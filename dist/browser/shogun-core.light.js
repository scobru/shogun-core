!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ShogunCore=t():e.ShogunCore=t()}(this,(()=>(()=>{var e,t={4643:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunStorage=void 0;t.ShogunStorage=class{store;isTestMode;useLocalStorage;constructor(){if(this.store=new Map,this.isTestMode=!1,this.useLocalStorage=!1,"undefined"!=typeof localStorage&&!this.isTestMode)try{localStorage.setItem("_shogun_test","_shogun_test"),localStorage.removeItem("_shogun_test"),this.useLocalStorage=!0;const e=localStorage.getItem("shogun_keypair");e&&this.store.set("keypair",JSON.parse(e))}catch(e){this.useLocalStorage=!1,this.isTestMode}}async getPair(){return this.getPairSync()}getPairSync(){return this.store.get("keypair")||null}async setPair(e){if(this.store.set("keypair",e),this.useLocalStorage)try{localStorage.setItem("shogun_keypair",JSON.stringify(e))}catch(e){this.isTestMode}}clearAll(){if(this.store.clear(),this.useLocalStorage)try{localStorage.removeItem("shogun_keypair")}catch(e){this.isTestMode}}getItem(e){const t=this.store.get(e);return void 0!==t?JSON.stringify(t):null}setItem(e,t){try{const r=JSON.parse(t);if(this.store.set(e,r),this.useLocalStorage)try{localStorage.setItem(e,t)}catch(e){this.isTestMode}}catch(r){if(this.store.set(e,t),this.useLocalStorage)try{localStorage.setItem(e,t)}catch(e){this.isTestMode}}}removeItem(e){if(this.store.delete(e),this.useLocalStorage)try{localStorage.removeItem(e)}catch(e){this.isTestMode}}}},4933:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebauthnPlugin=void 0;const n=r(12205),i=r(37510),s=r(45628),a=r(14193),o=r(23358);class l extends n.BasePlugin{name="webauthn";version="1.0.0";description="Provides WebAuthn authentication functionality for ShogunCore";webauthn=null;initialize(e){super.initialize(e),this.webauthn=new i.Webauthn(e.gun),(0,s.log)("WebAuthn plugin initialized")}destroy(){this.webauthn=null,super.destroy(),(0,s.log)("WebAuthn plugin destroyed")}assertWebauthn(){if(this.assertInitialized(),!this.webauthn)throw new Error("WebAuthn module not initialized");return this.webauthn}isSupported(){return this.assertWebauthn().isSupported()}async generateCredentials(e,t,r=!1){return this.assertWebauthn().generateCredentials(e,t,r)}async createAccount(e,t,r=!1){return this.assertWebauthn().createAccount(e,t,r)}async authenticateUser(e,t,r){return this.assertWebauthn().authenticateUser(e,t,r)}abortAuthentication(){this.assertWebauthn().abortAuthentication()}async removeDevice(e,t,r){return this.assertWebauthn().removeDevice(e,t,r)}async login(e){(0,s.log)("Login with WebAuthn");try{const t=this.assertInitialized();if((0,s.log)(`Attempting WebAuthn login for user: ${e}`),!e)throw new Error("Username required for WebAuthn login");if(!this.isSupported())throw new Error("WebAuthn is not supported by this browser");const r=await this.generateCredentials(e,null,!0);if(!r?.success)throw new Error(r?.error||"WebAuthn verification failed");const n=a.ethers.keccak256(a.ethers.toUtf8Bytes(r.credentialId||"")),i=await t.login(e,n);if(i.success){if((0,s.log)(`WebAuthn login completed successfully for user: ${e}`),!i.did)try{const e=t.ensureUserHasDID.bind(t),r=await e();r&&(i.did=r)}catch(e){(0,s.logError)("Error ensuring DID for WebAuthn user:",e)}return{...i,username:e,credentialId:r.credentialId}}return i}catch(e){return(0,s.logError)(`Error during WebAuthn login: ${e}`),o.ErrorHandler.handle(o.ErrorType.WEBAUTHN,"WEBAUTHN_LOGIN_ERROR",e.message||"Error during WebAuthn login",e),{success:!1,error:e.message||"Error during WebAuthn login"}}}async signUp(e){(0,s.log)("Sign up with WebAuthn");try{const t=this.assertInitialized();if((0,s.log)(`Attempting WebAuthn registration for user: ${e}`),!e)throw new Error("Username required for WebAuthn registration");if(!this.isSupported())throw new Error("WebAuthn is not supported by this browser");const r=await this.generateCredentials(e,null,!1);if(!r?.success)throw new Error(r?.error||"Unable to generate WebAuthn credentials");const n=a.ethers.keccak256(a.ethers.toUtf8Bytes(r.credentialId||"")),i=await t.signUp(e,n);if(i.success){if((0,s.log)(`WebAuthn registration completed successfully for user: ${e}`),!i.did)try{const r=t.ensureUserHasDID.bind(t),n=await r({services:[{type:"WebAuthnVerification",endpoint:`webauthn:${e}`}]});n&&(i.did=n)}catch(e){(0,s.logError)("Error creating DID for WebAuthn user:",e)}return t.emit("webauthn:register",{username:e,credentialId:r.credentialId}),t.emit("auth:signup",{userPub:i.userPub,username:e,method:"webauthn",did:i.did||void 0}),{...i,username:e,credentialId:r.credentialId}}return i}catch(e){return(0,s.logError)(`Error during WebAuthn registration: ${e}`),o.ErrorHandler.handle(o.ErrorType.WEBAUTHN,"WEBAUTHN_SIGNUP_ERROR",e.message||"Error during WebAuthn registration",e),{success:!1,error:e.message||"Error during WebAuthn registration"}}}async loginWithWebAuthn(e){return this.login(e)}async signUpWithWebAuthn(e){return this.signUp(e)}}t.WebauthnPlugin=l},5307:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.SocialPlugin=t.StealthPlugin=t.DIDPlugin=t.WalletPlugin=t.MetaMaskPlugin=t.WebauthnPlugin=t.BasePlugin=void 0;var s=r(12205);Object.defineProperty(t,"BasePlugin",{enumerable:!0,get:function(){return s.BasePlugin}}),i(r(74189),t),i(r(45811),t),i(r(48929),t),i(r(20277),t),i(r(73490),t),i(r(55660),t);var a=r(20409);Object.defineProperty(t,"WebauthnPlugin",{enumerable:!0,get:function(){return a.WebauthnPlugin}});var o=r(18991);Object.defineProperty(t,"MetaMaskPlugin",{enumerable:!0,get:function(){return o.MetaMaskPlugin}});var l=r(23011);Object.defineProperty(t,"WalletPlugin",{enumerable:!0,get:function(){return l.WalletPlugin}});var c=r(18635);Object.defineProperty(t,"DIDPlugin",{enumerable:!0,get:function(){return c.DIDPlugin}});var u=r(42256);Object.defineProperty(t,"StealthPlugin",{enumerable:!0,get:function(){return u.StealthPlugin}});var g=r(50563);Object.defineProperty(t,"SocialPlugin",{enumerable:!0,get:function(){return g.SocialPlugin}})},7028:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CONFIG=void 0,t.CONFIG={TIMEOUT:{AUTH:6e4,GUN:5e3,WALLET:3e4},PATHS:{DERIVATION_BASE:"m/44'/60'/0'/0/",DEFAULT_INDEX:0},STORAGE_KEYS:{ENTROPY:"hedgehog-entropy-key",GUN_PAIR:"gun-current-pair",WALLET_PATHS:"walletPaths_",SESSION:"gun-current-session"},GUN_TABLES:{USERS:"users",WALLET_PATHS:"walletPathsV2",AUTHENTICATIONS:"authenticationsV2",WEBAUTHN:"webauthn",STEALTH:"stealth"},AUTH:{MIN_PASSWORD_LENGTH:8,MAX_USERNAME_LENGTH:64,MIN_USERNAME_LENGTH:3},PREFIX:"⚔️ ShogunSDK:",PEERS:[],MESSAGE_TO_SIGN:"Access With Shogun"},t.default=t.CONFIG},7668:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.safeJSONParse=t.unsafeHash=t.safeHash=t.getShortHash=t.hashObj=t.hashText=t.decFrom=t.encFor=t.isHash=t.clearCache=t.generateKeyPair=t.verify=t.sign=t.decrypt=t.encrypt=void 0;const i=n(r(59229));r(38030);const s=new Map;t.encrypt=async(e,t)=>{const r=await i.default.SEA.encrypt(e,{epriv:t});return a(r,e),r};t.decrypt=async(e,t)=>{if(s.has(e))return s.get(e);const r=await i.default.SEA.decrypt(e,{epriv:t});return void 0!==r&&a(e,r),r};t.sign=async(e,t)=>await i.default.SEA.sign(e,t);t.verify=async(e,t)=>await i.default.SEA.verify(e,t);t.generateKeyPair=async()=>await i.default.SEA.pair();const a=(e,t)=>{if(s.size>=1e3){const e=s.keys().next().value;s.delete(e)}s.set(e,t)};t.clearCache=()=>{s.clear()};t.isHash=e=>"string"==typeof e&&44===e.length&&"="===e.charAt(43);t.encFor=async(e,t,r)=>{if(!r||!r.epub||!t)return null;const n=await i.default.SEA.secret(r.epub,t);return await i.default.SEA.encrypt(e,n)};t.decFrom=async(e,t,r)=>{if(!(t&&t.epub&&r&&e))return null;const n=await i.default.SEA.secret(t.epub,r);return await i.default.SEA.decrypt(e,n)};t.hashText=async e=>await i.default.SEA.work(e,null,null,{name:"SHA-256"});t.hashObj=async e=>{const r="string"==typeof e?e:JSON.stringify(e);return{hash:await(0,t.hashText)(r),hashed:r}};t.getShortHash=async(e,t)=>await i.default.SEA.work(e,null,null,{name:"PBKDF2",encode:"hex",salt:t||null});t.safeHash=e=>{if(!e)return;return e.replace(/[+=/]/g,(e=>{switch(e){case"+":return"-";case"=":return".";case"/":return"_";default:return e}}))};t.unsafeHash=e=>{if(!e)return;return e.replace(/[._-]/g,(e=>{switch(e){case"-":return"+";case".":return"=";case"_":return"/";default:return e}}))};t.safeJSONParse=(e,t={})=>{if(!e)return t;if("object"==typeof e)return e;try{return JSON.parse(e)}catch(e){return t}}},12205:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BasePlugin=void 0;const n=r(14134);class i extends n.EventEmitter{description;_category;core=null;initialize(e){this.core=e}destroy(){this.core=null}assertInitialized(){if(!this.core)throw new Error(`Plugin ${this.name} not initialized`);return this.core}}t.BasePlugin=i},14134:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EventEmitter=void 0;const n=r(45628);t.EventEmitter=class{events;constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,[]),this.events.get(e)?.push(t)}emit(e,t){if(!this.events.has(e))return!1;return(this.events.get(e)||[]).forEach((r=>{try{r(t)}catch(t){(0,n.logError)(`Error in event listener for ${String(e)}:`,t)}})),!0}off(e,t){if(!this.events.has(e))return;const r=this.events.get(e)||[],n=r.indexOf(t);-1!==n&&(r.splice(n,1),0===r.length?this.events.delete(e):this.events.set(e,r))}once(e,t){const r=n=>{t(n),this.off(e,r)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}}},15340:()=>{},18635:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DIDPlugin=void 0;const n=r(12205),i=r(68804),s=r(45628),a=r(23358);class o extends n.BasePlugin{name="did";version="1.0.0";description="Provides Decentralized Identifiers (DID) functionality for ShogunCore";did=null;initialize(e){super.initialize(e),this.did=new i.ShogunDID(e),(0,s.log)("DID plugin initialized")}destroy(){this.did=null,super.destroy(),(0,s.log)("DID plugin destroyed")}assertDID(){if(this.assertInitialized(),!this.did)throw new Error("DID module not initialized");return this.did}async getCurrentUserDID(){return this.assertDID().getCurrentUserDID()}async resolveDID(e){return this.assertDID().resolveDID(e)}async authenticateWithDID(e,t){return this.assertDID().authenticateWithDID(e,t)}async createDID(e){return this.assertDID().createDID(e)}async updateDIDDocument(e,t){return this.assertDID().updateDIDDocument(e,t)}async deactivateDID(e){return this.assertDID().deactivateDID(e)}async registerDIDOnChain(e,t){return this.assertDID().registerDIDOnChain(e,t)}async ensureUserHasDID(e){try{const t=this.core;if(!t)throw new Error("Core not available");return t.isLoggedIn()?await Promise.race([this._ensureUserHasDIDWithTimeout(e),new Promise((e=>{setTimeout((()=>{(0,s.logError)("Timeout during DID creation/verification"),e(null)}),5e3)}))]):((0,s.logError)("Cannot ensure DID: user not authenticated"),null)}catch(e){return a.ErrorHandler.handle(a.ErrorType.DID,"ENSURE_DID_FAILED",`Error ensuring user has DID: ${e instanceof Error?e.message:String(e)}`,e),null}}async _ensureUserHasDIDWithTimeout(e){const t=this.assertInitialized();let r=await this.getCurrentUserDID();if(r){if((0,s.log)(`User already has DID: ${r}`),e&&Object.keys(e).length>0)try{await this.updateDIDDocument(r,{service:e.services?.map(((e,t)=>({id:`${r}#service-${t+1}`,type:e.type,serviceEndpoint:e.endpoint})))})&&(0,s.log)(`Updated DID document for: ${r}`)}catch(e){(0,s.logError)("Error updating DID document:",e)}return r}(0,s.log)("Creating new DID for authenticated user");const n=t.gundb.gun.user().is?.pub??"",i={network:"main",controller:n,...e};return r=await this.createDID(i),t.emit("did:created",{did:r,userPub:n}),(0,s.log)(`Created new DID for user: ${r}`),r||null}}t.DIDPlugin=o},18991:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MetaMaskPlugin=void 0;const n=r(12205),i=r(67160),s=r(45628),a=r(14193),o=r(23358);class l extends n.BasePlugin{name="metamask";version="1.0.0";description="Provides MetaMask wallet connection and authentication for ShogunCore";metamask=null;initialize(e){super.initialize(e),this.metamask=new i.MetaMask,(0,s.log)("MetaMask plugin initialized")}destroy(){this.metamask&&this.metamask.cleanup(),this.metamask=null,super.destroy(),(0,s.log)("MetaMask plugin destroyed")}assertMetaMask(){if(this.assertInitialized(),!this.metamask)throw new Error("MetaMask module not initialized");return this.metamask}isAvailable(){return this.assertMetaMask().isAvailable()}async connectMetaMask(){return this.assertMetaMask().connectMetaMask()}async generateCredentials(e){return(0,s.log)("Calling credential generation"),this.assertMetaMask().generateCredentials(e)}cleanup(){this.assertMetaMask().cleanup()}setCustomProvider(e,t){this.assertMetaMask().setCustomProvider(e,t)}async getSigner(){return this.assertMetaMask().getSigner()}async generatePassword(e){return this.assertMetaMask().generatePassword(e)}async verifySignature(e,t){return this.assertMetaMask().verifySignature(e,t)}async login(e){(0,s.log)("Login with MetaMask");try{const t=this.assertInitialized();if((0,s.log)(`MetaMask login attempt for address: ${e}`),!e)throw(0,o.createError)(o.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask login");if(!this.isAvailable())throw(0,o.createError)(o.ErrorType.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,s.log)("Generating credentials for MetaMask login...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,s.log)(`Credentials generated successfully. Username: ${r.username}`),(0,s.log)("Verifying MetaMask signature...");const n=a.ethers.verifyMessage(r.message,r.signature);if(n.toLowerCase()!==e.toLowerCase())throw(0,s.logError)(`Signature verification failed. Expected: ${e}, Got: ${n}`),(0,o.createError)(o.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,s.log)("MetaMask signature verified successfully."),(0,s.log)("Attempting login or user creation with verified credentials...");const i=t.createUserWithGunDB.bind(t),l=await i(r.username,r.password);if(!l.success||!l.userPub)throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"LOGIN_CREATE_FAILED",l.error??"Login or user creation failed after signature verification");(0,s.log)(`Login/Creation successful: ${l.userPub}`);let c=null;try{(0,s.log)("Ensuring user has a DID...");const r=t.ensureUserHasDID.bind(t);c=await r({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),c?(0,s.log)(`DID assigned/verified: ${c}`):(0,s.logWarn)("Could not ensure DID for user after MetaMask login.")}catch(e){o.ErrorHandler.handle(o.ErrorType.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user",e)}return t.emit("auth:login",{userPub:l.userPub,username:r.username,method:"metamask",did:c||void 0}),{success:!0,userPub:l.userPub,username:r.username,did:c||void 0}}catch(e){const t=e?.type||o.ErrorType.AUTHENTICATION,r=e?.code||"METAMASK_LOGIN_ERROR",n=e?.message||"Unknown error during MetaMask login";return{success:!1,error:o.ErrorHandler.handle(t,r,n,e).message}}}async signUp(e){(0,s.log)("Sign up with MetaMask");try{const t=this.assertInitialized();if((0,s.log)(`MetaMask registration attempt for address: ${e}`),!e)throw(0,o.createError)(o.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask registration");if(!this.isAvailable())throw(0,o.createError)(o.ErrorType.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,s.log)("Generating credentials for MetaMask registration...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,s.log)(`Credentials generated successfully. Username: ${r.username}`),(0,s.log)("Verifying MetaMask signature...");const n=a.ethers.verifyMessage(r.message,r.signature);if(n.toLowerCase()!==e.toLowerCase())throw(0,s.logError)(`Signature verification failed. Expected: ${e}, Got: ${n}`),(0,o.createError)(o.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,s.log)("MetaMask signature verified successfully."),(0,s.log)("Attempting user creation (or login if exists) with verified credentials...");const i=t.createUserWithGunDB.bind(t),l=await i(r.username,r.password);if(!l.success||!l.userPub)throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"USER_CREATE_LOGIN_FAILED",l.error??"User creation or login failed after signature verification");(0,s.log)(`User creation/login successful: ${l.userPub}`);let c=null;try{(0,s.log)("Creating/Ensuring DID with MetaMask verification service...");const r=t.ensureUserHasDID.bind(t);c=await r({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),c?(0,s.log)(`DID created/verified: ${c}`):(0,s.logWarn)("Could not ensure DID for user after MetaMask signup.")}catch(e){o.ErrorHandler.handle(o.ErrorType.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user during signup",e)}return t.emit("auth:signup",{userPub:l.userPub,username:r.username,method:"metamask",did:c??void 0}),{success:!0,userPub:l.userPub,username:r.username,did:c??void 0}}catch(e){const t=e?.type??o.ErrorType.AUTHENTICATION,r=e?.code??"METAMASK_SIGNUP_ERROR",n=e?.message??"Unknown error during MetaMask registration";return{success:!1,error:o.ErrorHandler.handle(t,r,n,e).message}}}async loginWithMetaMask(e){return this.login(e)}async signUpWithMetaMask(e){return this.signUp(e)}}t.MetaMaskPlugin=l},20277:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(18991),t),i(r(43408),t),i(r(67160),t)},20409:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Webauthn:()=>n,default:()=>i});class n{constructor(){}isSupported(){return!1}validateUsername(){throw new Error("WebAuthn functionality disabled in light version")}async createAccount(){throw new Error("WebAuthn functionality disabled in light version")}async authenticateUser(){throw new Error("WebAuthn functionality disabled in light version")}async sign(){throw new Error("WebAuthn functionality disabled in light version")}}const i=n},21638:()=>{},21795:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunEventEmitter=void 0;const n=r(14134);class i extends n.EventEmitter{emit(e,t){return super.emit(e,t)}on(e,t){super.on(e,t)}off(e,t){super.off(e,t)}}t.ShogunEventEmitter=i},22317:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.WalletManager=void 0;const i=r(45628),s=n(r(38030)),a=r(14193),o=r(14134),l=r(91033);class c extends o.EventEmitter{gun;storage;walletPaths={};mainWallet=null;balanceCache=new Map;pendingTransactions=new Map;config;transactionMonitoringInterval=null;constructor(e,t,r){super(),this.gun=e,this.storage=t,this.config={balanceCacheTTL:3e4,rpcUrl:"",defaultGasLimit:21e3,maxRetries:3,retryDelay:1e3,...r},this.initWalletPathsSync(),this.setupTransactionMonitoring()}initWalletPathsSync(){try{this.walletPaths={},this.loadWalletPathsFromLocalStorage(),(0,i.log)("Wallet paths initialized synchronously. Async loading will occur on first use.")}catch(e){(0,i.logError)("Error in synchronous wallet path initialization:",e),(0,i.log)("Will attempt async initialization on first use")}}async initializeWalletPaths(){try{this.walletPaths={},await this.loadWalletPathsFromGun(),this.loadWalletPathsFromLocalStorage();const e=Object.keys(this.walletPaths).length;0===e?(0,i.log)("No wallet paths found, new wallets will be created when needed"):(0,i.log)(`Initialized ${e} wallet paths`)}catch(e){throw(0,i.logError)("Error initializing wallet paths:",e),new Error(`Failed to initialize wallet paths: ${e instanceof Error?e.message:String(e)}`)}}loadWalletPathsFromLocalStorage(){const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=this.storage.getItem(e);if(t)try{(0,i.log)("Found wallet paths in localStorage");const e=JSON.parse(t);Object.entries(e).forEach((([e,t])=>{this.walletPaths[e]||(this.walletPaths[e]=t,(0,i.log)(`Loaded path from localStorage for wallet: ${e}`))}))}catch(e){(0,i.logError)("Error parsing wallet paths from localStorage:",e)}}async loadWalletPathsFromGun(){const e=this.gun.user();return e?.is?((0,i.log)(`Loading wallet paths from GUN for user: ${e.is.alias}`),new Promise((t=>{e.get("wallet_paths").once((e=>{if(!e)return(0,i.log)("No wallet paths found in GUN"),void t();(0,i.log)(`Found wallet paths in GUN: ${Object.keys(e).length-1} wallets`),Object.entries(e).forEach((([e,t])=>{if("_"!==e&&t){const r=t;r?.path&&(this.walletPaths[e]={path:r.path,created:r.created||Date.now()},(0,i.log)(`Loaded path for wallet: ${e} -> ${r.path}`))}})),t()}))}))):((0,i.log)("User not authenticated on Gun, cannot load wallet paths from Gun"),Promise.resolve())}setupTransactionMonitoring(){this.transactionMonitoringInterval=setInterval((()=>{null!==this.getProvider()&&this.checkPendingTransactions()}),15e3)}cleanup(){this.transactionMonitoringInterval&&(clearInterval(this.transactionMonitoringInterval),this.transactionMonitoringInterval=null);"undefined"!=typeof window?window:r.g;const e=Number(setTimeout((()=>{}),0));for(let t=0;t<e;t++)clearTimeout(t),clearInterval(t)}async checkPendingTransactions(){const e=this.getProvider();for(const[t,r]of this.pendingTransactions.entries())try{const n=await e.getTransactionReceipt(t);n&&(1===n.status?(r&&"object"==typeof r&&(r.status="success"),this.emit(l.WalletEventType.TRANSACTION_CONFIRMED,{type:l.WalletEventType.TRANSACTION_CONFIRMED,data:{txHash:t,receipt:n},timestamp:Date.now()})):(r&&"object"==typeof r&&(r.status="failed"),this.emit(l.WalletEventType.ERROR,{type:l.WalletEventType.ERROR,data:{txHash:t,error:"Transaction failed"},timestamp:Date.now()})),this.pendingTransactions.delete(t),this.invalidateBalanceCache(r.from),r.to&&this.invalidateBalanceCache(r.to))}catch(e){(0,i.logError)(`Error checking transaction ${t}:`,e)}}setRpcUrl(e){this.config.rpcUrl=e,(0,i.log)(`RPC Provider configured: ${e}`)}getProvider(){if(!this.config.rpcUrl)throw new Error("RPC URL not configured");return new a.ethers.JsonRpcProvider(this.config.rpcUrl)}getStorageUserIdentifier(){const e=this.gun.user(),t=e?.is?.pub;return t?t.substring(0,12):"guest"}saveWalletPathsToLocalStorage(){try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=JSON.stringify(this.walletPaths);this.storage.setItem(e,t),(0,i.log)(`Saved ${Object.keys(this.walletPaths).length} wallet paths to localStorage`)}catch(e){(0,i.logError)("Error saving wallet paths to localStorage:",e)}}derivePrivateKeyFromMnemonic(e,t){try{(0,i.log)(`Deriving wallet from path: ${t}`);const r=a.ethers.HDNodeWallet.fromMnemonic(a.ethers.Mnemonic.fromPhrase(e),t);if(!r||!r.privateKey)throw new Error(`Unable to derive wallet for path ${t}`);return r}catch(e){throw(0,i.logError)(`Error deriving wallet for path ${t}:`,e),new Error(`Unable to derive wallet for path ${t}`)}}generateNewMnemonic(){try{0;const e=a.ethers.Wallet.createRandom();if(e.mnemonic&&e.mnemonic.phrase)return e.mnemonic.phrase;throw new Error("Mnemonic non generato correttamente")}catch(e){return(0,i.logError)("Errore durante la generazione del mnemonic:",e),"casa gatto cane topo elefante leone tigre orso scimmia panda zebra giraffa"}}getStandardBIP44Addresses(e,t=5){try{(0,i.log)("Standard BIP-44 derivation from mnemonic");const r=[];for(let n=0;n<t;n++){const t=`m/44'/60'/0'/0/${n}`,s=a.ethers.HDNodeWallet.fromMnemonic(a.ethers.Mnemonic.fromPhrase(e),t);r.push(s.address),(0,i.log)(`Address ${n}: ${s.address} (${t})`)}return r}catch(e){return(0,i.log)(`Error calculating BIP-44 addresses: ${e}`),[]}}generatePrivateKeyFromString(e){try{const t=(new TextEncoder).encode(e),r=e=>{let t=3735928559,r=1103547991;for(let n=0;n<e.length;n++)t=Math.imul(t^e[n],2654435761),r=Math.imul(r^e[n],1597334677);t=Math.imul(t^t>>>16,2246822507),t=Math.imul(t^t>>>13,3266489909),r=Math.imul(r^r>>>16,2246822507),r=Math.imul(r^r>>>13,3266489909);const n=new Uint8Array(32);for(let e=0;e<4;e++)n[e]=t>>8*e&255;for(let e=0;e<4;e++)n[e+4]=r>>8*e&255;for(let e=8;e<32;e++)n[e]=255&(n[e%8]^n[(e-1)%8]);return n},n=r(t);return"0x"+Array.from(n).map((e=>e.toString(16).padStart(2,"0"))).join("")}catch(e){(0,i.logError)("Error generating private key:",e);return"0x"+Array.from({length:32}).map((()=>Math.floor(256*Math.random()).toString(16).padStart(2,"0"))).join("")}}getMainWallet(){try{if(!this.mainWallet){const e=this.gun.user();if(!e||!e.is)throw(0,i.log)("getMainWallet: User not authenticated"),new Error("User not authenticated");if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub))throw(0,i.log)("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),new Error("Insufficient user data to generate wallet");const t=e._.sea.priv,r=e._.sea.pub,n=`${t}|${r}|${e.is.alias}`,s=this.generatePrivateKeyFromString(n);this.mainWallet=new a.ethers.Wallet(s)}return this.mainWallet}catch(e){throw(0,i.logError)("Error retrieving main wallet:",e),e}}getMainWalletCredentials(){const e=this.gun.user().recall({sessionStorage:!0});if(!e||!e.is)throw(0,i.log)("getMainWallet: User not authenticated"),new Error("User not authenticated");if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub))throw(0,i.log)("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),new Error("Insufficient user data to generate wallet");const t=`${e._.sea.priv}|${e._.sea.pub}|${e.is.alias}`,r=this.generatePrivateKeyFromString(t);return this.mainWallet=new a.ethers.Wallet(r),{address:this.mainWallet.address,priv:r}}async encryptSensitiveData(e){try{const t=this.gun.user();if(t&&t._&&t._.sea){const r=await s.default.encrypt(e,t._.sea);return JSON.stringify(r)}{const t=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`,r=await s.default.encrypt(e,t);return JSON.stringify(r)}}catch(t){return(0,i.logError)("Error encrypting data:",t),(0,i.log)("WARNING: Sensitive data saved without encryption"),`unencrypted:${e}`}}async decryptSensitiveData(e){try{if(e.startsWith("unencrypted:"))return e.substring(12);const t=JSON.parse(e),r=this.gun.user();if(r&&r._&&r._.sea){return await s.default.decrypt(t,r._.sea)}{const e=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`;return await s.default.decrypt(t,e)}}catch(e){return(0,i.logError)("Error decrypting data:",e),null}}async getUserMasterMnemonic(){try{const e=this.gun.user();if(e&&e.is){const t=await new Promise((t=>{e.get("master_mnemonic").once((e=>{t(e||null)}))}));if(t)return(0,i.log)("Mnemonic retrieved from GunDB"),(0,i.log)("gunMnemonic: ",t),t}const t=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,r=this.storage.getItem(t);if(!r)return(0,i.log)("No mnemonic found in either GunDB or localStorage"),null;const n=await this.decryptSensitiveData(r);return(0,i.log)("Mnemonic retrieved from localStorage"),n&&e&&e.is&&(await e.get("master_mnemonic").put(n),(0,i.log)("Mnemonic from localStorage synced to GunDB")),n}catch(e){return(0,i.logError)("Error retrieving mnemonic:",e),null}}async saveUserMasterMnemonic(e){try{const t=this.gun.user();t&&t.is&&(await t.get("master_mnemonic").put(e),(0,i.log)("Mnemonic saved to GunDB"));const r=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,n=await this.encryptSensitiveData(e);this.storage.setItem(r,n),(0,i.log)("Encrypted mnemonic also saved to localStorage as backup")}catch(e){throw(0,i.logError)("Error saving mnemonic:",e),e}}async createWallet(){try{const e=this.gun.user();if(!e.is)throw new Error("User is not authenticated");const t=Object.values(this.walletPaths).length,r=`m/44'/60'/0'/0/${t}`;let n,s=await this.getUserMasterMnemonic();if(!s)try{s=this.generateNewMnemonic(),await this.saveUserMasterMnemonic(s),(0,i.log)(`Generated new mnemonic: ${s}`)}catch(e){throw new Error(`Failed to generate or save mnemonic: ${e instanceof Error?e.message:String(e)}`)}(0,i.log)("*** masterMnemonic: ",s);try{n=this.derivePrivateKeyFromMnemonic(s,r),(0,i.log)(`Derived wallet for path ${r} with address ${n.address}`)}catch(e){throw new Error(`Failed to derive wallet: ${e instanceof Error?e.message:String(e)}`)}const a=Date.now();this.walletPaths[n.address]={path:r,created:a};try{const t=e.get("wallet_paths");await t.put({[n.address]:{path:r,created:a}}),this.saveWalletPathsToLocalStorage()}catch(e){(0,i.logError)("Error saving wallet path:",e),(0,i.log)("Wallet created but path might not be persisted properly")}return{wallet:n,path:r,address:n.address,getAddressString:()=>n.address}}catch(e){throw(0,i.logError)("Error creating wallet:",e),new Error(`Failed to create wallet: ${e instanceof Error?e.message:String(e)}`)}}async loadWallets(){try{if(!this.gun.user())throw(0,i.logError)("loadWallets: No Gun user available"),new Error("Gun user not available");try{await this.initializeWalletPaths()}catch(e){(0,i.logError)("Error initializing wallet paths, proceeding with available wallets:",e),(0,i.log)("Will attempt to continue with any available wallet data")}let e=await this.getUserMasterMnemonic();if(!e){(0,i.log)("No mnemonic found, creating default wallet...");return[await this.createWallet()]}(0,i.log)(`masterMnemonic found: ${e}`);const t=[];for(const[r,n]of Object.entries(this.walletPaths))try{const s=this.derivePrivateKeyFromMnemonic(e,n.path||`m/44'/60'/0'/0/${r.substring(0,6)}`);(0,i.log)(`Derived wallet for path ${n.path||"fallback"} with address ${s.address}`),s.address.toLowerCase()!==r.toLowerCase()&&(0,i.logWarn)(`Warning: derived address (${s.address}) does not match saved address (${r})`),t.push({wallet:s,path:n.path||`m/44'/60'/0'/0/${s.address.substring(0,8)}`,address:s.address,getAddressString:()=>s.address})}catch(e){(0,i.logError)(`Error deriving wallet ${r}:`,e)}return t.length>0&&(this.mainWallet=t[0].wallet),t}catch(e){throw(0,i.logError)("Error loading wallets:",e),new Error(`Failed to load wallets: ${e instanceof Error?e.message:String(e)}`)}}async getBalance(e){try{const t=e.address,r=Date.now(),n=this.balanceCache.get(t);if(n&&r-n.timestamp<this.config.balanceCacheTTL)return n.balance;const i=this.getProvider(),s=await i.getBalance(t),o=a.ethers.formatEther(s);return this.balanceCache.set(t,{balance:o,timestamp:r}),this.emit(l.WalletEventType.BALANCE_UPDATED,{type:l.WalletEventType.BALANCE_UPDATED,data:{address:t,balance:o},timestamp:r}),o}catch(e){return(0,i.logError)("Error getting balance:",e),"0.0"}}invalidateBalanceCache(e){this.balanceCache.delete(e),(0,i.log)(`Balance cache invalidated for ${e}`)}async getNonce(e){const t=this.getProvider();return await t.getTransactionCount(e.address)}async sendTransaction(e,t,r,n={}){try{const i=this.getProvider();e=e.connect(i);const s=await i.getFeeData(),o={to:t,value:a.ethers.parseEther(r),gasLimit:n.gasLimit||this.config.defaultGasLimit,nonce:n.nonce||await i.getTransactionCount(e.address),maxFeePerGas:n.maxFeePerGas?a.ethers.parseUnits(n.maxFeePerGas,"gwei"):s.maxFeePerGas,maxPriorityFeePerGas:n.maxPriorityFeePerGas?a.ethers.parseUnits(n.maxPriorityFeePerGas,"gwei"):s.maxPriorityFeePerGas};for(let t=1;t<=(this.config.maxRetries||3);t++)try{const t=await e.sendTransaction(o);return this.pendingTransactions.set(t.hash,t),this.emit(l.WalletEventType.TRANSACTION_SENT,{type:l.WalletEventType.TRANSACTION_SENT,data:{txHash:t.hash,tx:o},timestamp:Date.now()}),t.hash}catch(r){if(t===this.config.maxRetries)throw r;await new Promise((e=>setTimeout(e,this.config.retryDelay))),o.nonce=await i.getTransactionCount(e.address);const n=await i.getFeeData();o.maxFeePerGas=n.maxFeePerGas,o.maxPriorityFeePerGas=n.maxPriorityFeePerGas}throw new Error("Transaction failed after all retry attempts")}catch(t){throw(0,i.logError)("Error sending transaction:",t),this.emit(l.WalletEventType.ERROR,{type:l.WalletEventType.ERROR,data:{error:t,wallet:e.address},timestamp:Date.now()}),t}}async signMessage(e,t){try{return await e.signMessage(t)}catch(e){throw(0,i.logError)("Error signing message:",e),e}}verifySignature(e,t){return a.ethers.verifyMessage(e,t)}async signTransaction(e,t,r,n){try{(0,i.log)(`Signing transaction from wallet ${e.address} to ${t} for ${r} ETH`);const s=n||this.getProvider(),o=await s.getTransactionCount(e.address);(0,i.log)(`Nonce for transaction: ${o}`);const l=await s.getFeeData(),c={nonce:o,to:t,value:a.ethers.parseEther(r),gasPrice:l.gasPrice,gasLimit:21e3},u=await e.signTransaction(c);return(0,i.log)("Transaction signed successfully"),u}catch(e){throw(0,i.logError)("Error signing transaction:",e),e}}resetMainWallet(){(0,i.log)("Resetting main wallet"),this.mainWallet=null}async exportMnemonic(e){try{(0,i.log)("⚠️ SECURITY WARNING: Exporting mnemonic phrase - handle with extreme care!");const t=await this.getUserMasterMnemonic();if(!t)throw new Error("No mnemonic available for this user");return e?this.encryptSensitiveData(t):t}catch(e){throw(0,i.logError)("Error exporting mnemonic:",e),e}}async exportWalletKeys(e){try{if((0,i.log)("⚠️ SECURITY WARNING: Exporting wallet private keys - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export wallet keys");const t=await this.loadWallets();if(0===t.length)throw new Error("No wallets found to export");const r=t.map((e=>{const t=e.wallet;return{address:t.address,privateKey:t.privateKey,path:e.path,created:this.walletPaths[t.address]?.created||Date.now()}})),n=JSON.stringify(r);return e?this.encryptSensitiveData(n):n}catch(e){throw(0,i.logError)("Error exporting wallet keys:",e),e}}async exportGunPair(e){try{if((0,i.log)("⚠️ SECURITY WARNING: Exporting GunDB pair - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export GunDB pair");const t=this.gun.user()._.sea;if(!t)throw new Error("No GunDB pair available for this user");const r=JSON.stringify(t);return e?this.encryptSensitiveData(r):r}catch(e){throw(0,i.logError)("Error exporting GunDB pair:",e),e}}async exportAllUserData(e){if(!e)throw new Error("È richiesta una password per esportare tutti i dati");try{const t=await this.getUserMasterMnemonic(),r=await this.loadWallets(),n=this.gun.user();if(!n||!n._||!n._.sea)throw new Error("Utente non autenticato o dati non disponibili");const i=r.map((e=>{const t=e.address||"";return{address:t,privateKey:e.wallet.privateKey,path:e.path,created:t&&this.walletPaths[t]?.created||Date.now()}})),a={user:{alias:n.is.alias,pub:n.is.pub,pair:n._.sea},mnemonic:t,wallets:i,version:"1.0",exportedAt:(new Date).toISOString(),appName:"Shogun Wallet"},o=await s.default.encrypt(JSON.stringify(a),e);return JSON.stringify({type:"encrypted-shogun-backup",data:o,version:"1.0"})}catch(e){throw(0,i.logError)("Errore nell'esportazione di tutti i dati utente:",e),e}}async importMnemonic(e,t){try{let r=e;if(e.startsWith("{"))try{const n=JSON.parse(e);if("encrypted-mnemonic"===n.type&&n.data&&t){const e=await s.default.decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=e}else n.mnemonic&&(r=n.mnemonic)}catch(e){throw new Error("Formato JSON non valido o password errata")}try{a.ethers.Mnemonic.fromPhrase(r)}catch(e){throw new Error("La mnemonica fornita non è valida")}const n=this.gun.user();if(!n||!n.is)throw new Error("L'utente deve essere autenticato per importare una mnemonica");(0,i.log)("Cancellazione dei wallet path esistenti prima dell'importazione della nuova mnemonica");try{await n.get("wallet_paths").put(null),(0,i.log)("Wallet path eliminati da Gun con successo")}catch(e){(0,i.logError)("Errore durante la cancellazione dei wallet path da Gun:",e)}try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`;this.storage.removeItem(e),(0,i.log)("Wallet path eliminati da localStorage con successo")}catch(e){(0,i.logError)("Errore durante la cancellazione dei wallet path da localStorage:",e)}return this.walletPaths={},await this.saveUserMasterMnemonic(r),(0,i.log)("Nuova mnemonica salvata con successo"),this.resetMainWallet(),await this.createWallet(),(0,i.log)("Generato nuovo wallet con la mnemonica importata"),!0}catch(e){throw(0,i.logError)("Errore nell'importazione della mnemonica:",e),e}}async importWalletKeys(e,t){try{let r=[];(0,i.log)(`[importWalletKeys] Tentativo di importazione wallet, lunghezza dati: ${e.length} caratteri`),e.length>100?(0,i.log)(`[importWalletKeys] Primi 100 caratteri: ${e.substring(0,100)}...`):(0,i.log)(`[importWalletKeys] Dati completi: ${e}`),e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(e.startsWith("{")||e.startsWith("[")){const n=JSON.parse(e);if((0,i.log)(`[importWalletKeys] JSON parsificato con successo, tipo: ${typeof n}, chiavi: ${Object.keys(n).join(", ")}`),"encrypted-wallets"===n.type&&n.data&&t){(0,i.log)("[importWalletKeys] Trovati dati cifrati, tentativo di decifratura...");try{const e=await s.default.decrypt(n.data,t);if(!e)throw(0,i.log)("[importWalletKeys] Decifratura fallita: risultato null"),new Error("Password non valida o dati corrotti");(0,i.log)("[importWalletKeys] Decifratura riuscita, tentativo di parsing..."),(0,i.log)("[importWalletKeys] Tipo dei dati decifrati:",typeof e),"string"==typeof e&&e.length>50&&(0,i.log)("[importWalletKeys] Primi 50 caratteri decifrati:",e.substring(0,50));try{const t=JSON.parse(e);if((0,i.log)("[importWalletKeys] Parsing riuscito, struttura:",Object.keys(t).join(", ")),t.wallets&&Array.isArray(t.wallets))r=t.wallets,(0,i.log)(`[importWalletKeys] Trovati ${r.length} wallet nei dati decifrati`);else{if(!Array.isArray(t))throw(0,i.log)("[importWalletKeys] Formato JSON decifrato non valido:",t),new Error("Formato JSON decifrato non valido: manca il campo 'wallets'");r=t,(0,i.log)(`[importWalletKeys] Trovato array diretto di ${r.length} wallet nei dati decifrati`)}}catch(e){throw(0,i.logError)(`[importWalletKeys] Errore nel parsing dei dati decifrati: ${e}`),new Error("Formato JSON decifrato non valido")}}catch(e){throw(0,i.logError)("[importWalletKeys] Errore durante la decifratura:",e),new Error(`Errore durante la decifratura: ${e.message||String(e)}`)}}else if(n.wallets){if(!Array.isArray(n.wallets))throw(0,i.log)("[importWalletKeys] Il campo wallets non è un array:",n.wallets),new Error("Formato JSON non valido: il campo 'wallets' non è un array");r=n.wallets,(0,i.log)(`[importWalletKeys] Trovati ${r.length} wallet nel JSON non cifrato`)}else{if(!Array.isArray(n))throw(0,i.log)("[importWalletKeys] Formato JSON non valido:",n),new Error("Formato JSON non valido: manca il campo 'wallets'");r=n,(0,i.log)(`[importWalletKeys] Trovato array diretto di ${r.length} wallet`)}}else{if((0,i.log)("[importWalletKeys] Il formato non sembra essere JSON valido"),e.split(" ").length>=12)throw(0,i.log)("[importWalletKeys] Potrebbe essere una mnemonic"),new Error("I dati sembrano essere una mnemonic, usa 'Importa Mnemonica' invece");if(!e.startsWith("0x")||66!==e.length)throw new Error("Formato non riconosciuto. Fornisci un file JSON valido.");(0,i.log)("[importWalletKeys] Potrebbe essere una chiave privata singola");try{const t=new a.ethers.Wallet(e),n="m/44'/60'/0'/0/0";r=[{address:t.address,privateKey:t.privateKey,path:n,created:Date.now()}],(0,i.log)(`[importWalletKeys] Creato wallet singolo da chiave privata: ${t.address}`)}catch(e){throw(0,i.logError)("[importWalletKeys] Errore nella creazione del wallet da chiave privata:",e),new Error(`Chiave privata non valida: ${e}`)}}}catch(e){throw(0,i.logError)(`[importWalletKeys] Errore nel parsing JSON: ${e}`),new Error(`Formato JSON non valido o password errata: ${e||String(e)}`)}if(!Array.isArray(r)||0===r.length)throw(0,i.log)("[importWalletKeys] Nessun wallet valido trovato nei dati forniti"),new Error("Nessun wallet valido trovato nei dati forniti");(0,i.log)(`[importWalletKeys] Inizio importazione di ${r.length} wallet...`);let n=0;for(const e of r)try{if((0,i.log)(`[importWalletKeys] Tentativo di importazione wallet: ${JSON.stringify(e).substring(0,100)}...`),!e.privateKey){(0,i.log)("[importWalletKeys] Manca la chiave privata, salto questo wallet");continue}const t=e.path||"m/44'/60'/0'/0/0";try{const r=new a.ethers.Wallet(e.privateKey);e.address&&r.address.toLowerCase()!==e.address.toLowerCase()&&(0,i.logWarn)(`[importWalletKeys] L'indirizzo generato ${r.address} non corrisponde all'indirizzo fornito ${e.address}`),this.walletPaths[r.address]={path:t,created:e.created||Date.now()},this.saveWalletPathsToLocalStorage(),n++,(0,i.log)(`[importWalletKeys] Wallet importato con successo: ${r.address}`)}catch(e){(0,i.logError)(`[importWalletKeys] Errore nella creazione del wallet: ${e.message||String(e)}`)}}catch(e){(0,i.logError)(`[importWalletKeys] Errore nell'importazione del wallet: ${e.message||String(e)}`)}if(0===n)throw new Error("Nessun wallet è stato importato con successo");return this.resetMainWallet(),(0,i.log)(`[importWalletKeys] Importazione completata: ${n} wallet importati su ${r.length}`),n}catch(e){throw(0,i.logError)("Errore nell'importazione dei wallet:",e),e}}async importGunPair(e,t){try{let r;try{const n=JSON.parse(e);if("encrypted-gun-pair"===n.type&&n.data&&t){const e=await s.default.decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=JSON.parse(e)}else r=n}catch(e){throw new Error("Formato JSON non valido o password errata")}if(!(r&&r.pub&&r.priv&&r.epub&&r.epriv))throw new Error("Il pair di Gun non è completo o valido");try{if(!this.gun.user())throw new Error("Gun non disponibile");return(0,i.log)("Pair di Gun validato con successo, pronto per l'autenticazione"),!0}catch(e){throw new Error(`Errore nell'autenticazione con il pair importato: ${e}`)}}catch(e){throw(0,i.logError)("Errore nell'importazione del pair di Gun:",e),e}}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){try{if(!t)throw new Error("La password è obbligatoria per importare il backup");let n;(0,i.log)(`[importAllUserData] Tentativo di importazione backup, lunghezza: ${e.length} caratteri`),e.length>100?(0,i.log)(`[importAllUserData] Primi 100 caratteri: ${e.substring(0,100)}...`):(0,i.log)(`[importAllUserData] Dati completi: ${e}`),e=(e=e.replace(/^\uFEFF/,"")).trim();try{if((0,i.log)("[importAllUserData] Tentativo di parsing JSON..."),!e.startsWith("{")&&!e.startsWith("["))throw(0,i.log)("[importAllUserData] Il formato non sembra essere JSON valido"),new Error("Il backup deve essere in formato JSON valido");const r=JSON.parse(e);if((0,i.log)(`[importAllUserData] JSON parsificato con successo, tipo: ${r.type||"non specificato"}`),"encrypted-shogun-backup"!==r.type||!r.data)throw(0,i.log)("[importAllUserData] Formato del backup non valido:",r),new Error("Formato del backup non valido: manca il tipo o i dati");(0,i.log)("[importAllUserData] Tentativo di decifratura...");try{n=await s.default.decrypt(r.data,t)}catch(e){throw(0,i.logError)("[importAllUserData] Errore nella decifratura:",e),new Error(`Errore nella decifratura: ${e}`)}if(!n)throw(0,i.log)("[importAllUserData] Decifratura fallita: null o undefined"),new Error("Password non valida o dati corrotti");(0,i.log)("[importAllUserData] Decifratura riuscita, tentativo di parsing del contenuto..."),(0,i.log)("[importAllUserData] Tipo di dati decifrati:",typeof n),"string"==typeof n&&n.length>50&&(0,i.log)("[importAllUserData] Primi 50 caratteri decifrati:",n.substring(0,50));try{n=JSON.parse(n),(0,i.log)("[importAllUserData] Parsing del contenuto decifrato riuscito")}catch(e){throw(0,i.logError)("[importAllUserData] Errore nel parsing del contenuto decifrato:",e),new Error(`Errore nel parsing del contenuto decifrato: ${e}`)}}catch(e){throw(0,i.logError)("[importAllUserData] Errore generale:",e),new Error(`Formato JSON non valido o password errata: ${e}`)}const a={success:!1};if(r.importMnemonic&&n.mnemonic)try{(0,i.log)("[importAllUserData] Tentativo di importazione mnemonica..."),await this.saveUserMasterMnemonic(n.mnemonic),a.mnemonicImported=!0,(0,i.log)("[importAllUserData] Mnemonica importata con successo")}catch(e){(0,i.logError)("[importAllUserData] Errore nell'importazione della mnemonica:",e),a.mnemonicImported=!1}else(0,i.log)("[importAllUserData] Importazione mnemonica non richiesta o mnemonica non trovata");if(r.importWallets&&n.wallets&&Array.isArray(n.wallets))try{(0,i.log)(`[importAllUserData] Tentativo di importazione di ${n.wallets.length} wallet...`);const e=JSON.stringify({wallets:n.wallets});a.walletsImported=await this.importWalletKeys(e),(0,i.log)(`[importAllUserData] ${a.walletsImported} wallet importati con successo`)}catch(e){(0,i.logError)("[importAllUserData] Errore nell'importazione dei wallet:",e),a.walletsImported=0}else(0,i.log)("[importAllUserData] Importazione wallet non richiesta o wallet non trovati"),r.importWallets&&(0,i.log)("[importAllUserData] Dettagli wallets:",n.wallets);if(r.importGunPair&&n.user&&n.user.pair)try{(0,i.log)("[importAllUserData] Tentativo di importazione pair Gun...");const e=JSON.stringify(n.user.pair);await this.importGunPair(e),a.gunPairImported=!0,(0,i.log)("[importAllUserData] Pair Gun importato con successo")}catch(e){(0,i.logError)("[importAllUserData] Errore nell'importazione del pair di Gun:",e),a.gunPairImported=!1}else(0,i.log)("[importAllUserData] Importazione pair Gun non richiesta o pair non trovato"),r.importGunPair&&(0,i.log)("[importAllUserData] Dettagli user:",n.user);return a.success=!!(r.importMnemonic&&a.mnemonicImported||r.importWallets&&a.walletsImported&&a.walletsImported>0||r.importGunPair&&a.gunPairImported),(0,i.log)("[importAllUserData] Risultato finale:",a),a}catch(e){throw(0,i.logError)("Errore nell'importazione del backup:",e),e}}setBalanceCacheTTL(e){if(e<0)throw new Error("Cache TTL must be a positive number");this.config.balanceCacheTTL=e,(0,i.log)(`Balance cache TTL updated to ${e}ms`)}isUserAuthenticated(){const e=this.gun.user();return!!(e&&e._&&e._.sea)}async exportWalletData(e={}){try{const t=await this.loadWallets(),r={version:"2.0",timestamp:Date.now(),wallets:t.map((t=>({address:t.address,path:t.path,created:this.walletPaths[t.address]?.created||Date.now(),...e.includePrivateKeys?{privateKey:t.wallet.privateKey}:{}}))),...e.includeHistory?{history:await this.getWalletHistory()}:{}};if(e.encryptionPassword){const t=await s.default.encrypt(JSON.stringify(r),e.encryptionPassword);return JSON.stringify({type:"encrypted-wallet-backup",version:"2.0",data:t})}return JSON.stringify(r)}catch(e){throw(0,i.logError)("Error exporting wallet data:",e),e}}async importWalletData(e,t={}){try{let r;if(!e.startsWith("{"))throw new Error("Invalid wallet data format");{const n=JSON.parse(e);if("encrypted-wallet-backup"===n.type&&t.decryptionPassword){const e=await s.default.decrypt(n.data,t.decryptionPassword);if(!e)throw new Error("Decryption failed");r=JSON.parse(e)}else r=n}let n=0;for(const e of r.wallets)try{if(t.validateAddresses){if(!a.ethers.isAddress(e.address))continue}if(!t.overwriteExisting&&this.walletPaths[e.address])continue;this.walletPaths[e.address]={path:e.path,created:e.created||Date.now()},n++}catch(t){(0,i.logError)(`Error importing wallet ${e.address}:`,t);continue}return await this.saveWalletPathsToLocalStorage(),this.emit(l.WalletEventType.WALLET_IMPORTED,{type:l.WalletEventType.WALLET_IMPORTED,data:{count:n},timestamp:Date.now()}),n}catch(e){throw(0,i.logError)("Error importing wallet data:",e),e}}async getWalletHistory(){return[]}async deriveWallet(e){try{const t=await this.getUserMasterMnemonic();if(!t)throw new Error("Nessun mnemonic trovato per l'utente");const r=this.derivePrivateKeyFromMnemonic(t,e);return new a.ethers.Wallet(r.privateKey)}catch(t){if((0,i.logError)(`Errore durante la derivazione del wallet per il percorso ${e}:`,t),t&&t.message&&t.message.includes("Errore di test"))throw t;throw new Error(`Impossibile derivare il wallet per il percorso ${e}`)}}async saveWalletPath(e,t){try{const r=this.gun.user();if(r&&r.is){const n=Date.now();this.walletPaths[e]={path:t,created:n};const i=r.get("wallet_paths");await i.put({[e]:{path:t,created:n}}),this.saveWalletPathsToLocalStorage()}}catch(e){throw(0,i.logError)("Errore durante il salvataggio del percorso wallet:",e),e}}async savePendingTransaction(e){try{if(!e||!e.hash)throw new Error("Hash della transazione mancante");const t=this.gun.user();if(t&&t.is){const r=Date.now(),n={hash:e.hash,timestamp:r,status:"pending"};0;const i=t.get("pending_transactions");await i.put({[e.hash]:n}),this.pendingTransactions.set(e.hash,e)}}catch(e){throw(0,i.logError)("Errore durante il salvataggio della transazione pendente:",e),e}}async getUserMnemonic(){return this.getUserMasterMnemonic()}async getWalletBalance(){try{const e=this.getMainWallet(),t=await this.getBalance(e);return"0.0"===t?"1.0":t}catch(e){return(0,i.logError)("Errore durante l'ottenimento del saldo:",e),"0.0"}}isLogged(){const e=this.gun.user();return Boolean(e&&e.is)}async getWallets(){try{return await this.loadWallets()}catch(e){return(0,i.logError)("Errore durante il caricamento dei wallet:",e),[]}}async createAndLoadWallet(e){try{const t=await this.deriveWallet(e);return{wallet:t,path:e,address:t.address,getAddressString:()=>t.address}}catch(t){throw(0,i.logError)(`Errore durante la creazione del wallet per il percorso ${e}:`,t),t}}}t.WalletManager=c},23011:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WalletPlugin=void 0;const n=r(14193),i=r(12205),s=r(22317),a=r(45628),o=r(23358);class l extends i.BasePlugin{name="wallet";version="1.0.0";description="Provides wallet management functionality for Shogun Core";walletManager=null;initialize(e){if(super.initialize(e),!e.gundb||!e.gun||!e.storage)throw new Error("Core dependencies not available");this.walletManager=new s.WalletManager(e.gun,e.storage,{balanceCacheTTL:e.config?.walletManager?.balanceCacheTTL,rpcUrl:e.provider instanceof n.ethers.JsonRpcProvider?e.provider.connection?.url:void 0}),(0,a.log)("Wallet plugin initialized")}destroy(){this.walletManager=null,super.destroy(),(0,a.log)("Wallet plugin destroyed")}assertWalletManager(){if(this.assertInitialized(),!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager}getMainWallet(){return this.assertWalletManager().getMainWallet()}getMainWalletCredentials(){return this.assertWalletManager().getMainWalletCredentials()}async createWallet(){return this.assertWalletManager().createWallet()}async loadWallets(){try{const e=this.assertWalletManager();return this.core?.isLoggedIn()?await e.loadWallets():((0,a.log)("Cannot load wallets: user not authenticated"),o.ErrorHandler.handle(o.ErrorType.AUTHENTICATION,"AUTH_REQUIRED","User authentication required to load wallets",null),[])}catch(e){return o.ErrorHandler.handle(o.ErrorType.WALLET,"LOAD_WALLETS_ERROR",`Error loading wallets: ${e instanceof Error?e.message:String(e)}`,e),[]}}getStandardBIP44Addresses(e,t=5){return this.assertWalletManager().getStandardBIP44Addresses(e,t)}generateNewMnemonic(){try{const e=n.ethers.Wallet.createRandom().mnemonic;if(!e||!e.phrase)throw new Error("Failed to generate mnemonic phrase");return e.phrase}catch(e){throw(0,a.logError)("Error generating mnemonic:",e),new Error("Failed to generate mnemonic phrase")}}async signMessage(e,t){return this.assertWalletManager().signMessage(e,t)}verifySignature(e,t){return this.assertWalletManager().verifySignature(e,t)}async signTransaction(e,t,r){return this.assertWalletManager().signTransaction(e,t,r)}async exportMnemonic(e){return this.assertWalletManager().exportMnemonic(e)}async exportWalletKeys(e){return this.assertWalletManager().exportWalletKeys(e)}async exportGunPair(e){return this.assertWalletManager().exportGunPair(e)}async exportAllUserData(e){return this.assertWalletManager().exportAllUserData(e)}async importMnemonic(e,t){return this.assertWalletManager().importMnemonic(e,t)}async importWalletKeys(e,t){return this.assertWalletManager().importWalletKeys(e,t)}async importGunPair(e,t){return this.assertWalletManager().importGunPair(e,t)}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){return this.assertWalletManager().importAllUserData(e,t,r)}setRpcUrl(e){try{return e?(this.assertWalletManager().setRpcUrl(e),this.core&&(this.core.provider=new n.ethers.JsonRpcProvider(e)),(0,a.log)(`RPC URL updated to: ${e}`),!0):((0,a.log)("Invalid RPC URL provided"),!1)}catch(e){return(0,a.logError)("Failed to set RPC URL",e),!1}}getRpcUrl(){return this.core&&this.core.provider instanceof n.ethers.JsonRpcProvider&&this.core.provider.connection?.url||null}}t.WalletPlugin=l},23358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=t.ErrorType=void 0,t.createError=s,t.handleError=function(e,t={}){const{message:r=(e instanceof Error?e.message:String(e)),throwError:n=!1,logError:i=!0,callback:s}=t;if("function"==typeof s)return s(e);if(n)throw e instanceof Error?e:new Error(r);return{success:!1,message:r,error:e}};const n=r(45628);var i;function s(e,t,r,n){return{type:e,code:t,message:r,originalError:n,timestamp:Date.now()}}!function(e){e.AUTHENTICATION="AuthenticationError",e.AUTHORIZATION="AuthorizationError",e.VALIDATION="ValidationError",e.NETWORK="NetworkError",e.DATABASE="DatabaseError",e.WALLET="WalletError",e.DID="DIDError",e.STORAGE="StorageError",e.ENCRYPTION="EncryptionError",e.SIGNATURE="SignatureError",e.ENVIRONMENT="EnvironmentError",e.SECURITY="SecurityError",e.GUN="GunError",e.STEALTH="StealthError",e.WEBAUTHN="WebAuthnError",e.PLUGIN="PluginError",e.UNKNOWN="UnknownError",e.CONNECTOR="CONNECTOR",e.GENERAL="GENERAL"}(i||(t.ErrorType=i={}));t.ErrorHandler=class{static errors=[];static maxErrors=100;static listeners=[];static handleError(e){(0,n.logError)(`[${e.type}] ${e.code}: ${e.message}`),this.errors.push(e),this.errors.length>this.maxErrors&&(this.errors=this.errors.slice(-this.maxErrors)),this.notifyListeners(e)}static handle(e,t,r,i,a="error"){const o=i?`${r} - ${this.formatError(i)}`:r;switch(a){case"debug":(0,n.log)(`[${e}.${t}] (DEBUG) ${o}`);break;case"warn":(0,n.log)(`[${e}.${t}] (WARN) ${o}`);break;case"info":(0,n.log)(`[${e}.${t}] (INFO) ${o}`);break;default:(0,n.log)(`[${e}.${t}] (ERROR) ${o}`),i&&i instanceof Error&&(0,n.log)(i.stack||"No stack trace available")}const l=s(e,t,o,i);return this.handleError(l),l}static getRecentErrors(e=10){return this.errors.slice(-Math.min(e,this.errors.length))}static addListener(e){this.listeners.push(e)}static removeListener(e){const t=this.listeners.indexOf(e);-1!==t&&this.listeners.splice(t,1)}static notifyListeners(e){for(const t of this.listeners)try{t(e)}catch(e){(0,n.logError)(`Error in error listener: ${e}`)}}static formatError(e){if(!e)return"Unknown error";if(e instanceof Error)return`${e.name}: ${e.message}`;if("string"==typeof e)return e;if("object"==typeof e)try{return JSON.stringify(e)}catch(t){return`Object: ${Object.prototype.toString.call(e)}`}return String(e)}static async withRetry(e,t,r,i=3,s=1e3){let a;for(let t=1;t<=i;t++)try{return await e()}catch(e){a=e;const r=s*t;t<i&&((0,n.log)(`Retrying operation after ${r}ms (attempt ${t}/${i})`),await new Promise((e=>setTimeout(e,r))))}throw this.handle(t,r,`Operation failed after ${i} attempts`,a)}}},28156:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunEventEmitter=t.ShogunStorage=t.Webauthn=t.Stealth=t.MetaMask=t.GunDB=t.ShogunCore=t.GunRxJS=t.ErrorType=t.ErrorHandler=t.ShogunDID=void 0;const s=r(78431),a=r(14134),o=r(4643),l=r(50074),c=r(45628),u=r(14193),g=r(23358),h=r(63475),d=r(20409),p=r(18991),m=r(42256),f=r(18635),w=r(23011),y=r(5307);var E=r(44662);Object.defineProperty(t,"ShogunDID",{enumerable:!0,get:function(){return E.ShogunDID}});var v=r(23358);Object.defineProperty(t,"ErrorHandler",{enumerable:!0,get:function(){return v.ErrorHandler}}),Object.defineProperty(t,"ErrorType",{enumerable:!0,get:function(){return v.ErrorType}});var b=r(63475);Object.defineProperty(t,"GunRxJS",{enumerable:!0,get:function(){return b.GunRxJS}}),i(r(5307),t);t.ShogunCore=class{static API_VERSION="2.0.0";gun;user;gundb;storage;eventEmitter;provider;config;rx;plugins=new Map;constructor(e){if((0,c.log)("Initializing ShogunSDK"),this.config=e,e.logging&&((0,c.configureLogging)(e.logging),(0,c.log)("Logging configured with custom settings")),this.storage=new o.ShogunStorage,this.eventEmitter=new a.EventEmitter,g.ErrorHandler.addListener((e=>{this.eventEmitter.emit("error",{action:e.code,message:e.message,type:e.type})})),e.gundb||(e.gundb={},(0,c.log)("No GunDB configuration provided, using defaults")),e.gundb.authToken){const t=e.gundb.authToken;(0,c.log)(`Auth token from config: ${t}`)}else(0,c.log)("No auth token in config");const t={peers:e.gundb?.peers,websocket:e.gundb?.websocket??!1,localStorage:e.gundb?.localStorage??!1,radisk:e.gundb?.radisk??!1,authToken:e.gundb?.authToken,multicast:e.gundb?.multicast??!1,axe:e.gundb?.axe??!1};if(this.gundb=new s.GunDB(t),this.gun=this.gundb.getGun(),this.user=this.gun.user().recall({sessionStorage:!0}),this.rx=new h.GunRxJS(this.gun),e.providerUrl?(this.provider=new u.ethers.JsonRpcProvider(e.providerUrl),(0,c.log)(`Using configured provider URL: ${e.providerUrl}`)):(this.provider=u.ethers.getDefaultProvider("mainnet"),(0,c.log)("WARNING: Using default Ethereum provider. For production use, configure a specific provider URL.")),this.registerBuiltinPlugins(e),e.plugins?.autoRegister&&e.plugins.autoRegister.length>0)for(const t of e.plugins.autoRegister)try{this.register(t),(0,c.log)(`Auto-registered plugin: ${t.name}`)}catch(e){(0,c.logError)(`Failed to auto-register plugin ${t.name}:`,e)}(0,c.log)("ShogunSDK initialized!")}registerBuiltinPlugins(e){try{if(e.webauthn?.enabled){const e=new d.WebauthnPlugin;e._category=l.PluginCategory.Authentication,this.register(e),(0,c.log)("Webauthn plugin registered")}if(e.metamask?.enabled){const e=new p.MetaMaskPlugin;e._category=l.PluginCategory.Authentication,this.register(e),(0,c.log)("MetaMask plugin registered")}if(e.stealth?.enabled){const e=new m.StealthPlugin;e._category=l.PluginCategory.Privacy,this.register(e),(0,c.log)("Stealth plugin registered")}if(e.did?.enabled){const e=new f.DIDPlugin;e._category=l.PluginCategory.Identity,this.register(e),(0,c.log)("DID plugin registered")}if(e.walletManager?.enabled){const e=new w.WalletPlugin;e._category=l.PluginCategory.Wallet,this.register(e),(0,c.log)("Wallet plugin registered")}if(e.social?.enabled){const e=new y.SocialPlugin;e._category=l.PluginCategory.Social,this.register(e),(0,c.log)("Social plugin registered")}}catch(e){(0,c.logError)("Error registering builtin plugins:",e)}}register(e){if(this.plugins.has(e.name))throw new Error(`Plugin with name "${e.name}" already registered`);e.initialize(this),this.plugins.set(e.name,e),(0,c.log)(`Registered plugin: ${e.name}`)}unregister(e){const t=this.plugins.get(e);t?(t.destroy&&t.destroy(),this.plugins.delete(e),(0,c.log)(`Unregistered plugin: ${e}`)):(0,c.log)(`Plugin "${e}" not found, nothing to unregister`)}getPlugin(e){return this.plugins.get(e)}hasPlugin(e){return this.plugins.has(e)}getPluginsByCategory(e){const t=[];return this.plugins.forEach((r=>{r._category===e&&t.push(r)})),t}getAuthenticationMethod(e){switch(e){case"webauthn":return this.getPlugin(l.CorePlugins.WebAuthn);case"metamask":return this.getPlugin(l.CorePlugins.MetaMask);default:return{login:(e,t)=>{this.login(e,t)},signUp:(e,t,r)=>{this.signUp(e,t,r)}}}}observe(e){return this.rx.observe(e)}match(e,t){return this.rx.match(e,t)}rxPut(e,t){return this.rx.put(e,t)}rxSet(e,t){return this.rx.set(e,t)}onceObservable(e){return this.rx.once(e)}compute(e,t){return this.rx.compute(e,t)}rxUserPut(e,t){return this.rx.userPut(e,t)}observeUser(e){return this.rx.observeUser(e)}getRecentErrors(e=10){return g.ErrorHandler.getRecentErrors(e)}configureLogging(e){(0,c.configureLogging)(e),(0,c.log)("Logging reconfigured with new settings")}isLoggedIn(){const e=this.gundb.isLoggedIn(),t=this.gun.user();if(e)return!0;const r=t&&t._&&t._.sea,n=this.storage.getItem("pair");return!!r||!!n}logout(){try{if(!this.isLoggedIn())return void(0,c.log)("Logout ignored: user not authenticated");this.gundb.logout(),this.eventEmitter.emit("auth:logout",{}),(0,c.log)("Logout completed successfully")}catch(e){g.ErrorHandler.handle(g.ErrorType.AUTHENTICATION,"LOGOUT_FAILED",e instanceof Error?e.message:"Error during logout",e)}}async login(e,t){(0,c.log)("Login");try{if((0,c.log)(`Login attempt for user: ${e}`),!e||!t)return{success:!1,error:"Username and password are required"};const r=this.config?.timeouts?.login??15e3,n=new Promise((async n=>{const i=setTimeout((()=>{n({success:!1,error:"Login timeout"})}),r);try{const r=await this.gundb.login(e,t);clearTimeout(i),r.success?n({success:!0,userPub:r.userPub||"",username:r.username||e}):n({success:!1,error:r.error||"Login failed"})}catch(e){clearTimeout(i),n({success:!1,error:e.message||"Login error"})}})),i=await n;if(i.success){this.eventEmitter.emit("auth:login",{userPub:i.userPub??""});try{const e=await this.ensureUserHasDID();e&&(i.did=e)}catch(e){(0,c.logError)("Error ensuring DID after login:",e)}}return i}catch(e){return g.ErrorHandler.handle(g.ErrorType.AUTHENTICATION,"LOGIN_FAILED",e.message??"Unknown error during login",e),{success:!1,error:e.message??"Unknown error during login"}}}async signUp(e,t,r){(0,c.log)("Sign up");try{if(!e||!t)return{success:!1,error:"Username and password are required"};if(void 0!==r&&t!==r)return{success:!1,error:"Passwords do not match"};if(t.length<6)return{success:!1,error:"Password must be at least 6 characters long"};this.eventEmitter.emit("debug",{action:"signup_start",username:e,timestamp:Date.now()}),(0,c.log)(`Inizializzazione registrazione per utente: ${e}`);const n=new Promise((r=>{this.gundb.signUp(e,t).then((t=>{(0,c.log)("GunDB registration result: "+(t.success?"success":"failed")),this.eventEmitter.emit("debug",{action:"gundb_signup_complete",success:t.success,error:t.error,timestamp:Date.now()}),t.success?r({success:!0,userPub:t.userPub||"",username:e||""}):r({success:!1,error:t.error||"Registration failed in GunDB"})}))})),i=this.config?.timeouts?.signup??3e4,s=new Promise((t=>{setTimeout((()=>{(0,c.logError)(`Timeout a livello ShogunCore durante la registrazione utente: ${e}`),this.eventEmitter.emit("debug",{action:"signup_timeout",username:e,timestamp:Date.now()}),t({success:!1,error:"Registration timeout at ShogunCore level"})}),i)})),a=await Promise.race([n,s]);return a.success?((0,c.log)(`Registrazione completata con successo per: ${e}`),this.eventEmitter.emit("auth:signup",{userPub:a.userPub??"",username:e}),this.eventEmitter.emit("debug",{action:"signup_complete",username:e,userPub:a.userPub,timestamp:Date.now()}),a):(this.eventEmitter.emit("debug",{action:"signup_failed",username:e,error:a.error,timestamp:Date.now()}),a)}catch(t){return(0,c.logError)(`Error during registration for user ${e}:`,t),this.eventEmitter.emit("debug",{action:"signup_exception",username:e,error:t.message||"Unknown error",timestamp:Date.now()}),{success:!1,error:t.message??"Unknown error during registration"}}}ensureUserHasDIDAsync(e){e.success&&setTimeout((async()=>{try{const t=await this.ensureUserHasDID();t&&((0,c.log)(`Created DID for new user: ${t}`),e.did=t)}catch(e){(0,c.logError)("Error creating DID for new user (async):",e)}}),100)}async ensureUserHasDID(e){try{const t=this.getPlugin("did");return t?await t.ensureUserHasDID(e):((0,c.log)("DID plugin not available, cannot ensure DID"),null)}catch(e){return(0,c.logError)("Error ensuring user has DID:",e),null}}createUserWithGunDB(e,t){return(0,c.log)(`Ensuring user exists with GunDB: ${e}`),new Promise((async r=>{try{const n=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gun.user().auth(e,t,(e=>{if(e.err)r({err:e.err});else{const e=this.gundb.gun.user(),t=e.is?.pub||"";e.is&&t?r({pub:t}):r({err:"Authentication failed after apparent success."})}}))})),i=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().create(e,t,(e=>{r({err:e.err,pub:e.pub})}))}));(0,c.log)(`Attempting login first for ${e}...`);let s=await n();if(s.pub)return(0,c.log)(`Login successful for existing user. Pub: ${s.pub}`),void r({success:!0,userPub:s.pub});(0,c.log)(`Login failed (${s.err??"unknown reason"}), attempting user creation...`);const a=await i();if(a.err)return(0,c.log)(`User creation error: ${a.err}`),void r({success:!1,error:`User creation failed: ${a.err}`});(0,c.log)("User created successfully, attempting login again for confirmation..."),s=await n(),s.pub?((0,c.log)(`Post-creation login successful! User pub: ${s.pub}`),r({success:!0,userPub:s.pub})):((0,c.logError)(`Post-creation login failed unexpectedly: ${s.err}`),r({success:!1,error:`User created, but subsequent login failed: ${s.err}`}))}catch(e){const t=e.message??"Unknown error during user existence check";(0,c.logError)(`Error in createUserWithGunDB: ${t}`,e),r({success:!1,error:t})}}))}get(e){return new Promise(((t,r)=>{this.gundb.gun.get(e).once((e=>{e.err?r(e.err):t(e)}))}))}put(e){return new Promise(((t,r)=>{this.gundb.gun.put(e,(e=>{e.err?r(e.err):t(e)}))}))}userPut(e){return new Promise(((t,r)=>{this.gundb.gun.user().put(e,(e=>{e.err?r(e.err):t(e)}))}))}userGet(e){return new Promise(((t,r)=>{this.gundb.gun.user().get(e).once((e=>{e.err?r(e.err):t(e)}))}))}setRpcUrl(e){try{return e?(this.provider=new u.ethers.JsonRpcProvider(e),(0,c.log)(`RPC URL updated to: ${e}`),!0):((0,c.log)("Invalid RPC URL provided"),!1)}catch(e){return(0,c.logError)("Failed to set RPC URL",e),!1}}getRpcUrl(){return this.provider instanceof u.ethers.JsonRpcProvider?this.provider.connection?.url??null:null}emit(e,t){return this.eventEmitter.emit(e,t)}on(e,t){return this.eventEmitter.on(e,t),this}once(e,t){return this.eventEmitter.once(e,t),this}off(e,t){return this.eventEmitter.off(e,t),this}removeAllListeners(e){return this.eventEmitter.removeAllListeners(e),this}},i(r(50074),t);var D=r(78431);Object.defineProperty(t,"GunDB",{enumerable:!0,get:function(){return D.GunDB}});var P=r(67160);Object.defineProperty(t,"MetaMask",{enumerable:!0,get:function(){return P.MetaMask}});var S=r(42256);Object.defineProperty(t,"Stealth",{enumerable:!0,get:function(){return S.Stealth}});var I=r(20409);Object.defineProperty(t,"Webauthn",{enumerable:!0,get:function(){return I.Webauthn}});var A=r(4643);Object.defineProperty(t,"ShogunStorage",{enumerable:!0,get:function(){return A.ShogunStorage}});var T=r(21795);Object.defineProperty(t,"ShogunEventEmitter",{enumerable:!0,get:function(){return T.ShogunEventEmitter}})},29148:function(e,t,r){"use strict";var n,i=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),a=0;a<r.length;a++)"default"!==r[a]&&i(t,e,r[a]);return s(t,e),t}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||i(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunCore=t.modules=void 0,t.initShogunBrowser=h;const l=r(28156);Object.defineProperty(t,"ShogunCore",{enumerable:!0,get:function(){return l.ShogunCore}});const c=r(50074),u=r(45628);let g;function h(e){const t={...e};return t.gundb??={},e.gundb?.peers||(0,u.log)("WARNING: Using default GunDB peers. For production, always configure custom peers."),e.providerUrl||(0,u.log)("WARNING: No Ethereum provider URL specified. Using default public endpoint with rate limits."),g=new l.ShogunCore(t),g.hasPlugin(c.CorePlugins.WebAuthn)&&(0,u.log)("WebAuthn plugin initialized",{category:"init",level:"info"}),g.hasPlugin(c.CorePlugins.MetaMask)&&(0,u.log)("MetaMask plugin initialized",{category:"init",level:"info"}),g.hasPlugin(c.CorePlugins.WalletManager)&&(0,u.log)("Wallet plugin initialized",{category:"init",level:"info"}),g.hasPlugin(c.CorePlugins.Social)&&(0,u.log)("Social plugin initialized",{category:"init",level:"debug"}),g}t.modules={loadWebAuthn:()=>Promise.resolve().then((()=>a(r(20409)))),loadStealth:()=>Promise.resolve().then((()=>a(r(42256)))),loadDID:()=>Promise.resolve().then((()=>a(r(44662)))),loadWallet:()=>Promise.resolve().then((()=>a(r(23011)))),loadMetaMask:()=>Promise.resolve().then((()=>a(r(18991))))},o(r(50074),t),"undefined"!=typeof window&&(window.ShogunCore=g,window.initShogunBrowser=h,window.ShogunModules=t.modules)},29854:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunConsensus=void 0;const n=r(7668);t.GunConsensus=class{gun;config;constructor(e,t={}){this.gun=e,this.config={threshold:t.threshold??.51,timeWindow:t.timeWindow??6e4,minVotes:t.minVotes??3}}async proposeChange(e,t,r={}){if(!this.gun.isLoggedIn())throw new Error("You must be authenticated to propose changes");const i=this.gun.getCurrentUser()?.pub;if(!i)throw new Error("Public key not available");const s=this.generateId(),a=Date.now(),o={id:s,topic:e,data:t,metadata:r,proposer:i,timestamp:a,expiresAt:a+this.config.timeWindow,status:"pending"},l=this.gun.getCurrentUser()?.user._.sea;if(!l)throw new Error("Key pair not available");const c=await(0,n.sign)(o,l);return new Promise(((e,t)=>{this.gun.get("consensus").get("proposals").get(s).put(c,(r=>{r.err?t(new Error(r.err)):e(s)}))}))}async vote(e,t,r=""){if(!this.gun.isLoggedIn())throw new Error("You must be authenticated to vote");const i=this.gun.getCurrentUser()?.pub;if(!i)throw new Error("Public key not available");const s=await this.getProposal(e);if(!s)throw new Error("Proposal not found");if(s.expiresAt<Date.now())throw new Error("Proposal expired");if(await this.getUserVote(e,i))throw new Error("You have already voted on this proposal");const a={voter:i,approve:t,comment:r,timestamp:Date.now()},o=this.gun.getCurrentUser()?.user._.sea;if(!o)throw new Error("Key pair not available");const l=await(0,n.sign)(a,o);return new Promise(((t,r)=>{this.gun.get("consensus").get("proposals").get(e).get("votes").get(i).put(l,(n=>{n.err?r(new Error(n.err)):this.updateProposalStatus(e).then((()=>t(!0))).catch(r)}))}))}async getProposal(e){return new Promise((t=>{this.gun.get("consensus").get("proposals").get(e).once((e=>{if(e)try{const r=("string"==typeof e?JSON.parse(e):e).proposer;if(!r)return void t(null);(0,n.verify)(e,r).then((e=>{t(e||null)})).catch((e=>{t(null)}))}catch(e){t(null)}else t(null)}))}))}async getUserVote(e,t){return new Promise((r=>{this.gun.get("consensus").get("proposals").get(e).get("votes").get(t).once((e=>{r(e||null)}))}))}async updateProposalStatus(e){const t=await this.countVotes(e);if(t.totalVotes>=this.config.minVotes){const r=t.approvalCount/t.totalVotes;r>=this.config.threshold?await this.finalizeProposal(e,"approved"):r+(1-t.totalVotes)<this.config.threshold&&await this.finalizeProposal(e,"rejected")}}async countVotes(e){return new Promise((t=>{let r=0,i=0,s=0;this.gun.get("consensus").get("proposals").get(e).get("votes").map().once((async(e,t)=>{if(e&&"_"!==t)try{const t=("string"==typeof e?JSON.parse(e):e).voter;if(!t)return;const a=await(0,n.verify)(e,t);a&&(s++,a.approve?r++:i++)}catch(e){}})),setTimeout((()=>{t({approved:r>=this.config.threshold*s,approvalCount:r,rejectionCount:i,totalVotes:s})}),100)}))}async finalizeProposal(e,t){return new Promise(((r,n)=>{this.gun.get("consensus").get("proposals").get(e).get("status").put(t,(e=>{e.err?n(new Error(e.err)):r()}))}))}generateId(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}}},30348:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthAddresses=t.Stealth=void 0;const i=r(14193),s=r(4643),a=r(23358),o=r(45628),l=n(r(59229));class c{STEALTH_DATA_TABLE;lastEphemeralKeyPair=null;lastMethodUsed="unknown";storage;STEALTH_HISTORY_KEY="stealthHistory";logs=[];constructor(e){this.STEALTH_DATA_TABLE="Stealth",this.storage=e||new s.ShogunStorage}log(e,t,r){const n={timestamp:(new Date).toISOString(),level:e,message:t,data:r};this.logs.push(n)}async cleanupSensitiveData(){try{this.lastEphemeralKeyPair=null,this.lastMethodUsed="unknown",this.logs=[],this.log("info","Sensitive data cleanup completed")}catch(e){throw this.log("error","Error during cleanup",e),e}}validateStealthData(e){try{if(!e||"object"!=typeof e)return this.log("error","Invalid stealth data: data is not an object"),!1;const t=["recipientPublicKey","ephemeralKeyPair","timestamp"];for(const r of t)if(!(r in e))return this.log("error",`Invalid stealth data: missing ${r}`),!1;if("string"!=typeof e.recipientPublicKey||!e.recipientPublicKey.trim())return this.log("error","Invalid recipientPublicKey"),!1;if("number"!=typeof e.timestamp||e.timestamp<=0)return this.log("error","Invalid timestamp"),!1;const r=["pub","priv","epub","epriv"];for(const t of r)if(!(t in e.ephemeralKeyPair)||"string"!=typeof e.ephemeralKeyPair[t])return this.log("error",`Invalid ephemeralKeyPair: missing or invalid ${t}`),!1;return e.method&&!["standard","legacy"].includes(e.method)?(this.log("error","Invalid method value"),!1):e.sharedSecret&&"string"!=typeof e.sharedSecret?(this.log("error","Invalid sharedSecret type"),!1):(this.log("debug","Stealth data validation passed"),!0)}catch(e){return this.log("error","Error during stealth data validation",e),!1}}formatPublicKey(e){if(!e)return null;const t=e.trim();return t&&/^[~]?[\w+/=\-_.]+$/.test(t)?t.startsWith("~")?t.slice(1):t:null}async createAccount(){try{const e=await l.default.SEA.pair();if(!(e&&e.pub&&e.priv&&e.epub&&e.epriv))throw new Error("Failed to generate stealth key pair");return{pub:e.pub,priv:e.priv,epub:e.epub,epriv:e.epriv}}catch(e){throw this.log("error","Error creating stealth account:",e),e}}async generateEphemeralKeyPair(){try{const e=await l.default.SEA.pair();if(!e||!e.epriv||!e.epub)throw new Error("Failed to generate ephemeral key pair");return{privateKey:e.epriv,publicKey:e.epub}}catch(e){throw this.log("error","Error generating ephemeral key pair",e),e}}async generateStealthAddress(e,t){if(!e){const e=new Error("Invalid keys: missing or invalid parameters");throw a.ErrorHandler.handle(a.ErrorType.STEALTH,"INVALID_KEYS","Invalid or missing recipient public key",e),e}return new Promise(((r,n)=>{let s;const c=()=>{(0,o.logDebug)("Ephemeral keys generated:",s),this.lastEphemeralKeyPair=s;const t={recipientPublicKey:e,ephemeralKeyPair:s,timestamp:Date.now()},c={epub:s.epub,epriv:s.epriv};(0,o.logDebug)("Key format for secret (generation):",JSON.stringify(c)),l.default.SEA.secret(e,c,(async l=>{(0,o.logDebug)("Shared secret successfully generated with recipient keys"),(0,o.logDebug)("Input format used:",{recipientPublicKey:e,ephemeralKeyObject:c});try{const n=i.ethers.keccak256(i.ethers.toUtf8Bytes(l)),a=new i.ethers.Wallet(n);(0,o.logDebug)("Stealth address generated:",{address:a.address,ephemeralPubKey:s.epub,recipientPublicKey:e}),this.lastMethodUsed="standard",t.method="standard",this.saveStealthHistory(a.address,t);const c=s.epub||s.pub;if(!c)throw new Error("Failed to generate ephemeral public key");r({stealthAddress:a.address,ephemeralPublicKey:c,recipientPublicKey:e})}catch(e){const t=new Error(`Error creating stealth address: ${e instanceof Error?e.message:"unknown error"}`);a.ErrorHandler.handle(a.ErrorType.STEALTH,"ADDRESS_GENERATION_FAILED",`Error creating stealth address: ${e instanceof Error?e.message:"unknown error"}`,e),n(t)}}))};t?this.generateEphemeralKeyPair().then((e=>{try{s={epriv:t,epub:e.publicKey,priv:t,pub:e.publicKey},c()}catch(e){return a.ErrorHandler.handle(a.ErrorType.STEALTH,"EPHEMERAL_KEY_GENERATION_FAILED","Failed to use provided ephemeral key",e),void n(e)}})):this.generateEphemeralKeyPair().then((e=>{try{const t={epriv:e.privateKey,epub:e.publicKey,priv:e.privateKey,pub:e.publicKey};s=t,c()}catch(e){return a.ErrorHandler.handle(a.ErrorType.STEALTH,"EPHEMERAL_KEY_GENERATION_FAILED","Failed to generate valid ephemeral keys",e),void n(e)}}))}))}async openStealthAddress(e,t,r){(0,o.logDebug)(`Attempting to open stealth address ${e}`);try{const t=this.storage.getItem(this.STEALTH_HISTORY_KEY)||"{}",r=JSON.parse(t);(0,o.logDebug)(`Checking if data exists for address ${e} in storage`);const n=r[e];if(n){if((0,o.logDebug)("Found locally saved stealth data:",n),n.sharedSecret){(0,o.logDebug)("Direct derivation from saved shared secret");const e=i.ethers.keccak256(i.ethers.toUtf8Bytes(n.sharedSecret));return new i.ethers.Wallet(e)}if(n.method&&n.ephemeralKeyPair){if((0,o.logDebug)("Attempting to regenerate secret with method:",n.method),"standard"===n.method){const t={epub:n.ephemeralKeyPair.epub,epriv:n.ephemeralKeyPair.epriv};return(0,o.logDebug)("Regenerating with explicit format:",JSON.stringify(t)),new Promise(((r,s)=>{l.default.SEA.secret(n.recipientPublicKey,t,(async t=>{if(t)try{const n=i.ethers.keccak256(i.ethers.toUtf8Bytes(t)),s=new i.ethers.Wallet(n);if(s.address.toLowerCase()===e.toLowerCase())return(0,o.logDebug)("Regeneration successful! Matching address:",s.address),r(s);throw(0,o.logDebug)("Generated address does not match:",s.address),new Error("Address does not match")}catch(e){throw(0,o.logError)("Error during derivation:",e),new Error("Derivation error")}else s(new Error("Unable to regenerate shared secret"))}))}))}throw new Error("Method not supported")}throw new Error("Insufficient data")}throw(0,o.logDebug)("No stealth data found in storage for this address"),new Error("No data found")}catch(n){return(0,o.logError)("Error retrieving data from storage:",n),this.openStealthAddressStandard(e,t,r)}}async openStealthAddressStandard(e,t,r){if(!e||!t)throw new Error("Missing parameters: stealthAddress or ephemeralPublicKey");return(0,o.logDebug)("Opening stealth address with retrieved keys:",{stealthAddress:e,ephemeralPublicKey:t,userKeysFound:!!r}),new Promise(((n,s)=>{const a=[()=>((0,o.logDebug)("Attempt 1: Standard method with ephemeral keys"),new Promise((n=>{l.default.SEA.secret(t,r,(async t=>{try{if(!t)return n(null);const r=this.deriveWalletFromSecret(t);return r.address.toLowerCase()===e.toLowerCase()?n(r):n(null)}catch(e){return n(null)}}))})))];this.deriveWalletFromSecret=e=>{const t=i.ethers.keccak256(i.ethers.toUtf8Bytes(e));return new i.ethers.Wallet(t)};const c=async(e=0)=>{if(e>=a.length)return s(new Error("All stealth address derivation methods failed"));const t=await a[e]();if(t)return(0,o.logDebug)(`Method ${e+1} worked!`),n(t);c(e+1)};c()}))}async getPublicKey(e){return this.formatPublicKey(e)}prepareStealthKeysForSaving(e){if(!(e?.pub&&e?.priv&&e?.epub&&e?.epriv))throw new Error("Invalid stealth keys: missing or incomplete parameters");return e}deriveWalletFromSecret(e){const t=i.ethers.keccak256(i.ethers.toUtf8Bytes(e));return new i.ethers.Wallet(t)}saveStealthHistory(e,t){try{if(!this.validateStealthData(t))throw new Error("Invalid stealth data");const r={...t,sharedSecret:void 0};r.ephemeralKeyPair&&(r.ephemeralKeyPair={pub:r.ephemeralKeyPair.pub,epub:r.ephemeralKeyPair.epub,priv:"",epriv:""});const n=this.storage.getItem(this.STEALTH_HISTORY_KEY)??"{}",i=JSON.parse(n);i[e]=r,this.storage.setItem(this.STEALTH_HISTORY_KEY,JSON.stringify(i)),this.log("info",`Stealth data saved for address ${e}`)}catch(e){throw this.log("error","Error saving stealth data:",e),e}}async scanStealthAddresses(e,t){try{const r=[];for(const n of e)try{await this.isStealthAddressMine(n,t)&&r.push(n)}catch(e){this.log("error",`Error checking stealth address: ${e instanceof Error?e.message:"unknown error"}`)}return r}catch(e){throw this.log("error","Error scanning stealth addresses",e),e}}async isStealthAddressMine(e,t){try{if(!e||!t)throw new Error("Invalid parameters for stealth address check");if(!this.validateStealthData(e))throw new Error("Invalid stealth data format");const r=await this.getStealthPrivateKey(e,t);if(!r)return!1;try{const e=new i.ethers.Wallet(r);return(0,o.logDebug)("Wallet derived:",e.address),!0}catch(e){return!1}}catch(e){throw this.log("error","Error checking stealth address ownership",e),e}}async getStealthPrivateKey(e,t){try{if(!e||!t)throw new Error("Invalid parameters for private key derivation");if(!this.validateStealthData(e))throw new Error("Invalid stealth data format");return e.sharedSecret?i.ethers.keccak256(i.ethers.toUtf8Bytes(e.sharedSecret)):new Promise(((r,n)=>{const s={priv:t,epub:e.ephemeralKeyPair.epub};l.default.SEA.secret(e.ephemeralKeyPair.epub,s,(e=>{if(e)try{const t=i.ethers.keccak256(i.ethers.toUtf8Bytes(e));r(t)}catch(e){n(new Error(`Error deriving private key: ${e instanceof Error?e.message:"unknown error"}`))}else n(new Error("Failed to generate shared secret"))}))}))}catch(e){throw this.log("error","Error getting stealth private key",e),e}}generateStealthKeys(){return{scanning:{privateKey:"0x"+"1".repeat(64),publicKey:"0x"+"2".repeat(64)},spending:{privateKey:"0x"+"3".repeat(64),publicKey:"0x"+"4".repeat(64)}}}verifyStealthAddress(e,t,r,n){return!0}scanningKeyToPrivateKey(e,t,r){return"derived-private-key"}generateStealthMetadata(e,t){return e&&t?{ephemeralPublicKey:e,stealthAddress:t}:{ephemeralPublicKey:e||"0x"+"8".repeat(64),stealthAddress:t||"0x"+"9".repeat(40)}}}t.Stealth=c,t.StealthAddresses=c,"undefined"!=typeof window?window.Stealth=c:void 0!==r.g&&(r.g.Stealth=c),t.default=c},37510:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Webauthn=void 0;const n=r(14193),i=r(23358),s=r(14134),a=r(45628),o=r(77458),l={rpName:"Shogun Wallet",timeout:6e4,userVerification:"preferred",attestation:"none",authenticatorAttachment:"platform",requireResidentKey:!1};class c extends s.EventEmitter{config;gunInstance;credential;abortController=null;constructor(e,t){super(),this.gunInstance=e,this.credential=null,this.config={...l,...t,rpId:t?.rpId??window.location.hostname.split(":")[0]}}validateUsername(e){if(!e||"string"!=typeof e)throw new Error("Username must be a non-empty string");if(e.length<3||e.length>64)throw new Error("Username must be between 3 and 64 characters");if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error("Username can only contain letters, numbers, underscores and hyphens")}async createAccount(e,t,r=!1){try{this.validateUsername(e);const n=3;let i=null;for(let s=1;s<=n;s++)try{const n=await this.generateCredentials(e,t,r);if(n.success)return this.emit(o.WebAuthnEventType.DEVICE_REGISTERED,{type:o.WebAuthnEventType.DEVICE_REGISTERED,data:{username:e,deviceInfo:n.deviceInfo},timestamp:Date.now()}),n;i=new Error(n.error??"Unknown error")}catch(e){if(i=e,s<n){await new Promise((e=>setTimeout(e,1e3*s)));continue}}throw i||new Error("Failed to create account after retries")}catch(e){throw this.emit(o.WebAuthnEventType.ERROR,{type:o.WebAuthnEventType.ERROR,data:{error:e.message},timestamp:Date.now()}),e}}async authenticateUser(e,t,r={}){try{if(this.validateUsername(e),!t){const e=new Error("No WebAuthn credentials found for this username");return i.ErrorHandler.handle(i.ErrorType.WEBAUTHN,"NO_CREDENTIALS",e.message,e),{success:!1,error:e.message}}this.abortAuthentication(),this.abortController=new AbortController;const n=r.timeout||this.config.timeout,s=setTimeout((()=>this.abortController?.abort()),n);try{const i={challenge:this.generateChallenge(e),allowCredentials:[],timeout:n,userVerification:r.userVerification||this.config.userVerification,rpId:this.config.rpId},s=await navigator.credentials.get({publicKey:i,signal:this.abortController.signal});if(!s)throw new Error("WebAuthn verification failed");const{password:a}=this.generateCredentialsFromSalt(e,t),l=this.getDeviceInfo(s.id),c={success:!0,username:e,password:a,credentialId:this.bufferToBase64(s.rawId),deviceInfo:l};return this.emit(o.WebAuthnEventType.AUTHENTICATION_SUCCESS,{type:o.WebAuthnEventType.AUTHENTICATION_SUCCESS,data:{username:e,deviceInfo:l},timestamp:Date.now()}),c}finally{clearTimeout(s),this.abortController=null}}catch(t){const r=t instanceof Error?t.message:"Unknown WebAuthn error";return this.emit(o.WebAuthnEventType.AUTHENTICATION_FAILED,{type:o.WebAuthnEventType.AUTHENTICATION_FAILED,data:{username:e,error:r},timestamp:Date.now()}),i.ErrorHandler.handle(i.ErrorType.WEBAUTHN,"AUTH_ERROR",r,t),{success:!1,error:r}}}abortAuthentication(){this.abortController&&(this.abortController.abort(),this.abortController=null)}getDeviceInfo(e){const t=this.getPlatformInfo();return{deviceId:e,timestamp:Date.now(),name:t.name,platform:t.platform,lastUsed:Date.now()}}getPlatformInfo(){if("undefined"==typeof navigator)return{name:"unknown",platform:"unknown"};const e=navigator.platform,t=navigator.userAgent;return/iPhone|iPad|iPod/.test(e)?{name:"iOS Device",platform:e}:/Android/.test(t)?{name:"Android Device",platform:e}:/Win/.test(e)?{name:"Windows Device",platform:e}:/Mac/.test(e)?{name:"Mac Device",platform:e}:/Linux/.test(e)?{name:"Linux Device",platform:e}:{name:"Unknown Device",platform:e}}generateChallenge(e){const t=Date.now().toString(),r=this.getRandomBytes(32),n=`${e}-${t}-${this.uint8ArrayToHex(r)}`;return(new TextEncoder).encode(n)}getRandomBytes(e){if("undefined"!=typeof window&&window.crypto)return window.crypto.getRandomValues(new Uint8Array(e));throw new Error("No cryptographic implementation available")}uint8ArrayToHex(e){return Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("")}bufferToBase64(e){const t=new Uint8Array(e).reduce(((e,t)=>e+String.fromCharCode(t)),"");return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}generateCredentialsFromSalt(e,t){const r=n.ethers.toUtf8Bytes(e+t);return{password:n.ethers.sha256(r)}}isSupported(){return"undefined"!=typeof window&&void 0!==window.PublicKeyCredential}async createCredential(e){try{const t=crypto.getRandomValues(new Uint8Array(32)),r=(new TextEncoder).encode(e),n={challenge:t,rp:{name:"Shogun Wallet",..."localhost"!==this.config.rpId&&{id:this.config.rpId}},user:{id:r,name:e,displayName:e},pubKeyCredParams:[{type:"public-key",alg:-7}],timeout:this.config.timeout,attestation:this.config.attestation,authenticatorSelection:{authenticatorAttachment:this.config.authenticatorAttachment,userVerification:this.config.userVerification,requireResidentKey:this.config.requireResidentKey}};(0,a.logDebug)("Attempting to create credentials with options:",n);const i=await navigator.credentials.create({publicKey:n});if(!i)throw new Error("Credential creation failed");(0,a.logDebug)("Credentials created successfully:",i);const s=i,o={id:s.id,rawId:s.rawId,type:s.type,response:{clientDataJSON:s.response.clientDataJSON},getClientExtensionResults:s.getClientExtensionResults};return"attestationObject"in s.response&&(o.response.attestationObject=s.response.attestationObject),this.credential=o,o}catch(e){(0,a.logError)("Detailed error in credential creation:",e);const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Error creating credentials: ${t}`)}}async generateCredentials(e,t,r=!1){try{if(r){const t=await this.verifyCredential(e);return{success:t.success,error:t.error,credentialId:t.credentialId,username:t.username}}{const t=await this.createCredential(e),r=t.id;let n=null;return t?.response?.getPublicKey&&(n=t.response.getPublicKey()),{success:!0,credentialId:r,publicKey:n}}}catch(e){(0,a.logError)("Error in generateCredentials:",e);return{success:!1,error:e instanceof Error?e.message:"Unknown error during WebAuthn operation"}}}async verifyCredential(e){try{const t={challenge:crypto.getRandomValues(new Uint8Array(32)),timeout:this.config.timeout,userVerification:this.config.userVerification,..."localhost"!==this.config.rpId&&{rpId:this.config.rpId}};this.credential?.rawId&&(t.allowCredentials=[{id:this.credential.rawId,type:"public-key"}]);const r=await navigator.credentials.get({publicKey:t});return r?{success:!0,credentialId:r.id,username:e}:{success:!1,error:"Credential verification failed"}}catch(e){(0,a.logError)("Error verifying credentials:",e);return{success:!1,error:e instanceof Error?e.message:"Unknown error verifying credentials"}}}async saveToGun(e,t){if(this.gunInstance)try{await this.gunInstance.get(`webauthn_${e}`).put({credentialId:t.id,type:t.type,timestamp:Date.now()})}catch(e){(0,a.logError)("Error saving credentials to Gun:",e)}}async removeDevice(e,t,r){if(!r||!r.credentials||!r.credentials[t])return{success:!1};const n={...r};return n.credentials&&delete n.credentials[t],{success:!0,updatedCredentials:n}}async sign(e){return await navigator.credentials.get({publicKey:{challenge:new Uint8Array(16),rpId:this.config.rpId}})}}t.Webauthn=c,"undefined"!=typeof window?window.Webauthn=c:void 0!==r.g&&(r.g.Webauthn=c)},38664:()=>{},42115:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=void 0;const n=r(12205),i=r(30348),s=r(45628);class a extends n.BasePlugin{name="stealth";version="1.0.0";description="Provides stealth address functionality for ShogunCore";stealth=null;initialize(e){if(super.initialize(e),!e.storage)throw new Error("Storage dependency not available in core");this.stealth=new i.Stealth(e.storage),(0,s.log)("Stealth plugin initialized")}destroy(){this.stealth=null,super.destroy(),(0,s.log)("Stealth plugin destroyed")}assertStealth(){if(this.assertInitialized(),!this.stealth)throw new Error("Stealth module not initialized");return this.stealth}async generateEphemeralKeyPair(){return this.assertStealth().generateEphemeralKeyPair()}async generateStealthAddress(e,t){return this.assertStealth().generateStealthAddress(e,t)}async scanStealthAddresses(e,t){return this.assertStealth().scanStealthAddresses(e,t)}async isStealthAddressMine(e,t){return this.assertStealth().isStealthAddressMine(e,t)}async getStealthPrivateKey(e,t){return this.assertStealth().getStealthPrivateKey(e,t)}async openStealthAddress(e,t,r){return this.assertStealth().openStealthAddress(e,t,r)}}t.StealthPlugin=a},42256:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Stealth:()=>n,default:()=>i});class n{constructor(){}formatPublicKey(){throw new Error("Stealth functionality disabled in light version")}async createAccount(){throw new Error("Stealth functionality disabled in light version")}async generateStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async openStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async getPublicKey(){throw new Error("Stealth functionality disabled in light version")}prepareStealthKeysForSaving(){throw new Error("Stealth functionality disabled in light version")}deriveWalletFromSecret(){throw new Error("Stealth functionality disabled in light version")}}const i=n},43408:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},44662:(e,t,r)=>{"use strict";r.r(t),r.d(t,{ShogunDID:()=>n,default:()=>i});class n{constructor(){}async createDID(){throw new Error("DID functionality disabled in light version")}async getCurrentUserDID(){throw new Error("DID functionality disabled in light version")}async resolveDID(){throw new Error("DID functionality disabled in light version")}async authenticateWithDID(){throw new Error("DID functionality disabled in light version")}async updateDIDDocument(){throw new Error("DID functionality disabled in light version")}async deactivateDID(){throw new Error("DID functionality disabled in light version")}isValidDID(){throw new Error("DID functionality disabled in light version")}}const i=n},45628:(e,t,r)=>{"use strict";var n=r(65606);Object.defineProperty(t,"__esModule",{value:!0}),t.enableDebug=function(){s=!0,a("Debug mode enabled")},t.disableDebug=function(){s=!1},t.configureLogging=function(e){i={...i,...e}},t.log=a,t.logError=o,t.logWarn=l,t.logDebug=c,t.logWithLevel=function(e,t,...r){switch(e){case"error":o(t,...r);break;case"warn":l(t,...r);break;case"debug":c(t,...r);break;default:a(t,...r)}};let i={enabled:"true"===n.env.DEBUG,level:"info",prefix:"[ShogunSDK]"},s=!1;function a(e,...t){(new Date).toISOString()}function o(e,...t){(new Date).toISOString()}function l(e,...t){(new Date).toISOString()}function c(e,...t){if(!s)return;(new Date).toISOString()}},45811:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=void 0;var s=r(42115);Object.defineProperty(t,"StealthPlugin",{enumerable:!0,get:function(){return s.StealthPlugin}}),i(r(30348),t)},47790:()=>{},48929:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.DIDPlugin=void 0;var s=r(18635);Object.defineProperty(t,"DIDPlugin",{enumerable:!0,get:function(){return s.DIDPlugin}}),i(r(68804),t)},50074:(e,t)=>{"use strict";var r,n;Object.defineProperty(t,"__esModule",{value:!0}),t.CorePlugins=t.PluginCategory=void 0,function(e){e.Authentication="authentication",e.Wallet="wallet",e.Privacy="privacy",e.Identity="identity",e.Utility="utility",e.Social="social"}(r||(t.PluginCategory=r={})),function(e){e.WebAuthn="webauthn",e.MetaMask="metamask",e.Stealth="stealth",e.DID="did",e.WalletManager="wallet",e.Social="social"}(n||(t.CorePlugins=n={}))},50563:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SocialPlugin=void 0;const n=r(12205),i=r(55660),s=r(45628),a=r(79364);class o extends n.BasePlugin{name="social";version="1.0.2";description="Social plugin using GunDB for storage and real-time updates";social=null;get user(){return this.social?.user||null}initialize(e){super.initialize(e),this.social=new i.Social(e.gun),(0,s.log)("Social plugin initialized")}destroy(){this.social&&"function"==typeof this.social.cleanup&&this.social.cleanup(),this.social=null,super.destroy(),(0,s.log)("Social plugin destroyed")}async getProfile(e){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.getProfile?this.social.getProfile(e):((0,s.logError)("getProfile method not available"),{pub:e,followers:[],following:[],customFields:{}})}async post(e){return this.social.post(e)}async postWithImage(e,t){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.post?this.social.post(e,t):((0,s.logError)("postWithImage method not available"),null)}async searchByHashtag(e){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.searchByHashtag?this.social.searchByHashtag(e):((0,s.logError)("searchByHashtag method not available"),[])}async likePost(e){return this.social.likePost(e)}async unlikePost(e){return this.social.unlikePost(e)}async getLikes(e){return this.social.getLikes(e)}async getLikeCount(e){return this.social.getLikeCount(e)}async addComment(e,t){return this.social.addComment(e,t)}async getComments(e){return this.social.getComments(e)}async deletePost(e){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.deletePost?this.social.deletePost(e):((0,s.logError)("deletePost method not available"),!1)}async getTimeline(){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.getTimeline?this.social.getTimeline():((0,s.logError)("getTimeline method not available"),{messages:[],error:"Method not implemented"})}async follow(e){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.follow?this.social.follow(e):((0,s.logError)("follow method not available"),!1)}async unfollow(e){if(!this.social)throw new Error("Social plugin not initialized");return"function"==typeof this.social.unfollow?this.social.unfollow(e):((0,s.logError)("unfollow method not available"),!1)}cleanup(){this.social&&"function"==typeof this.social.cleanup&&this.social.cleanup()}getTimelineObservable(e=10,t={includeLikes:!0}){return this.social?"function"==typeof this.social.getTimelineObservable?this.social.getTimelineObservable(e,t):((0,s.logError)("getTimelineObservable method not available"),(0,a.of)([])):((0,s.logError)("Social plugin not initialized"),(0,a.of)([]))}getCommentsObservable(e){return this.social?"function"==typeof this.social.getCommentsObservable?this.social.getCommentsObservable(e):((0,s.logError)("getCommentsObservable method not available"),(0,a.of)([])):((0,s.logError)("Social plugin not initialized"),(0,a.of)([]))}getLikesObservable(e){return this.social?"function"==typeof this.social.getLikesObservable?this.social.getLikesObservable(e):((0,s.logError)("getLikesObservable method not available"),(0,a.of)([])):((0,s.logError)("Social plugin not initialized"),(0,a.of)([]))}getLikeCountObservable(e){return this.social?"function"==typeof this.social.getLikeCountObservable?this.social.getLikeCountObservable(e):((0,s.logError)("getLikeCountObservable method not available"),(0,a.of)(0)):((0,s.logError)("Social plugin not initialized"),(0,a.of)(0))}getEnrichedPostObservable(e){return this.social?"function"==typeof this.social.getEnrichedPostObservable?this.social.getEnrichedPostObservable(e):((0,s.logError)("getEnrichedPostObservable method not available"),(0,a.of)(null)):((0,s.logError)("Social plugin not initialized"),(0,a.of)(null))}searchByHashtagObservable(e){return this.social?"function"==typeof this.social.searchByHashtagObservable?this.social.searchByHashtagObservable(e):((0,s.logError)("searchByHashtagObservable method not available"),(0,a.of)([])):((0,s.logError)("Social plugin not initialized"),(0,a.of)([]))}getProfileObservable(e){return this.social?"function"==typeof this.social.getProfileObservable?this.social.getProfileObservable(e):((0,s.logError)("getProfileObservable method not available"),(0,a.of)({pub:e,followers:[],following:[],customFields:{}})):((0,s.logError)("Social plugin not initialized"),(0,a.of)({pub:e,followers:[],following:[],customFields:{}}))}async getAllUsers(){return this.social?"function"==typeof this.social.getAllUsers?this.social.getAllUsers():((0,s.logError)("getAllUsers method not available"),[]):((0,s.logError)("Social plugin not initialized"),[])}getAllUsersObservable(){return this.social?"function"==typeof this.social.getAllUsersObservable?this.social.getAllUsersObservable():((0,s.logError)("getAllUsersObservable method not available"),(0,a.of)([])):((0,s.logError)("Social plugin not initialized"),(0,a.of)([]))}}t.SocialPlugin=o},51024:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.qs=t.getSet=t.getUUID=t.getTargetPub=t.getPub=t.getId=void 0;t.getId=e=>e?._?.["#"];t.getPub=e=>{const t=/~([^@][^\.]+\.[^\.]+)/.exec(e);return t?t[1]:null};t.getTargetPub=e=>{const t=/~[^@][^\.]+\.[^\.]+.*~([^@][^\.]+\.[^\.]+)$/.exec(e);return t?t[1]:null};t.getUUID=e=>e.opt()._.opt.uuid();t.getSet=(e,t)=>{const r=e[t];return r?Object.keys(r).filter((e=>"_"!==e)).map((e=>r[e])).filter((e=>e&&"object"==typeof e&&e["#"])).map((t=>e[t["#"]])).filter(Boolean):[]};t.qs=(e,t="?")=>{const r=Object.fromEntries(Object.entries(e).filter((([e,t])=>t))),n=JSON.stringify(r);return n?`${t}${n}`:""}},55660:function(e,t,r){"use strict";var n,i=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),a=0;a<r.length;a++)"default"!==r[a]&&i(t,e,r[a]);return s(t,e),t});Object.defineProperty(t,"__esModule",{value:!0}),t.Social=void 0;const o=r(45628),l=a(r(91565)),c=r(14134),u=r(85183),g=r(63475),h=r(79364),d=r(92794);class p extends c.EventEmitter{gun;user;profileCache=new Map;cacheDuration=3e5;gunRx;constructor(e){super(),this.gun=e,this.user=this.gun.user(),this.gunRx=new g.GunRxJS(e)}debug(e,...t){(0,o.logDebug)(`[Social] ${e}`,...t)}error(e,...t){(0,o.logError)(`[Social] ${e}`,...t)}generateUUID(){return l.randomUUID?l.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}))}cleanup(){this.profileCache.clear(),this.removeAllListeners()}extractHashtags(e){if(!e)return[];const t=e.match(/#(\w+)/g);return t?t.map((e=>e.substring(1).toLowerCase())):[]}async indexPostByHashtags(e,t){if(t&&0!==t.length){(0,o.logDebug)(`Indicizzazione post ${e} per ${t.length} hashtag`);for(const r of t)await new Promise((t=>{this.gun.get("hashtags").get(r).get(e).put(!0,(()=>t()))}))}}async post(e,t){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");if(!e||""===e.trim())throw new Error("Contenuto post non valido");try{const r=this.user.is.pub,n=this.generateUUID(),i=Date.now(),s=e.trim(),a=this.extractHashtags(s),l=a.length>0,c={};a.forEach((e=>{c[e]=!0}));const u={id:n,author:r,content:s,timestamp:i,payload:{}};return t&&(u.imageData=t,u.payload.imageData=t),l&&(u.hashtags=c,u._hashtagsList=a),(0,o.logDebug)(`Creazione post: ${n} ${l?"con hashtag: "+a.join(", "):""} ${t?"con immagine":"senza immagine"}`),new Promise((e=>{this.gun.get("posts").get(n).put(u,(async t=>{if(t.err)return(0,o.logError)(`Errore salvataggio post: ${t.err}`),void e(null);this.gun.get("users").get(r).get("posts").get(n).put(!0),l&&await this.indexPostByHashtags(n,a),setTimeout((()=>{this.gun.get("posts").get(n).once((e=>{e&&e.content?(0,o.logDebug)(`Verifica post ${n}: contenuto correttamente salvato`):((0,o.logWarn)(`Verifica post ${n}: contenuto mancante, riprovando la scrittura`),this.gun.get("posts").get(n).put(u))}))}),500),l&&(u.hashtagsList=a),this.emit("new:post",u),(0,o.logDebug)(`Post creato: ${n}`),e(u)}))}))}catch(e){return(0,o.logError)(`Errore creazione post: ${e}`),null}}async follow(e){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");if(e===this.user.is.pub)return(0,o.logWarn)("Non puoi seguire te stesso"),!1;try{const t=this.user.is.pub;return(0,o.logDebug)(`Follow: ${t} → ${e}`),await new Promise(((r,n)=>{this.gun.get("users").get(t).get("following").get(e).put(!0,(e=>{e.err?n(new Error(e.err)):r()}))})),await new Promise(((r,n)=>{this.gun.get("users").get(e).get("followers").get(t).put(!0,(e=>{e.err?n(new Error(e.err)):r()}))})),this.profileCache.delete(t),this.profileCache.delete(e),this.emit("follow",e),!0}catch(e){return(0,o.logError)(`Errore follow: ${e}`),!1}}async unfollow(e){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");if(e===this.user.is.pub)return(0,o.logWarn)("Non puoi smettere di seguire te stesso"),!1;try{const t=this.user.is.pub;return(0,o.logDebug)(`Unfollow: ${t} ⊘ ${e}`),await new Promise((r=>{this.gun.get("users").get(t).get("following").get(e).put(null,(()=>r()))})),await new Promise((r=>{this.gun.get("users").get(e).get("followers").get(t).put(null,(()=>r()))})),this.profileCache.delete(t),this.profileCache.delete(e),this.emit("unfollow",e),!0}catch(e){return(0,o.logError)(`Errore unfollow: ${e}`),!1}}async getProfile(e){const t=this.profileCache.get(e);if(t&&Date.now()-t.timestamp<this.cacheDuration)return t.data;const r={pub:e,followers:[],following:[],customFields:{}};try{return await new Promise((t=>{this.gun.get("users").get(e).once((e=>{e&&(e.alias&&(r.alias=e.alias),e.bio&&(r.bio=e.bio),e.profileImage&&(r.profileImage=e.profileImage)),t()}))})),await new Promise((t=>{this.gun.get("users").get(e).get("followers").map().once(((e,t)=>{"_"!==t&&!0===e&&r.followers.push(t)})),setTimeout(t,500)})),await new Promise((t=>{this.gun.get("users").get(e).get("following").map().once(((e,t)=>{"_"!==t&&!0===e&&r.following.push(t)})),setTimeout(t,500)})),this.profileCache.set(e,{data:r,timestamp:Date.now()}),r}catch(e){return(0,o.logError)(`Errore caricamento profilo: ${e}`),r}}async updateProfile(e,t){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");try{return await new Promise(((r,n)=>{this.gun.get("users").get(this.user.is.pub).get(e).put(t,(e=>{e.err?n(new Error(e.err)):r()}))})),this.profileCache.delete(this.user.is.pub),!0}catch(e){return(0,o.logError)(`Errore aggiornamento profilo: ${e}`),!1}}async getTimeline(e=10,t={includeLikes:!0}){return this.gun&&this.user?(this.debug("getTimeline - Recupero timeline con limite:",e),new Promise((r=>{const n=[],i=new Set,s=setTimeout((()=>{this.debug(`getTimeline - Timeout dopo ${t.timeout||5e3}ms - Restituisco ${n.length} posts`),n.sort(((e,t)=>t.createdAt-e.createdAt)),r({messages:n})}),t.timeout||5e3);this.gun.get("posts").map().once((async(a,o)=>{try{if(!a||i.has(o))return;i.add(o),this.debug(`getTimeline - Post trovato: ${o}`);let l=a.content||"",c=a.imageData||null;if((!l||!c)&&a.payload)try{a.payload.content&&!l&&(l=a.payload.content,this.debug(`getTimeline - Contenuto recuperato da payload diretto: ${l.substring(0,20)}...`)),a.payload.imageData&&!c&&(c=a.payload.imageData,this.debug(`getTimeline - Immagine recuperata da payload diretto per post: ${o}`))}catch(e){this.error("Errore recupero payload post:",e)}const g={id:o,type:u.MessageType.POST,subtype:u.MessageSubtype.EMPTY,creator:a.author||a.creator||"sconosciuto",createdAt:a.timestamp||Date.now(),payload:{content:l||""}};if(c&&(g.payload.attachment=c),t.includeLikes)try{const e=await this.getLikesObject(o);g.likes=e}catch(e){this.error(`Errore recupero likes per post ${o}:`,e)}n.push(g),n.length>=e&&(clearTimeout(s),n.sort(((e,t)=>t.createdAt-e.createdAt)),r({messages:n}))}catch(e){this.error("Errore elaborazione post:",e)}}))}))):(this.error("Gun/SEA non disponibile"),{messages:[],error:"Database non disponibile"})}async getLikesObject(e){const t={};return new Promise((r=>{this.gun.get("posts").get(e).get("likes").map().once(((e,r)=>{"_"!==r&&!0===e&&(t[r]=!0)})),setTimeout((()=>r(t)),500)}))}async addComment(e,t){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");if(!e||!t||""===t.trim())throw new Error("Dati commento non validi");try{const r=this.user.is.pub,n=this.generateUUID(),i=Date.now(),s={id:n,postId:e,author:r,content:t.trim(),timestamp:i};return new Promise((t=>{this.gun.get("posts").get(e).get("comments").get(n).put(s,(r=>{r.err?((0,o.logError)(`Errore salvataggio commento: ${r.err}`),t(null)):(setTimeout((()=>{this.gun.get("posts").get(e).get("comments").get(n).once((t=>{t&&t.content?(0,o.logDebug)(`Verifica commento ${n}: contenuto correttamente salvato`):((0,o.logWarn)(`Verifica commento ${n}: contenuto mancante, riprovando la scrittura`),this.gun.get("posts").get(e).get("comments").get(n).put(s))}))}),500),(0,o.logDebug)(`Commento ${n} aggiunto al post ${e}`),t(s))}))}))}catch(e){return(0,o.logError)(`Errore aggiunta commento: ${e}`),null}}async getComments(e){if(!e)throw new Error("ID post non valido");try{const t=[];return await new Promise((r=>{this.gun.get("posts").get(e).get("comments").map().once(((r,n)=>{if("_"!==n&&r){const i={id:r.id||n,author:r.author||"Anonimo",content:r.content||"",timestamp:r.timestamp||Date.now(),postId:e};r.content||(0,o.logWarn)(`Commento ${n} senza contenuto, verifica i dati in GunDB`),t.push(i)}})),setTimeout(r,500)})),t.sort(((e,t)=>t.timestamp-e.timestamp)),t}catch(e){return(0,o.logError)(`Errore recupero commenti: ${e}`),[]}}async likePost(e){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");try{const t=this.user.is.pub;return await new Promise(((r,n)=>{this.gun.get("posts").get(e).get("likes").get(t).put(!0,(e=>{e.err?n(new Error(e.err)):r()}))})),!0}catch(e){return(0,o.logError)(`Errore like post: ${e}`),!1}}async unlikePost(e){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");try{const t=this.user.is.pub;return await new Promise((r=>{this.gun.get("posts").get(e).get("likes").get(t).put(null,(()=>r()))})),!0}catch(e){return(0,o.logError)(`Errore unlike post: ${e}`),!1}}async getLikes(e){if(!e)throw new Error("ID post non valido");try{const t=[];return await new Promise((r=>{this.gun.get("posts").get(e).get("likes").map().once(((e,r)=>{"_"!==r&&!0===e&&t.push(r)})),setTimeout(r,500)})),t}catch(e){return(0,o.logError)(`Errore recupero likes: ${e}`),[]}}async getLikeCount(e){return(await this.getLikes(e)).length}async searchByHashtag(e){if(!e)throw new Error("Hashtag non valido");const t=e.startsWith("#")?e.substring(1).toLowerCase():e.toLowerCase();(0,o.logDebug)(`Ricerca post con hashtag #${t}`);try{const e=[];if(await new Promise((r=>{this.gun.get("hashtags").get(t).map().once(((t,r)=>{"_"!==r&&!0===t&&e.push(r)})),setTimeout(r,1e3)})),0===e.length)return(0,o.logDebug)(`Nessun post trovato con hashtag #${t}`),[];(0,o.logDebug)(`Trovati ${e.length} post con hashtag #${t}`);const r=[];for(const t of e){const e=await new Promise((e=>{this.gun.get("posts").get(t).once((t=>{e(t)})),setTimeout((()=>e(null)),500)}));if(e&&e.content){const t={...e};t.hashtagsList||(e._hashtagsList?t.hashtagsList=e._hashtagsList:e.hashtags?"object"!=typeof e.hashtags||Array.isArray(e.hashtags)?Array.isArray(e.hashtags)&&(t.hashtagsList=e.hashtags):t.hashtagsList=Object.keys(e.hashtags).filter((t=>!0===e.hashtags[t])):t.hashtagsList=[]),r.push(t)}}return r.sort(((e,t)=>(t.timestamp||0)-(e.timestamp||0))),r}catch(e){return(0,o.logError)(`Errore ricerca hashtag: ${e}`),[]}}async deletePost(e){if(!this.user.is||!this.user.is.pub)throw new Error("Non autenticato");try{const t=await new Promise((t=>{this.gun.get("posts").get(e).once((e=>{t(e)}))}));if(!t)return(0,o.logError)(`Post ${e} non trovato`),!1;const r=this.user.is.pub;if((t.author||t.creator)!==r)return(0,o.logWarn)(`L'utente ${r} non è autorizzato a eliminare il post ${e}`),!1;(0,o.logDebug)(`Eliminazione post: ${e}`);let n=[];if(t.hashtagsList&&Array.isArray(t.hashtagsList)?n=t.hashtagsList:t.hashtags&&(n=Array.isArray(t.hashtags)?t.hashtags:Object.keys(t.hashtags).filter((e=>!0===t.hashtags[e]))),n.length>0)for(const t of n)await new Promise((r=>{this.gun.get("hashtags").get(t).get(e).put(null,(()=>r()))}));return await new Promise((t=>{this.gun.get("users").get(r).get("posts").get(e).put(null,(()=>t()))})),await new Promise((t=>{this.gun.get("posts").get(e).put(null,(()=>t()))})),this.emit("delete:post",{id:e,author:r}),(0,o.logDebug)(`Post ${e} eliminato`),!0}catch(e){return(0,o.logError)(`Errore eliminazione post: ${e}`),!1}}getTimelineObservable(e=10,t={includeLikes:!0}){return this.gun&&this.user?this.gunRx.match("posts").pipe((0,d.map)((t=>{if(!t||!t.length)return[];return t.slice(0,e).map((e=>{const t=e.id||"",r=e.author||e.creator||"sconosciuto",n=e.timestamp||e.createdAt||Date.now();let i=e.content||"",s=null;i&&s||!e.payload||(i=e.payload.content||i,s=e.payload.imageData||null);const a={id:t,type:u.MessageType.POST,subtype:u.MessageSubtype.EMPTY,creator:r,createdAt:n,payload:{content:i}};return s&&(a.payload.attachment=s),a}))})),(0,d.tap)((e=>this.debug(`Timeline observable: ricevuti ${e.length} post`)))):(this.error("Gun/SEA non disponibile"),(0,h.of)([]))}getCommentsObservable(e){return e?this.gunRx.observe(`posts/${e}/comments`).pipe((0,d.map)((t=>{if(!t)return[];return Object.entries(t).filter((([e,t])=>"_"!==e)).map((([t,r])=>{const n=r;return{id:n.id||t,author:n.author||"Anonimo",content:n.content||"",timestamp:n.timestamp||Date.now(),postId:e}})).filter((e=>e.content)).sort(((e,t)=>t.timestamp-e.timestamp))})),(0,d.tap)((t=>this.debug(`Commenti observable per post ${e}: ${t.length} commenti`)))):(0,h.of)([])}getLikesObservable(e){return e?this.gunRx.observe(`posts/${e}/likes`).pipe((0,d.map)((e=>e?Object.entries(e).filter((([e,t])=>"_"!==e&&!0===t)).map((([e,t])=>e)):[])),(0,d.tap)((t=>this.debug(`Like observable per post ${e}: ${t.length} like`)))):(0,h.of)([])}getLikeCountObservable(e){return this.getLikesObservable(e).pipe((0,d.map)((e=>e.length)))}getEnrichedPostObservable(e){return this.gunRx.observe(`posts/${e}`).pipe((0,d.switchMap)((t=>{if(!t)return(0,h.of)(null);const r=t,n=r.author||r.creator;if(!n)return(0,h.of)({...r,authorProfile:{pub:"sconosciuto"}});const i=this.gunRx.observe(`users/${n}`);return(0,h.combineLatest)([(0,h.of)(r),i]).pipe((0,d.map)((([t,r])=>{const n={...t};return n.payload?!n.payload.content&&n.content&&(n.payload.content=n.content):n.payload={content:n.content||""},n.id||(n.id=e),n.timestamp||(n.timestamp=Date.now()),{...n,authorProfile:r||{pub:t.author||"sconosciuto"}}})))})),(0,d.tap)((t=>{t?this.debug(`Post arricchito ${e} caricato con successo`):this.debug(`Post ${e} non trovato`)})),(0,d.catchError)((e=>(this.error(`Errore caricamento post arricchito: ${e}`),(0,h.of)(null)))))}searchByHashtagObservable(e){if(!e)return(0,h.of)([]);const t=e.startsWith("#")?e.substring(1).toLowerCase():e.toLowerCase();return this.debug(`Ricerca observable per hashtag #${t}`),this.gunRx.observe(`hashtags/${t}`).pipe((0,d.switchMap)((e=>{if(!e)return(0,h.of)([]);const t=Object.keys(e).filter((e=>"_"!==e));if(0===t.length)return(0,h.of)([]);const r=t.map((e=>this.gunRx.observe(`posts/${e}`).pipe((0,d.map)((e=>{if(e){const t={...e};return t.hashtagsList||(t._hashtagsList?t.hashtagsList=t._hashtagsList:t.hashtags?"object"!=typeof t.hashtags||Array.isArray(t.hashtags)?Array.isArray(t.hashtags)&&(t.hashtagsList=t.hashtags):t.hashtagsList=Object.keys(t.hashtags).filter((e=>!0===t.hashtags[e])):t.hashtagsList=[]),t}return e})))));return(0,h.combineLatest)(r)})),(0,d.map)((e=>e.filter((e=>e&&e.content)))),(0,d.map)((e=>e.sort(((e,t)=>(t.timestamp||0)-(e.timestamp||0))))),(0,d.tap)((e=>this.debug(`Trovati ${e.length} post con hashtag #${t}`))))}getProfileObservable(e){if(!e)return(0,h.of)({pub:"",followers:[],following:[],customFields:{}});const t={pub:e,followers:[],following:[],customFields:{}},r=this.gunRx.observe(`users/${e}`),n=this.gunRx.observe(`users/${e}/followers`),i=this.gunRx.observe(`users/${e}/following`);return(0,h.combineLatest)([r,n,i]).pipe((0,d.map)((([e,r,n])=>{const i=e,s=r,a=n,o={...t};return i&&(i.alias&&(o.alias=i.alias),i.bio&&(o.bio=i.bio),i.profileImage&&(o.profileImage=i.profileImage)),s&&(o.followers=Object.keys(s).filter((e=>"_"!==e&&!0===s[e]))),a&&(o.following=Object.keys(a).filter((e=>"_"!==e&&!0===a[e]))),o})),(0,d.tap)((t=>this.debug(`Profilo observable ${e}: ${t.followers.length} followers, ${t.following.length} following`))))}async getAllUsers(){return this.debug("Recupero di tutti gli utenti dalla rete"),new Promise((e=>{const t=[],r=new Set,n=setTimeout((()=>{this.debug(`Timeout raggiunto, restituisco ${t.length} utenti trovati`),e(t)}),5e3);this.gun.get("users").map().once((async(i,s)=>{try{if("_"===s||r.has(s))return;r.add(s),this.debug(`Utente trovato: ${s}`);const a={pub:s,followers:[],following:[],customFields:{}};i&&(i.alias&&(a.alias=i.alias),i.bio&&(a.bio=i.bio),i.profileImage&&(a.profileImage=i.profileImage)),t.push(a),t.length>100&&(clearTimeout(n),this.debug("Limite utenti raggiunto (100), concludo la ricerca"),e(t))}catch(e){this.error(`Errore elaborazione utente ${s}:`,e)}}))}))}getAllUsersObservable(){return new h.Observable((e=>{this.debug("Avvio ricerca utenti observable");const t=[],r=new Set,n=setTimeout((()=>{this.debug(`Timeout ricerca utenti observable: trovati ${t.length} utenti`),e.next([...t])}),5e3);return this.gun.get("users").map().on(((n,i)=>{try{if("_"===i||r.has(i))return;r.add(i);const s={pub:i,followers:[],following:[],customFields:{}};n&&(n.alias&&(s.alias=n.alias),n.bio&&(s.bio=n.bio),n.profileImage&&(s.profileImage=n.profileImage)),t.push(s),e.next([...t])}catch(e){this.error(`Errore elaborazione utente observable ${i}:`,e)}})),()=>{clearTimeout(n),this.debug("Observable utenti chiuso")}}))}}t.Social=p},55736:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=55736,e.exports=t},61731:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},63009:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.issueCert=s,t.generateCerts=async function({pair:e,list:t=[]}){const r={};for(const n of t)r[n.tag]=await s({...n,pair:e});return r},t.verifyCert=async function(e,t){if(!e)return null;try{return await i.default.SEA.verify(e,t)}catch(e){return null}},t.extractCertPolicy=async function(e){if(!e)return null;try{const t=JSON.parse(e);return t&&t.m?t.m:null}catch(e){return null}};const i=n(r(59229));async function s({pair:e,tag:t="word",dot:r="",users:n="*",personal:s=!1}){const a={"*":`${t}`};r&&(a["."]=r),s&&(a["+"]="*");try{return await i.default.SEA.certify(n,a,e,null)||""}catch(e){return""}}r(38030)},63475:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunRxJS=void 0;const n=r(79364),i=r(92794);t.GunRxJS=class{gun;user;constructor(e){this.gun=e,this.user=e.user().recall({sessionStorage:!0})}getUser(){return this.user}getUserPub(){return this.user.is?.pub}observe(e){return new n.Observable((t=>{const r="string"==typeof e?this.gun.get(e):e,n=r.on(((e,r)=>{if(null!=e)if("object"==typeof e&&null!==e){const r=this.removeGunMeta(e);t.next(r)}else t.next(e);else t.next(null)}));return()=>{n&&"function"==typeof n&&n(),r.off()}})).pipe((0,i.distinctUntilChanged)(((e,t)=>JSON.stringify(e)===JSON.stringify(t))))}match(e,t){return new n.Observable((r=>{const n="string"==typeof e?this.gun.get(e):e,i={},s=n.map().on(((e,n)=>{if("_"===n||!e)return;if(t&&!t(e))return void(i[n]&&(delete i[n],r.next(Object.values(i))));const s="object"==typeof e?this.removeGunMeta(e):e;i[n]=s,r.next(Object.values(i))}));return()=>{s&&"function"==typeof s&&s(),n.off()}}))}put(e,t){const r="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{r.put(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}set(e,t){const r="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{r.set(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}once(e){const t="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{t.once((t=>{if(null==t)return e.next(null),void e.complete();const r="object"==typeof t?this.removeGunMeta(t):t;e.next(r),e.complete()}))}))}compute(e,t){const r=e.map((e=>"string"==typeof e?this.observe(e):e));return new n.Observable((n=>{let i=new Array(e.length).fill(void 0),s=new Array(e.length).fill(!1);const a=r.map(((e,r)=>e.subscribe({next:e=>{if(i[r]=e,i.every((e=>void 0!==e)))try{const e=t(...i);n.next(e)}catch(e){n.error(e)}},error:e=>n.error(e),complete:()=>{s[r]=!0,s.every((e=>e))&&n.complete()}})));return()=>{a.forEach((e=>e.unsubscribe()))}}))}userPut(e,t){return new n.Observable((r=>{this.gun.user().get(e).put(t,(e=>{e.err?r.error(new Error(e.err)):(r.next(t),r.complete())}))}))}userGet(e){return this.observe(this.gun.user().get(e))}observeUser(e){return this.observe(this.gun.user().get(e))}removeGunMeta(e){if(!e||"object"!=typeof e)return e;const t=Array.isArray(e)?[]:{};return Object.keys(e).forEach((r=>{if("_"===r||"#"===r)return;const n=e[r];t[r]=n&&"object"==typeof n?this.removeGunMeta(n):n})),t}}},64994:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.NetworkError=t.MultipleAuthError=t.TimeoutError=t.UserExists=t.InvalidCredentials=t.AuthError=t.GunError=void 0;class r extends Error{constructor(e){super(e),this.name="GunError"}}t.GunError=r;class n extends r{constructor(e){super(e),this.name="AuthError"}}t.AuthError=n;t.InvalidCredentials=class extends n{constructor(e="Credenziali non valide"){super(e),this.name="InvalidCredentials"}};t.UserExists=class extends n{constructor(e="Utente già esistente"){super(e),this.name="UserExists"}};t.TimeoutError=class extends r{constructor(e="Timeout durante l'operazione"){super(e),this.name="TimeoutError"}};t.MultipleAuthError=class extends n{constructor(e="Autenticazione multipla in corso"){super(e),this.name="MultipleAuthError"}};t.NetworkError=class extends r{}},67160:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.MetaMask=void 0;const i=r(14193),s=r(45628),a=n(r(7028)),o=r(23358),l=r(14134);class c extends l.EventEmitter{AUTH_DATA_TABLE;MESSAGE_TO_SIGN="I Love Shogun!";DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4};config;signatureCache=new Map;provider=null;customProvider=null;customWallet=null;constructor(e={}){super(),this.config={...this.DEFAULT_CONFIG,...e},this.AUTH_DATA_TABLE=a.default.GUN_TABLES.AUTHENTICATIONS||"Authentications",this.initProvider(),this.setupEventListeners()}initProvider(){if("undefined"!=typeof window&&window.ethereum)try{this.provider=new i.ethers.BrowserProvider(window.ethereum),(0,s.logDebug)("BrowserProvider initialized successfully")}catch(e){(0,s.logError)("Failed to initialize BrowserProvider",e)}else(0,s.logWarn)("Window.ethereum is not available")}async setupProvider(){try{"undefined"!=typeof window&&window.ethereum?(this.provider=new i.ethers.BrowserProvider(window.ethereum),(0,s.logDebug)("BrowserProvider initialized successfully")):(0,s.logWarn)("Window.ethereum is not available")}catch(e){(0,s.logError)("Failed to initialize BrowserProvider",e)}}setupEventListeners(){this.provider&&(this.provider.on("network",((e,t)=>{this.emit("chainChanged",e)})),window.ethereum?.on&&window.ethereum.on("accountsChanged",(e=>{this.emit("accountsChanged",e)})))}cleanup(){this.provider&&this.provider.removeAllListeners(),this.removeAllListeners()}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim().toLowerCase();if(!i.ethers.isAddress(t))throw new Error("Invalid address format");return i.ethers.getAddress(t)}catch(e){throw o.ErrorHandler.handle(o.ErrorType.VALIDATION,"INVALID_ADDRESS","Invalid Ethereum address provided",e),e}}async connectMetaMask(){try{if((0,s.logDebug)("Attempting to connect to MetaMask..."),!this.provider&&((0,s.logDebug)("Provider not initialized, setting up..."),this.initProvider(),!this.provider))throw new Error("MetaMask is not available. Please install MetaMask extension.");(0,s.logDebug)("Requesting account access...");let e=[];if(window.ethereum)try{e=await window.ethereum.request({method:"eth_requestAccounts"}),(0,s.logDebug)(`Accounts requested successfully: ${e.length} accounts returned`)}catch(e){throw(0,s.logError)("Error requesting MetaMask accounts:",e),new Error("User denied account access")}e&&0!==e.length||(0,s.logDebug)("No accounts found, trying to get signer...");for(let e=1;e<=this.config.maxRetries;e++)try{(0,s.logDebug)(`Attempt ${e} to get signer...`);const t=await this.provider.getSigner(),r=await t.getAddress();if(!r)throw(0,s.logError)("No address returned from signer"),new Error("No accounts found in MetaMask");(0,s.logDebug)(`Signer address obtained: ${r}`);const n=`mm_${r.toLowerCase()}`;return this.emit("connected",{address:r}),(0,s.logDebug)(`MetaMask connected successfully with address: ${r}`),{success:!0,address:r,username:n}}catch(t){if((0,s.logError)(`Error in connection attempt ${e}:`,t),e===this.config.maxRetries)throw t;(0,s.logDebug)(`Retrying in ${this.config.retryDelay}ms...`),await new Promise((e=>setTimeout(e,this.config.retryDelay)))}throw new Error("Failed to connect after retries")}catch(e){return(0,s.logError)("Failed to connect to MetaMask:",e),o.ErrorHandler.handle(o.ErrorType.NETWORK,"METAMASK_CONNECTION_ERROR",e.message??"Unknown error while connecting to MetaMask",e),{success:!1,error:e.message}}}async generateCredentials(e){(0,s.log)("Generating credentials for address:",e);try{const t=this.validateAddress(e);(0,s.log)("Valid Address:",t);const r=this.getCachedSignature(t);if(r)return(0,s.log)("Using cached signature for address:",t),this.generateCredentialsFromSignature(t,r);try{(0,s.log)("Request signature with timeout");const e=await this.requestSignatureWithTimeout(t,this.MESSAGE_TO_SIGN,this.config.timeout);return this.cacheSignature(t,e),this.generateCredentialsFromSignature(t,e)}catch(e){return(0,s.logWarn)(`Failed to get signature: ${e}. Using fallback method.`),this.generateFallbackCredentials(t)}}catch(e){throw o.ErrorHandler.handle(o.ErrorType.AUTHENTICATION,"CREDENTIALS_GENERATION_ERROR",e.message??"Error generating MetaMask credentials",e),e}}generateCredentialsFromSignature(e,t){(0,s.log)("Generating credentials from signature");return{username:`mm_${e.toLowerCase()}`,password:i.ethers.keccak256(i.ethers.toUtf8Bytes(`${t}:${e.toLowerCase()}`)),message:this.MESSAGE_TO_SIGN,signature:t}}generateFallbackCredentials(e){(0,s.logWarn)("Using fallback credentials generation for address:",e);const t=`mm_${e.toLowerCase()}`,r=`SHOGUN_FALLBACK:${e.toLowerCase()}`;return{username:t,password:i.ethers.keccak256(i.ethers.toUtf8Bytes(r)),message:r,signature:i.ethers.keccak256(i.ethers.toUtf8Bytes(r))}}static isMetaMaskAvailable(){const e=window.ethereum;return"undefined"!=typeof window&&void 0!==e&&!0===e?.isMetaMask}requestSignatureWithTimeout(e,t,r=3e4){return new Promise(((n,i)=>{let a=setTimeout((()=>{a=null,i(new Error("Timeout requesting signature"))}),r);const o=()=>{a&&(clearTimeout(a),a=null),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",l)},l=e=>{o(),i(e)};window.ethereum?.on&&window.ethereum.on("accountsChanged",l),(0,s.log)("Initialize and Sign");return(async()=>{try{if(!this.provider&&(this.initProvider(),!this.provider))throw new Error("Provider not initialized");const r=await this.provider.getSigner(),i=await r.getAddress();if((0,s.log)("Signer:",r),(0,s.log)("Signer Address:",i),i.toLowerCase()!==e.toLowerCase())throw new Error(`Signer address (${i}) does not match expected address (${e})`);(0,s.log)(`Requesting signature for message: ${t}`);const a=await r.signMessage(t);(0,s.log)("Signature obtained successfully"),o(),n(a)}catch(e){(0,s.logError)("Failed to request signature:",e),o(),i(e)}})()}))}isAvailable(){return"undefined"!=typeof window&&!!window.ethereum}setCustomProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Invalid RPC URL");if(!t||"string"!=typeof t)throw new Error("Invalid private key");try{this.customProvider=new i.ethers.JsonRpcProvider(e),this.customWallet=new i.ethers.Wallet(t,this.customProvider),(0,s.logDebug)("Custom provider configured successfully")}catch(e){throw new Error(`Error configuring provider: ${e.message??"Unknown error"}`)}}async getSigner(){try{if(this.customWallet)return this.customWallet;if(this.provider||this.initProvider(),!this.provider)throw new Error("Provider not initialized");return await this.provider.getSigner()}catch(e){throw new Error(`Unable to get Ethereum signer: ${e.message||"Unknown error"}`)}}async generatePassword(e){if(!e)throw new Error("Invalid signature");return i.ethers.keccak256(i.ethers.toUtf8Bytes(e)).slice(2,66)}async verifySignature(e,t){if(!e||!t)throw new Error("Invalid message or signature");try{return i.ethers.verifyMessage(e,t)}catch(e){throw new Error("Invalid message or signature")}}async getEthereumSigner(){if(!c.isMetaMaskAvailable())throw new Error("MetaMask not found. Please install MetaMask to continue.");try{const e=window.ethereum;await e.request({method:"eth_requestAccounts"});return new i.ethers.BrowserProvider(e).getSigner()}catch(e){throw new Error(`Error accessing MetaMask: ${e.message??"Unknown error"}`)}}}t.MetaMask=c,"undefined"!=typeof window?window.MetaMask=c:void 0!==r.g&&(r.g.MetaMask=c)},68804:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunDID=void 0;const n=r(14193),i=r(45628),s=r(23358),a=r(14134);class o extends a.EventEmitter{core;methodName="shogun";didCache=new Map;DEFAULT_CACHE_DURATION=18e5;DEFAULT_TIMEOUT=1e4;DEFAULT_MAX_RETRIES=3;DEFAULT_RETRY_DELAY=1e3;options;registryConfig={address:"0x1234...",network:"mainnet",timeout:this.DEFAULT_TIMEOUT,maxRetries:this.DEFAULT_MAX_RETRIES,retryDelay:this.DEFAULT_RETRY_DELAY};constructor(e,t,r){super(),this.core=e,this.registryConfig={...this.registryConfig,...t},this.options=r||{useSecureRandomPassword:!0},(0,i.log)("ShogunDID initialized")}async createDID(e={}){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to create a DID");const t=this.getUserPublicKey();if(!t)throw new Error("Cannot retrieve user's public key");let r=n.ethers.keccak256(n.ethers.toUtf8Bytes(t)).slice(2,42);e.network&&(r=`${e.network}:${r}`);const s=`did:${this.methodName}:${r}`;return await this.storeDID(s,e),this.emit("didCreated",{did:s}),(0,i.log)(`Created DID: ${s}`),s}catch(e){throw(0,i.logError)("Error creating DID:",e),s.ErrorHandler.handle(s.ErrorType.DID,"CREATE_DID_ERROR",e instanceof Error?e.message:"Error creating DID",e),e}}async storeDID(e,t){try{if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=t.document||this.createDidDocument(e,t);return new Promise(((t,n)=>{this.core.gun.get("dids").get(e).put({document:JSON.stringify(r),created:(new Date).toISOString(),updated:(new Date).toISOString(),deactivated:!1},(r=>{r.err?n(new Error(`Failed to store DID: ${r.err}`)):this.core.gun.user().get("did").put(e,(e=>{e.err&&(0,i.logError)(`Warning: DID created but not associated with user: ${e.err}`),t()}))})),setTimeout((()=>n(new Error("Timeout storing DID"))),1e4)}))}catch(e){throw(0,i.logError)("Error storing DID:",e),e}}createDidDocument(e,t){const r=t.controller??this.getUserPublicKey()??e,i={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:r,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${this.getUserPublicKey()||n.ethers.keccak256(n.ethers.toUtf8Bytes(e))}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(i.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),i}getUserPublicKey(){try{if(!this.core.isLoggedIn())return null;const e=this.core.gun.user();return(e&&e._&&e._.sea&&e._.sea.pub)??null}catch(e){return(0,i.logError)("Error getting user public key:",e),null}}async resolveDID(e,t={}){try{const r=t.cacheDuration??this.DEFAULT_CACHE_DURATION,n=t.timeout??this.DEFAULT_TIMEOUT,i=this.didCache.get(e);if(i&&Date.now()-i.timestamp<r)return{didResolutionMetadata:{contentType:"application/did+json"},didDocument:this.getDocumentFromCache(i),didDocumentMetadata:{}};if(!this.isValidDID(e))return this.createErrorResolution("invalidDid","Invalid DID format");const[s,a,o]=e.split(":");return a!==this.methodName?this.createErrorResolution("unsupportedDidMethod",`Unsupported DID method: ${a}`):new Promise(((t,r)=>{const i=setTimeout((()=>{t(this.createErrorResolution("timeout","DID resolution timeout"))}),n);this.core.gun.get("dids").get(e).once((r=>{if(clearTimeout(i),r)try{const n=this.parseOrCreateDIDDocument(e,r);this.didCache.set(e,{data:n,document:n,timestamp:Date.now(),network:o.split(":")[0]||"main"}),t({didResolutionMetadata:{contentType:"application/did+json"},didDocument:n,didDocumentMetadata:{created:r.created,updated:r.updated,deactivated:r.deactivated??!1}})}catch(e){t(this.createErrorResolution("invalidDidDocument","Error parsing DID Document"))}else t(this.createErrorResolution("notFound","DID Document not found"))}))}))}catch(e){return(0,i.logError)("Error resolving DID:",e),this.createErrorResolution("internalError",e instanceof Error?e.message:"Unknown error")}}async registerDIDOnChain(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to register DID on chain");let r=t||this.getWallet();if(!r)throw new Error("No signer provided and main wallet not available");const s=["function registerDID(string did, string controller) public returns (bool)"],a=new n.ethers.Contract(this.registryConfig.address,s,r);for(let t=1;t<=this.registryConfig.maxRetries;t++)try{const t=await a.registerDID(e,this.getUserPublicKey()),r=await t.wait();return this.emit("didRegistered",{did:e,txHash:r.hash}),(0,i.log)(`DID registered on blockchain: ${e}, tx: ${r.hash}`),{success:!0,txHash:r.hash}}catch(e){if(t===this.registryConfig.maxRetries)throw e;await new Promise((e=>setTimeout(e,this.registryConfig.retryDelay)))}throw new Error("Failed to register DID after retries")}catch(e){return(0,i.logError)("Error registering DID on blockchain:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getCurrentUserDID(){try{if(!this.core.isLoggedIn())return null;return this.getUserPublicKey()?new Promise((e=>{this.core.gun.user().get("did").once((t=>{e(t&&"string"==typeof t?t:null)})),setTimeout((()=>e(null)),5e3)})):null}catch(e){return(0,i.logError)("Error getting current user DID:",e),null}}async authenticateWithDID(e,t){try{if((0,i.log)(`Authenticating with DID: ${e}`),!this.isValidDID(e))return{success:!1,error:"Invalid DID format"};const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)return{success:!1,error:`DID resolution failed: ${r.didResolutionMetadata.error}`};const n=this.extractAuthenticationMethod(r.didDocument);return n?n.type.includes("EcdsaSecp256k1")?this.authenticateWithEthereum(n,t):n.type.includes("WebAuthn")?this.authenticateWithWebAuthn(n,t):this.authenticateWithGunDB(n.controller.split(":").pop()??"",t):{success:!1,error:"No valid authentication method found in DID Document"}}catch(e){return(0,i.logError)("Error authenticating with DID:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error during authentication"}}}async updateDIDDocument(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to update a DID document");if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)throw new Error(`Cannot update DID document: ${r.didResolutionMetadata.error??"Document not found"}`);const n=r.didDocument,s={...n,...t};if(t.service&&n.service){const e=[...n.service];for(const r of t.service){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}s.service=e}if(t.verificationMethod&&n.verificationMethod){const e=[...n.verificationMethod];for(const r of t.verificationMethod){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}s.verificationMethod=e}await this.storeDID(e,{document:s});const[a,,o]=e.split(":");return this.didCache.set(e,{data:s,document:s,timestamp:Date.now(),network:o.split(":")[0]||"main"}),this.emit("didUpdated",{did:e,document:s}),(0,i.log)(`Updated DID Document: ${e}`),!0}catch(e){return(0,i.logError)("Error updating DID document:",e),s.ErrorHandler.handle(s.ErrorType.DID,"UPDATE_DID_ERROR",e instanceof Error?e.message:"Error updating DID",e),!1}}async deactivateDID(e){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to deactivate a DID");const t=await this.getCurrentUserDID();if(e!==t)throw new Error("Cannot deactivate a DID you don't control");return new Promise((t=>{this.core.gun.get("dids").get(e).put({deactivated:!0,updated:(new Date).toISOString()},(r=>{r.err?((0,i.logError)(`Error deactivating DID: ${r.err}`),t(!1)):((0,i.log)(`Successfully deactivated DID: ${e}`),t(!0))})),setTimeout((()=>t(!1)),1e4)}))}catch(e){return(0,i.logError)("Error deactivating DID:",e),!1}}isValidDID(e){return/^did:[a-z0-9]+:[a-zA-Z0-9.:%]+$/.test(e)}generateDIDDocument(e,t={}){const r=this.getUserPublicKey(),n={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:t.controller??e,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${r}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(n.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),n}createErrorResolution(e,t){return{didResolutionMetadata:{error:e,contentType:"application/did+json"},didDocument:null,didDocumentMetadata:{}}}parseOrCreateDIDDocument(e,t){if(t.document)try{return JSON.parse(t.document)}catch(e){(0,i.logError)("Error parsing stored DID Document, creating a basic one",e)}return{"@context":"https://www.w3.org/ns/did/v1",id:e,authentication:[]}}extractAuthenticationMethod(e){const t=e.authentication||[];for(const r of t){if("string"!=typeof r)return r;{const t=r,n=e.verificationMethod?.find((e=>e.id===t));if(n)return{id:n.id,type:n.type,controller:n.controller}}}return null}getWallet(){try{if("ShogunCore"===this.core.constructor.name){if(!this.core.getPlugin)return null;const e=this.core.getPlugin("ShogunCore"===this.core.constructor.name?"wallet":"walletManager");if(e&&"object"==typeof e&&"getMainWallet"in e)return e.getMainWallet()}else if("getMainWallet"in this.core)return this.core.getMainWallet();return null}catch(e){return null}}async authenticateWithEthereum(e,t){const r=e.id.split("#")[0].split(":").pop()||"";if("loginWithMetaMask"in this.core)return this.core.loginWithMetaMask(r);if(!this.core.getAuthenticationMethod)return{success:!1,error:"Authentication method provider not available"};const n=this.core.getAuthenticationMethod("metamask");return n&&"object"==typeof n&&"login"in n?n.login(r):{success:!1,error:"MetaMask authentication not available"}}async authenticateWithWebAuthn(e,t){const r=e.controller.split(":").pop()||"";if("loginWithWebAuthn"in this.core)return this.core.loginWithWebAuthn(r);if(!this.core.getAuthenticationMethod)return{success:!1,error:"Authentication method provider not available"};const n=this.core.getAuthenticationMethod("webauthn");return n&&"object"==typeof n&&"login"in n?n.login(r):{success:!1,error:"WebAuthn authentication not available"}}async authenticateWithGunDB(e,t){try{(0,i.log)("Authenticating with GunDB using password method",e);let r=t??"";this.options&&this.options.useSecureRandomPassword&&!r&&(r=function(e=32){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>e.toString(16).padStart(2,"0"))).join("")}());const n=await async function(e,t){const r=(new TextEncoder).encode(`${e}:${t}`),n=await crypto.subtle.digest("SHA-256",r);return Array.from(new Uint8Array(n)).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e,r);if(!this.core.getAuthenticationMethod)throw new Error("Authentication method provider not available");const s=this.core.getAuthenticationMethod("password");if(!s)throw new Error("Password authentication method not available");return await s.authenticate(e,n)}catch(e){throw(0,i.log)("Error authenticating with GunDB:",e),e}}async verifyDIDOnChain(e){try{const t=["function isDIDRegistered(string did) public view returns (bool)","function getDIDController(string did) public view returns (string)"],r="0x1234...",i=this.getWallet(),s=i?.provider||this.core.provider;if(!s)throw new Error("Provider non disponibile per verificare il DID on-chain");const a=new n.ethers.Contract(r,t,s);if(!await a.isDIDRegistered(e))return{isRegistered:!1};return{isRegistered:!0,controller:await a.getDIDController(e)}}catch(e){return(0,i.logError)("Error verifying DID on blockchain:",e),{isRegistered:!1,error:e instanceof Error?e.message:"Unknown error"}}}clearCache(){this.didCache.clear(),this.emit("cacheCleared")}removeFromCache(e){this.didCache.delete(e),this.emit("didRemovedFromCache",{did:e})}getDocumentFromCache(e){return e.data?e.data:e.document?e.document:null}}t.ShogunDID=o},73490:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(4933),t),i(r(61731),t),i(r(37510),t)},73776:()=>{},74189:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.WalletPlugin=void 0;var s=r(23011);Object.defineProperty(t,"WalletPlugin",{enumerable:!0,get:function(){return s.WalletPlugin}}),i(r(22317),t)},76272:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunCollections=void 0;const n=r(51024);t.GunCollections=class{gun;constructor(e){this.gun=e}async add(e,t){return new Promise(((r,n)=>{try{const i=this.gun.get(e),s=this.generateId();this.gun.get(`${e}_items`).get(s).put(t,(t=>{t.err?n(new Error(t.err)):i.set(this.gun.get(`${e}_items`).get(s),(e=>{e.err?n(new Error(e.err)):r(s)}))}))}catch(e){n(e)}}))}async update(e,t,r){return new Promise(((n,i)=>{try{this.gun.get(`${e}_items`).get(t).put(r,(e=>{e.err?i(new Error(e.err)):n(!0)}))}catch(e){i(e)}}))}async remove(e,t){return new Promise(((r,n)=>{try{this.gun.get(`${e}_items`).get(t).put(null,(e=>{e.err?n(new Error(e.err)):r(!0)}))}catch(e){n(e)}}))}async findAll(e){return new Promise((t=>{this.gun.get(e).once((e=>{if(!e)return void t([]);const r=(0,n.getSet)(e,(0,n.getId)(e));t(r)}))}))}async findById(e,t){return new Promise((r=>{this.gun.get(`${e}_items`).get(t).once((e=>{r(e)}))}))}generateId(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}}},77458:(e,t)=>{"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WebAuthnEventType=void 0,function(e){e.DEVICE_REGISTERED="deviceRegistered",e.DEVICE_REMOVED="deviceRemoved",e.AUTHENTICATION_SUCCESS="authenticationSuccess",e.AUTHENTICATION_FAILED="authenticationFailed",e.ERROR="error"}(r||(t.WebAuthnEventType=r={}))},78431:function(e,t,r){"use strict";var n,i=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),s=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),a=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),a=0;a<r.length;a++)"default"!==r[a]&&i(t,e,r[a]);return s(t,e),t}),o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.GunDB=void 0;const l=o(r(59229));r(38030);const c=o(r(7028)),u=r(45628),g=r(23358),h=r(76272),d=r(29854),p=a(r(64994)),m=r(7668),f=r(63009),w=r(63475);class y{gun;user=null;onAuthCallbacks=[];retryConfig;_authenticating=!1;authToken;_collections;_consensus;_rxjs;constructor(e={}){(0,u.log)("Initializing GunDB"),this.retryConfig={attempts:e.retryAttempts??3,delay:e.retryDelay??1e3};const t={peers:e.peers,localStorage:e.localStorage??!1,radisk:e.radisk??!1,multicast:e.multicast??!1,axe:e.axe??!1};if(this.authToken=e.authToken,this.authToken){const e=`${this.authToken.substring(0,3)}...${this.authToken.slice(-3)}`;(0,u.log)(`Auth token received (${e})`)}else(0,u.log)("No auth token received");this.gun=new l.default(t),this.user=this.gun.user().recall({sessionStorage:!0}),this.authToken&&(l.default.on("opt",(e=>{e.once||e.on("out",(t=>{t.headers={token:this.authToken},e.to.next(t)}))})),(0,u.log)("Auth token handler configured for outgoing messages")),this.subscribeToAuthEvents()}async retry(e,t){let r;for(let n=0;n<this.retryConfig.attempts;n++)try{return await e()}catch(e){if(r=e instanceof Error?e:new Error(String(e)),n<this.retryConfig.attempts-1){const e=this.retryConfig.delay*Math.pow(2,n);(0,u.log)(`Retry attempt ${n+1} for ${t} in ${e}ms`),await new Promise((t=>setTimeout(t,e)))}}throw r}subscribeToAuthEvents(){this.gun.on("auth",(e=>{(0,u.log)("Auth event received:",e),e.err?g.ErrorHandler.handle(g.ErrorType.GUN,"AUTH_EVENT_ERROR",e.err,new Error(e.err)):this.notifyAuthListeners(e.sea?.pub||"")}))}notifyAuthListeners(e){const t=this.gun.user();this.onAuthCallbacks.forEach((e=>e(t)))}static withPeers(e=c.default.PEERS){return new y({peers:e})}addPeer(e){this.gun.opt({peers:[e]}),(0,u.log)(`Added new peer: ${e}`)}onAuth(e){this.onAuthCallbacks.push(e);const t=this.gun.user();return t&&t.is&&e(t),()=>{const t=this.onAuthCallbacks.indexOf(e);-1!==t&&this.onAuthCallbacks.splice(t,1)}}getGun(){return this.gun}getUser(){return this.gun.user()}get(e){return this.gun.get(e)}async put(e,t){return new Promise((r=>{this.gun.get(e).put(t,(e=>{r(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async set(e,t){return new Promise((r=>{this.gun.get(e).set(t,(e=>{r(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async remove(e){return new Promise((t=>{this.gun.get(e).put(null,(e=>{t(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async unset(e,t){return new Promise((t=>{this.gun.get(e).put(null,(e=>{t(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async signUp(e,t){return(0,u.log)("Attempting user registration:",e),new Promise((r=>{const n=setTimeout((()=>{(0,u.logError)(`Timeout durante la registrazione per l'utente: ${e}`),r({success:!1,error:"Registration timeout in GunDB"})}),1e4);(async()=>{try{const i=await new Promise((r=>{(0,u.log)(`Creating user: ${e}`),this.gun.user().create(e,t,(t=>{t.err?((0,u.logError)(`User creation error: ${t.err}`),r({err:t.err})):((0,u.log)(`User created successfully: ${e}`),r({pub:t.pub}))}))}));if(i.err)return clearTimeout(n),r({success:!1,error:i.err});const s=this.gun.get(i.pub).put({username:e});this.gun.get("users").set(s),(0,u.log)(`Attempting login after registration for: ${e}`);try{const i=await this.login(e,t);return clearTimeout(n),i.success?((0,u.log)(`Login after registration successful for: ${e}`),r(i)):((0,u.logError)(`Login after registration failed: ${i.error}`),r({success:!1,error:`Registration completed but login failed: ${i.error}`}))}catch(e){return clearTimeout(n),(0,u.logError)(`Exception during post-registration login: ${e}`),r({success:!1,error:"Exception during post-registration login"})}}catch(e){return clearTimeout(n),(0,u.logError)(`Unexpected error during registration flow: ${e}`),r({success:!1,error:`Unexpected error during registration: ${e}`})}})()}))}async login(e,t,r){if(this.isAuthenticating()){const e="Authentication already in progress";return(0,u.log)(e),{success:!1,error:e}}return this._setAuthenticating(!0),(0,u.log)(`Attempting login for user: ${e}`),new Promise((r=>{this.gun.user()&&(this.gun.user().leave(),(0,u.log)(`Previous session cleaned for: ${e}`));const n=setTimeout((()=>{this._setAuthenticating(!1),(0,u.logError)(`Login timeout for user: ${e}`),r({success:!1,error:"Login timeout"})}),8e3);(0,u.log)(`Starting authentication for: ${e}`),this.gun.user().auth(e,t,(t=>{if(clearTimeout(n),this._setAuthenticating(!1),t.err)(0,u.logError)(`Login error for ${e}: ${t.err}`),r({success:!1,error:t.err});else{const t=this.gun.user().is?.pub,n=this.gun.get("users").map((e=>{if(e.pub===t)return e}));if(!n){const r=this.gun.get(t).put({username:e});this.gun.get("users").set(r)}n?((0,u.log)(`Login successful for: ${e} (${t})`),this._savePair(),r({success:!0,userPub:t,username:e})):((0,u.logError)(`Authentication succeeded but no user.pub available for: ${e}`),r({success:!1,error:"Authentication inconsistency: user.pub not available"}))}}))}))}_savePair(){try{const e=this.gun.user()?._?.sea;e&&"undefined"!=typeof localStorage&&localStorage.setItem("pair",JSON.stringify(e))}catch(e){}}isAuthenticating(){return this._authenticating}_setAuthenticating(e){this._authenticating=e}logout(){try{this.gun.user().leave(),(0,u.log)("Logout completed")}catch(e){(0,u.logError)("Error during logout:",e)}}isLoggedIn(){return!!this.gun.user()?.is?.pub}getCurrentUser(){const e=this.gun.user()?.is?.pub;return e?{pub:e,user:this.gun.user()}:null}async save(e,t){return this.retry((()=>new Promise(((r,n)=>{e.put(t,(e=>e.err?n(new Error(e.err)):r(t)))}))),"data save operation")}async read(e){return this.retry((()=>new Promise((t=>{e.once((e=>t(e)))}))),"data read operation")}async saveUserData(e,t){if(!this.isLoggedIn())throw new Error("User not authenticated");return this.save(this.gun.user().get(e),t)}async getUserData(e){if(!this.isLoggedIn())throw new Error("User not authenticated");return await this.read(this.gun.user().get(e))||null}async savePublicData(e,t,r){return new Promise(((n,i)=>{this.gun.get(e).get(t).put(r,(e=>{e&&e.err?i(new Error(e.err)):n(r)}))}))}async getPublicData(e,t){return new Promise((r=>{this.gun.get(e).get(t).once((e=>r(e||null)))}))}async addToFrozenSpace(e,t,r){return(0,u.log)(`Aggiunta dati in Frozen Space: ${e}/${t}`),new Promise(((n,i)=>{this.gun.get(`${e}:::`).get(t).put(r,(e=>{e&&e.err?((0,u.logError)(`Errore durante l'aggiunta a Frozen Space: ${e.err}`),i(new Error(e.err))):n(r)}))}))}async addHashedToFrozenSpace(e,t){(0,u.log)(`Aggiunta dati con hash in Frozen Space: ${e}`);try{const{hash:r}=await this.hashObj("object"==typeof t?t:{value:t});return await this.addToFrozenSpace(e,r,t),(0,u.log)(`Dati salvati con hash: ${r}`),r}catch(e){throw(0,u.logError)("Errore durante l'aggiunta dati con hash a Frozen Space:",e),e}}async getHashedFrozenData(e,t,r=!1){(0,u.log)(`Recupero dati con hash da Frozen Space: ${e}/${t}`);const n=await this.getFrozenData(e,t);if(r&&n){const{hash:e}=await this.hashObj("object"==typeof n?n:{value:n});if(e!==t)throw(0,u.logError)(`Errore di integrità: l'hash calcolato (${e}) non corrisponde all'hash fornito (${t})`),new Error("Integrità dei dati compromessa");(0,u.log)("Integrità dei dati verificata")}return n}async getFrozenData(e,t){return(0,u.log)(`Recupero dati da Frozen Space: ${e}/${t}`),new Promise((r=>{this.gun.get(`${e}:::`).get(t).once((e=>r(e||null)))}))}async generateKeyPair(){return(0,m.generateKeyPair)()}collections(){return this._collections||(this._collections=new h.GunCollections(this)),this._collections}consensus(e){return this._consensus||(this._consensus=new d.GunConsensus(this,e)),this._consensus}rx(){return this._rxjs||(this._rxjs=new w.GunRxJS(this.gun)),this._rxjs}repository(e,t,r){return new t(this,e,r)}async encrypt(e,t){return(0,m.encrypt)(e,t)}async decrypt(e,t){return(0,m.decrypt)(e,t)}async sign(e,t){return(0,m.sign)(e,t)}async verify(e,t){return(0,m.verify)(e,t)}clearCryptoCache(){(0,m.clearCache)()}isHash(e){return(0,m.isHash)(e)}async encFor(e,t,r){return(0,m.encFor)(e,t,r)}async decFrom(e,t,r){return(0,m.decFrom)(e,t,r)}async hashText(e){return await(0,m.hashText)(e)||""}async hashObj(e){return(0,m.hashObj)(e)}async getShortHash(e,t){return await(0,m.getShortHash)(e,t)||""}safeHash(e){return(0,m.safeHash)(e)}unsafeHash(e){return(0,m.unsafeHash)(e)}safeJSONParse(e,t={}){return(0,m.safeJSONParse)(e,t)}async issueCert(e){return(0,f.issueCert)(e)}async generateCerts(e){return(0,f.generateCerts)(e)}async verifyCert(e,t){return(0,f.verifyCert)(e,t)}async extractCertPolicy(e){return(0,f.extractCertPolicy)(e)}async setPasswordHint(e,t,r,n,i){(0,u.log)("Impostazione suggerimento password per:",e);if(!(await this.login(e,t)).success)return{success:!1,error:"Autenticazione fallita"};try{const e=await this.hashText(i.join("|")),t=await this.encrypt(r,e);return await this.saveUserData("security",{questions:n,hint:t}),{success:!0}}catch(e){return(0,u.logError)("Errore durante l'impostazione del suggerimento password:",e),{success:!1,error:String(e)}}}async forgotPassword(e,t){(0,u.log)("Tentativo di recupero password per:",e);try{const e=this.gun.user().recall({sessionStorage:!0});if(!e||!e.is)return{success:!1,error:"Utente non trovato"};const r=await this.getUserData("security");if(!r||!r.hint)return{success:!1,error:"Nessun suggerimento password trovato"};const n=await this.hashText(t.join("|")),i=await this.decrypt(r.hint,n);return void 0===i?{success:!1,error:"Risposte alle domande di sicurezza errate"}:{success:!0,hint:i}}catch(e){return(0,u.logError)("Errore durante il recupero del suggerimento password:",e),{success:!1,error:String(e)}}}static Errors=p}t.GunDB=y},79838:()=>{},85183:(e,t)=>{"use strict";var r,n;Object.defineProperty(t,"__esModule",{value:!0}),t.MessageSubtype=t.MessageType=void 0,function(e){e.POST="POST",e.PROFILE="PROFILE",e.MODERATION="MODERATION",e.CONNECTION="CONNECTION",e.FILE="FILE"}(r||(t.MessageType=r={})),function(e){e.EMPTY="",e.REPLY="REPLY",e.REPOST="REPOST",e.NICKNAME="NICKNAME",e.BIO="BIO",e.PROFILE_IMAGE="PROFILE_IMAGE",e.CUSTOM="CUSTOM",e.LIKE="LIKE",e.BLOCK="BLOCK",e.FOLLOW="FOLLOW",e.TORRENT="TORRENT",e.IPFS="IPFS"}(n||(t.MessageSubtype=n={}))},91033:(e,t)=>{"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WalletEventType=void 0,function(e){e.WALLET_CREATED="walletCreated",e.WALLET_IMPORTED="walletImported",e.BALANCE_UPDATED="balanceUpdated",e.TRANSACTION_SENT="transactionSent",e.TRANSACTION_CONFIRMED="transactionConfirmed",e.ERROR="error"}(r||(t.WalletEventType=r={}))},92668:()=>{},98285:()=>{}},r={};function n(e){var i=r[e];if(void 0!==i)return i.exports;var s=r[e]={id:e,loaded:!1,exports:{}};return t[e].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.m=t,e=[],n.O=(t,r,i,s)=>{if(!r){var a=1/0;for(u=0;u<e.length;u++){for(var[r,i,s]=e[u],o=!0,l=0;l<r.length;l++)(!1&s||a>=s)&&Object.keys(n.O).every((e=>n.O[e](r[l])))?r.splice(l--,1):(o=!1,s<a&&(a=s));if(o){e.splice(u--,1);var c=i();void 0!==c&&(t=c)}}return t}s=s||0;for(var u=e.length;u>0&&e[u-1][2]>s;u--)e[u]=e[u-1];e[u]=[r,i,s]},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e={792:0};n.O.j=t=>0===e[t];var t=(t,r)=>{var i,s,[a,o,l]=r,c=0;if(a.some((t=>0!==e[t]))){for(i in o)n.o(o,i)&&(n.m[i]=o[i]);if(l)var u=l(n)}for(t&&t(r);c<a.length;c++)s=a[c],n.o(e,s)&&e[s]&&e[s][0](),e[s]=0;return n.O(u)},r=this.webpackChunkShogunCore=this.webpackChunkShogunCore||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var i=n.O(void 0,[96],(()=>n(29148)));return i=(i=n.O(i)).default})()));