!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ShogunCore=t():e.ShogunCore=t()}(this,(()=>(()=>{var e,t={74:(e,t)=>{"use strict";var r,n;Object.defineProperty(t,"__esModule",{value:!0}),t.CorePlugins=t.PluginCategory=void 0,function(e){e.Authentication="authentication",e.Wallet="wallet",e.Privacy="privacy",e.Identity="identity",e.Utility="utility"}(r||(t.PluginCategory=r={})),function(e){e.WebAuthn="webauthn",e.MetaMask="metamask",e.Stealth="stealth",e.WalletManager="wallet",e.BitcoinWallet="bitcoin-wallet"}(n||(t.CorePlugins=n={}))},170:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getArrayFromIndexedObject=t.getIndexedObjectFromArray=t.qs=t.getSet=t.getUUID=t.getTargetPub=t.getPub=t.getId=void 0,t.app_scoped=function(e,t){return t.length>0?`${t}-${e}`:e};t.getId=e=>e?._?.["#"];t.getPub=e=>{const t=/~([^@][^\.]+\.[^\.]+)/.exec(e);return t?t[1]:null};t.getTargetPub=e=>{const t=/~[^@][^\.]+\.[^\.]+.*~([^@][^\.]+\.[^\.]+)$/.exec(e);return t?t[1]:null};t.getUUID=e=>e.opt()._.opt.uuid();t.getSet=(e,t)=>{const r=e[t];return r?Object.keys(r).filter((e=>"_"!==e)).map((e=>r[e])).filter((e=>e&&"object"==typeof e&&e["#"])).map((t=>e[t["#"]])).filter(Boolean):[]};t.qs=(e,t="?")=>{const r=Object.fromEntries(Object.entries(e).filter((([e,t])=>t))),n=JSON.stringify(r);return n?`${t}${n}`:""};t.getIndexedObjectFromArray=e=>e.reduce(((e,t)=>({...e,[t.id]:t})),{});t.getArrayFromIndexedObject=e=>Object.values(e)},277:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),a(r(8991),t),a(r(3408),t),a(r(7160),t)},348:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthAddresses=t.Stealth=void 0;const a=r(4193),i=r(4643),s=n(r(8030));class o{STEALTH_DATA_TABLE;storage;gun;logs=[];constructor(e,t){this.STEALTH_DATA_TABLE="Stealth",this.storage=t||new i.ShogunStorage,this.gun=e}log(e,t,r){const n={timestamp:(new Date).toISOString(),level:e,message:t,data:r};this.logs.push(n)}async cleanupSensitiveData(){try{this.logs=[],this.log("info","Sensitive data cleanup completed")}catch(e){throw this.log("error","Error during cleanup",e),e}}async getStealthKeys(){const e=await this.assertStealth().getStealthKeys();return{spendingKey:e.spendingKey,viewingKey:e.viewingKey}}async generateAndSaveKeys(e){const t=this.gun.user().get("stealth").get("viewingKey").once(),r=this.gun.user().get("stealth").get("spendingKey").once();if(t||r)return;const n=await this.createAccount(),a=await this.createAccount();let i;i=e?await this.gun.user().auth(e):this.gun.user();const o=await s.default.encrypt(a,i()._.sea),l=await s.default.encrypt(n,i()._.sea);this.gun.user().get("stealth").get("viewingKey").put(o),this.gun.user().get("stealth").get("spendingKey").put(l),this.log("info","Stealth keys generated and saved for address",e?.pub||i?.is?.alias)}formatPublicKey(e){if(!e)return null;const t=e.trim();return t&&/^[~]?[\w+/=\-_.]+$/.test(t)?t.startsWith("~")?t.slice(1):t:null}async createAccount(){const e=await this.assertStealth().createAccount();return{privateKey:e.privateKey,publicKey:e.publicKey}}async generateStealthAddress(e,t){return this.assertStealth().generateStealthAddress(e,t)}async openStealthAddress(e,t,r,n,a){return this.assertStealth().openStealthAddress(e,t,r,n,a)}async getPublicKey(e){return this.formatPublicKey(e)}deriveWalletFromSecret(e){const t=a.ethers.keccak256(a.ethers.toUtf8Bytes(e));return new a.ethers.Wallet(t)}generateStealthKeys(){return{scanning:this.createAccount(),spending:this.createAccount()}}verifyStealthAddress(e,t,r,n){return!0}assertStealth(){if(!this.gun.user())throw new Error("Stealth not initialized");return this}}t.Stealth=o,t.StealthAddresses=o,"undefined"!=typeof window?window.Stealth=o:void 0!==r.g&&(r.g.Stealth=o),t.default=o},409:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Webauthn:()=>n,default:()=>a});class n{constructor(){}isSupported(){return!1}validateUsername(){throw new Error("WebAuthn functionality disabled in light version")}async createAccount(){throw new Error("WebAuthn functionality disabled in light version")}async authenticateUser(){throw new Error("WebAuthn functionality disabled in light version")}async sign(){throw new Error("WebAuthn functionality disabled in light version")}}const a=n},554:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isHash=function(e){return"string"==typeof e&&44===e.length&&"="===e.charAt(43)},t.encrypt=async function(e,t){if(!Gun.SEA)throw new Error("SEA is not available");return Gun.SEA.encrypt(e,t)},t.decrypt=async function(e,t){if(!Gun.SEA)throw new Error("SEA is not available");return Gun.SEA.decrypt(e,t)},t.encFor=async function(e,t,r){const a=await n.SEA.secret(r.epub,t),i=await n.SEA.encrypt(e,a);return i},t.decFrom=async function(e,t,r){const a=await n.SEA.secret(t.epub,r),i=await n.SEA.decrypt(e,a);return i},t.hashText=a,t.hashObj=async function(e){let t="string"==typeof e?e:JSON.stringify(e);return{hash:await a(t),hashed:t}},t.secret=async function(e,t){const r=await n.SEA.secret(e,t);return r},t.getShortHash=async function(e,t){return await n.SEA.work(e,null,null,{name:"PBKDF2",encode:"hex",salt:t})},t.safeHash=function(e){if(!e)return;return e.replace(/[+=/]/g,i)},t.unsafeHash=function(e){if(!e)return;return e.replace(/[._-]/g,s)},t.safeJSONParse=function(e,t={}){if(!e)return t;if("object"==typeof e)return e;try{return JSON.parse(e)}catch(e){return t}},t.randomUUID=function(){throw new Error("Function not implemented.")};const n=r(9229);async function a(e){return await n.SEA.work(e,null,null,{name:"SHA-256"})}function i(e){switch(e){case"+":return"-";case"=":return".";case"/":return"_"}}function s(e){switch(e){case"-":return"+";case".":return"=";case"_":return"/"}}},749:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BitcoinWallet=void 0;const n=r(5628),a=r(3358),i=r(4134);class s extends i.EventEmitter{MESSAGE_TO_SIGN="I Love Shogun!";DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4,network:"mainnet",useApi:!1};config;signatureCache=new Map;connectedAddress=null;connectedType=null;manualKeyPair=null;constructor(e={}){super(),this.config={...this.DEFAULT_CONFIG,...e},this.setupEventListeners()}setupEventListeners(){}cleanup(){this.removeAllListeners(),this.connectedAddress=null,this.connectedType=null,this.manualKeyPair=null}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim();if("nostr"===this.connectedType){if(!/^(npub1|[0-9a-f]{64})/.test(t))throw new Error("Invalid Nostr public key format")}else if(!/^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,59}$/.test(t))throw new Error("Invalid Bitcoin address format");return t}catch(e){throw a.ErrorHandler.handle(a.ErrorType.VALIDATION,"INVALID_ADDRESS","Invalid Bitcoin address provided",e),e}}isAlbyAvailable(){return(0,n.logWarn)("Alby support is deprecated, use Nostr instead"),!1}isNostrExtensionAvailable(){return"undefined"!=typeof window&&!!window.nostr}isAvailable(){return this.isNostrExtensionAvailable()||null!==this.manualKeyPair}async connectWallet(e="nostr"){try{switch((0,n.logDebug)(`Attempting to connect to ${e} wallet...`),"alby"===e&&((0,n.logWarn)("Alby support is deprecated, using Nostr instead"),e="nostr"),e){case"nostr":return await this.connectNostr();case"manual":return await this.connectManual();default:throw new Error(`Unsupported wallet type: ${e}`)}}catch(t){return(0,n.logError)(`Failed to connect to ${e} wallet:`,t),a.ErrorHandler.handle(a.ErrorType.NETWORK,"BITCOIN_WALLET_CONNECTION_ERROR",t.message??`Unknown error while connecting to ${e} wallet`,t),{success:!1,error:t.message??`Failed to connect to ${e} wallet`}}}async connectAlby(){return(0,n.logWarn)("Alby support is deprecated, redirecting to Nostr"),this.connectNostr()}async connectNostr(){if(!this.isNostrExtensionAvailable())return{success:!1,error:"Nostr extension is not available. Please install a Nostr compatible extension."};try{const e=await window.nostr.getPublicKey();if(!e)throw new Error("Could not get public key from Nostr extension");this.connectedAddress=e,this.connectedType="nostr",this.emit("connected",{address:e,type:"nostr"});const t=`nostr_${e.substring(0,10)}`;return{success:!0,address:e,username:t,extensionType:"nostr"}}catch(e){throw new Error(`Nostr connection error: ${e.message}`)}}async connectManual(){if(!this.manualKeyPair)return{success:!1,error:"No manual key pair configured. Use setKeyPair() first."};this.connectedAddress=this.manualKeyPair.address,this.connectedType="manual",this.emit("connected",{address:this.manualKeyPair.address,type:"manual"});const e=`btc_${this.manualKeyPair.address.substring(0,10)}`;return{success:!0,address:this.manualKeyPair.address,username:e,extensionType:"manual"}}setKeyPair(e){this.manualKeyPair=e,e.address&&(this.connectedAddress=e.address,this.connectedType="manual")}async generateCredentials(e){(0,n.logDebug)(`Generating credentials for address: ${e}`);try{const t=this.validateAddress(e),r=this.getCachedSignature(t);if(r)return(0,n.logDebug)("Using cached signature"),await this.generateCredentialsFromSignature(t,r);const a=this.MESSAGE_TO_SIGN;let i;try{i=await this.requestSignatureWithTimeout(t,a,this.config.timeout)}catch(e){if((0,n.logError)("Error requesting signature:",e),"manual"===this.connectedType&&this.manualKeyPair)return await this.generateFallbackCredentials(t);throw e}return this.cacheSignature(t,i),await this.generateCredentialsFromSignature(t,i)}catch(e){throw(0,n.logError)("Error generating credentials:",e),e}}async generateCredentialsFromSignature(e,t){return{username:`btc_${e.toLowerCase().replace(/[^a-z0-9]/g,"")}`,password:await this.generatePassword(t),message:this.MESSAGE_TO_SIGN,signature:t}}async generateFallbackCredentials(e){if("manual"!==this.connectedType||!this.manualKeyPair)throw new Error("Fallback credentials only available for manual connections");const t=`btc_${e.toLowerCase().replace(/[^a-z0-9]/g,"")}`,r=await this.generatePassword(this.manualKeyPair.privateKey),n=`manual_${this.manualKeyPair.privateKey.slice(-16)}`;return{username:t,password:r,message:this.MESSAGE_TO_SIGN,signature:n}}requestSignatureWithTimeout(e,t,r=3e4){return new Promise(((n,a)=>{const i=setTimeout((()=>{a(new Error("Signature request timed out"))}),r);this.requestSignature(e,t).then((e=>{clearTimeout(i),n(e)})).catch((e=>{clearTimeout(i),a(e)}))}))}async requestSignature(e,t){if(!this.connectedType)throw new Error("No wallet connected");try{switch(this.connectedType){case"alby":if((0,n.logWarn)("Alby is deprecated, redirecting signature request to Nostr"),!window.nostr)throw new Error("Nostr extension not available");const r={kind:1,created_at:Math.floor(Date.now()/1e3),tags:[],content:t,pubkey:e};return(await window.nostr.signEvent(r)).sig;case"nostr":const a={kind:1,created_at:Math.floor(Date.now()/1e3),tags:[],content:t,pubkey:e};return(await window.nostr.signEvent(a)).sig;case"manual":if(!this.manualKeyPair)throw new Error("No manual key pair available");return`manual_signature_${Date.now()}`;default:throw new Error(`Unsupported wallet type: ${this.connectedType}`)}}catch(e){throw(0,n.logError)("Error requesting signature:",e),new Error(`Failed to get signature: ${e.message}`)}}async generatePassword(e){let t=0;for(let r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t&=t}return`btc_${Math.abs(t).toString(36)}`}async verifySignature(e,t,r){try{if("nostr"===this.connectedType)return r===this.connectedAddress;if("alby"===this.connectedType)return(0,n.logWarn)("Alby is deprecated, using Nostr verification logic"),r===this.connectedAddress;if("manual"===this.connectedType&&this.manualKeyPair)return r===this.manualKeyPair.address;if(this.config.useApi&&this.config.apiUrl)try{return!0}catch(e){return(0,n.logError)("API verification failed:",e),!1}return(0,n.logWarn)("Falling back to trust-based verification"),!0}catch(e){return(0,n.logError)("Error verifying signature:",e),!1}}getConnectedAddress(){return this.connectedAddress}getConnectedType(){return this.connectedType}}t.BitcoinWallet=s},1731:(e,t)=>{"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WebAuthnEventType=void 0,function(e){e.DEVICE_REGISTERED="deviceRegistered",e.DEVICE_REMOVED="deviceRemoved",e.AUTHENTICATION_SUCCESS="authenticationSuccess",e.AUTHENTICATION_FAILED="authenticationFailed",e.ERROR="error"}(r||(t.WebAuthnEventType=r={}))},1772:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.events=t.states=t.StateMachineEvent=void 0,t.use_machine=function(e,t){let r=t,n=new Map;return{subscribe:function(e){const t=crypto.randomUUID();return n.set(t,e),e(r),()=>{n.delete(t)}},set:function(t){r=e(r,t);for(const e of n.values())e(r)}}},t.auth_state_machine=function(e,n){const a=new r("Not a valid state transition",e,n.type);switch(e){case t.states.disconnected:if(n.type===t.events.create)return t.states.creating;if(n.type===t.events.authenticate)return t.states.pending;throw a;case t.states.creating:if(n.type===t.events.fail)return t.states.disconnected;if(n.type===t.events.success)return t.states.disconnected;throw a;case t.states.pending:if(n.type===t.events.fail)return t.states.disconnected;if(n.type===t.events.success)return t.states.authorized;throw a;case t.states.authorized:if(n.type===t.events.disconnect)return t.states.leaving;throw a;case t.states.leaving:if(n.type===t.events.fail)return t.states.authorized;if(n.type===t.events.success)return t.states.disconnected;throw a;default:throw a}};t.StateMachineEvent=class{type;data;constructor(e,t={}){this.type=e,this.data=t}},t.states={disconnected:"disconnected",creating:"creating",pending:"pending",authorized:"authorized",leaving:"leaving"},t.events={create:"create",authenticate:"authenticate",disconnect:"disconnect",fail:"fail",success:"success"};class r extends Error{state;event;constructor(e,t,r){super(e),this.state=t,this.event=r}}},2077:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunRxJS=void 0;const n=r(9364),a=r(2794);t.GunRxJS=class{gun;user;constructor(e){this.gun=e,this.user=e.user().recall({sessionStorage:!0})}getUser(){return this.user}getUserPub(){return this.user.is?.pub}observe(e){return new n.Observable((t=>{const r="string"==typeof e?this.gun.get(e):e,n=r.on(((e,r)=>{if(null!=e)if("object"==typeof e&&null!==e){const r=this.removeGunMeta(e);t.next(r)}else t.next(e);else t.next(null)}));return()=>{n&&"function"==typeof n&&n(),r.off()}})).pipe((0,a.distinctUntilChanged)(((e,t)=>JSON.stringify(e)===JSON.stringify(t))))}match(e,t){return new n.Observable((r=>{const n="string"==typeof e?this.gun.get(e):e,a={},i=n.map().on(((e,n)=>{if("_"===n||!e)return;if(t&&!t(e))return void(a[n]&&(delete a[n],r.next(Object.values(a))));const i="object"==typeof e?this.removeGunMeta(e):e;a[n]=i,r.next(Object.values(a))}));return()=>{i&&"function"==typeof i&&i(),n.off()}}))}put(e,t){const r="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{r.put(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}set(e,t){const r="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{r.set(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}once(e){const t="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{t.once((t=>{if(null==t)return e.next(null),void e.complete();const r="object"==typeof t?this.removeGunMeta(t):t;e.next(r),e.complete()}))}))}compute(e,t){const r=e.map((e=>"string"==typeof e?this.observe(e):e));return new n.Observable((n=>{let a=new Array(e.length).fill(void 0),i=new Array(e.length).fill(!1);const s=r.map(((e,r)=>e.subscribe({next:e=>{if(a[r]=e,a.every((e=>void 0!==e)))try{const e=t(...a);n.next(e)}catch(e){n.error(e)}},error:e=>n.error(e),complete:()=>{i[r]=!0,i.every((e=>e))&&n.complete()}})));return()=>{s.forEach((e=>e.unsubscribe()))}}))}userPut(e,t){return new n.Observable((r=>{this.gun.user().get(e).put(t,(e=>{e.err?r.error(new Error(e.err)):(r.next(t),r.complete())}))}))}userGet(e){return this.observe(this.gun.user().get(e))}observeUser(e){return this.observe(this.gun.user().get(e))}removeGunMeta(e){if(!e||"object"!=typeof e)return e;const t=Array.isArray(e)?[]:{};return Object.keys(e).forEach((r=>{if("_"===r||"#"===r)return;const n=e[r];t[r]=n&&"object"==typeof n?this.removeGunMeta(n):n})),t}}},2115:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=void 0;const n=r(4586),a=r(348),i=r(5628);class s extends n.BasePlugin{name="stealth";version="1.0.0";description="Provides stealth address functionality for ShogunCore";stealth=null;initialize(e){if(super.initialize(e),!e.storage)throw new Error("Storage dependency not available in core");if(!e.gun)throw new Error("Gun dependency not available in core");this.stealth=new a.Stealth(e.gun,e.storage),(0,i.log)("Stealth plugin initialized")}destroy(){this.stealth=null,super.destroy(),(0,i.log)("Stealth plugin destroyed")}assertStealth(){if(this.assertInitialized(),!this.stealth)throw new Error("Stealth module not initialized");return this.stealth}async generateEphemeralKeyPair(){return this.assertStealth().createAccount()}async generateStealthAddress(e,t){return this.assertStealth().generateStealthAddress(e,t)}async scanStealthAddresses(e,t){return Promise.resolve([])}async isStealthAddressMine(e,t){return Promise.resolve(!1)}async getStealthPrivateKey(e,t){return Promise.resolve("0x"+"0".repeat(64))}async openStealthAddress(e,t,r){const n=await this.getStealthKeys(),a={pub:n.viewingKey,priv:n.viewingKey,epub:n.viewingKey,epriv:n.viewingKey},i={pub:n.spendingKey,priv:n.spendingKey,epub:n.spendingKey,epriv:n.spendingKey};return this.assertStealth().openStealthAddress(e,t,r,i,a)}async getStealthKeys(){return this.assertStealth().getStealthKeys()}}t.StealthPlugin=s},2256:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Stealth:()=>n,default:()=>a});class n{constructor(){}formatPublicKey(){throw new Error("Stealth functionality disabled in light version")}async createAccount(){throw new Error("Stealth functionality disabled in light version")}async generateStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async openStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async getPublicKey(){throw new Error("Stealth functionality disabled in light version")}prepareStealthKeysForSaving(){throw new Error("Stealth functionality disabled in light version")}deriveWalletFromSecret(){throw new Error("Stealth functionality disabled in light version")}}const a=n},2317:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.WalletManager=void 0;const a=r(5628),i=n(r(8030)),s=r(4193),o=r(4134),l=r(3512);class c extends o.EventEmitter{gun;storage;walletPaths={};mainWallet=null;balanceCache=new Map;pendingTransactions=new Map;config;transactionMonitoringInterval=null;provider=null;signer=null;constructor(e,t,r){super(),this.gun=e,this.storage=t,this.config={balanceCacheTTL:3e4,rpcUrl:"",defaultGasLimit:21e3,maxRetries:3,retryDelay:1e3,...r},this.initWalletPathsSync(),this.setupTransactionMonitoring()}initWalletPathsSync(){try{this.walletPaths={},this.loadWalletPathsFromLocalStorage(),(0,a.log)("Wallet paths initialized synchronously. Async loading will occur on first use.")}catch(e){(0,a.logError)("Error in synchronous wallet path initialization:",e),(0,a.log)("Will attempt async initialization on first use")}}async initializeWalletPaths(){try{this.walletPaths={},await this.loadWalletPathsFromGun(),this.loadWalletPathsFromLocalStorage();const e=Object.keys(this.walletPaths).length;0===e?(0,a.log)("No wallet paths found, new wallets will be created when needed"):(0,a.log)(`Initialized ${e} wallet paths`)}catch(e){throw(0,a.logError)("Error initializing wallet paths:",e),new Error(`Failed to initialize wallet paths: ${e instanceof Error?e.message:String(e)}`)}}loadWalletPathsFromLocalStorage(){const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=this.storage.getItem(e);if(t)try{(0,a.log)("Found wallet paths in localStorage");const e=JSON.parse(t);Object.entries(e).forEach((([e,t])=>{this.walletPaths[e]||(this.walletPaths[e]=t,(0,a.log)(`Loaded path from localStorage for wallet: ${e}`))}))}catch(e){(0,a.logError)("Error parsing wallet paths from localStorage:",e)}}async loadWalletPathsFromGun(){const e=this.gun.user();return e?.is?((0,a.log)(`Loading wallet paths from GUN for user: ${e.is.alias}`),new Promise((t=>{e.get("wallet_paths").once((e=>{if(!e)return(0,a.log)("No wallet paths found in GUN"),void t();(0,a.log)(`Found wallet paths in GUN: ${Object.keys(e).length-1} wallets`),Object.entries(e).forEach((([e,t])=>{if("_"!==e&&t){const r=t;r?.path&&(this.walletPaths[e]={path:r.path,created:r.created||Date.now()},(0,a.log)(`Loaded path for wallet: ${e} -> ${r.path}`))}})),t()}))}))):((0,a.log)("User not authenticated on Gun, cannot load wallet paths from Gun"),Promise.resolve())}setupTransactionMonitoring(){this.transactionMonitoringInterval=setInterval((()=>{null!==this.getProvider()&&this.checkPendingTransactions()}),15e3)}cleanup(){this.transactionMonitoringInterval&&(clearInterval(this.transactionMonitoringInterval),this.transactionMonitoringInterval=null);"undefined"!=typeof window?window:r.g;const e=Number(setTimeout((()=>{}),0));for(let t=0;t<e;t++)clearTimeout(t),clearInterval(t)}async checkPendingTransactions(){const e=this.getProvider();if(e)for(const[t,r]of this.pendingTransactions.entries())try{const n=await e.getTransactionReceipt(t);n&&(1===n.status?(r&&"object"==typeof r&&(r.status="success"),this.emit(l.WalletEventType.TRANSACTION_CONFIRMED,{type:l.WalletEventType.TRANSACTION_CONFIRMED,data:{txHash:t,receipt:n},timestamp:Date.now()})):(r&&"object"==typeof r&&(r.status="failed"),this.emit(l.WalletEventType.ERROR,{type:l.WalletEventType.ERROR,data:{txHash:t,error:"Transaction failed"},timestamp:Date.now()})),this.pendingTransactions.delete(t),this.invalidateBalanceCache(r.from),r.to&&this.invalidateBalanceCache(r.to))}catch(e){(0,a.logError)(`Error checking transaction ${t}:`,e)}else(0,a.logWarn)("Provider non disponibile, impossibile controllare transazioni pendenti")}setRpcUrl(e){this.config.rpcUrl=e,(0,a.log)(`RPC Provider configured: ${e}`),this.provider||(this.provider=new s.ethers.JsonRpcProvider(e)),this.signer=this.getSigner()}getProvider(){return this.provider}getSigner(){const e=this.getMainWallet();if(!this.provider)throw new Error("Provider not available");return e.connect(this.provider)}setSigner(e){if(!this.config.rpcUrl)throw new Error("RPC URL not configured");const t=new s.ethers.JsonRpcProvider(this.config.rpcUrl);this.signer=e.connect(t)}getStorageUserIdentifier(){const e=this.gun.user(),t=e?.is?.pub;return t?t.substring(0,12):"guest"}saveWalletPathsToLocalStorage(){try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=JSON.stringify(this.walletPaths);this.storage.setItem(e,t),(0,a.log)(`Saved ${Object.keys(this.walletPaths).length} wallet paths to localStorage`)}catch(e){(0,a.logError)("Error saving wallet paths to localStorage:",e)}}derivePrivateKeyFromMnemonic(e,t){try{(0,a.log)(`Deriving wallet from path: ${t}`);const r=s.ethers.HDNodeWallet.fromMnemonic(s.ethers.Mnemonic.fromPhrase(e),t);if(!r||!r.privateKey)throw new Error(`Unable to derive wallet for path ${t}`);return r}catch(e){throw(0,a.logError)(`Error deriving wallet for path ${t}:`,e),new Error(`Unable to derive wallet for path ${t}`)}}generateNewMnemonic(){try{0;const e=s.ethers.Wallet.createRandom();if(e.mnemonic&&e.mnemonic.phrase)return e.mnemonic.phrase;throw new Error("Mnemonic non generato correttamente")}catch(e){return(0,a.logError)("Errore durante la generazione del mnemonic:",e),"casa gatto cane topo elefante leone tigre orso scimmia panda zebra giraffa"}}getStandardBIP44Addresses(e,t=5){try{(0,a.log)("Standard BIP-44 derivation from mnemonic");const r=[];for(let n=0;n<t;n++){const t=`m/44'/60'/0'/0/${n}`,i=s.ethers.HDNodeWallet.fromMnemonic(s.ethers.Mnemonic.fromPhrase(e),t);r.push(i.address),(0,a.log)(`Address ${n}: ${i.address} (${t})`)}return r}catch(e){return(0,a.log)(`Error calculating BIP-44 addresses: ${e}`),[]}}generatePrivateKeyFromString(e){try{const t=(new TextEncoder).encode(e),r=e=>{let t=3735928559,r=1103547991;for(let n=0;n<e.length;n++)t=Math.imul(t^e[n],2654435761),r=Math.imul(r^e[n],1597334677);t=Math.imul(t^t>>>16,2246822507),t=Math.imul(t^t>>>13,3266489909),r=Math.imul(r^r>>>16,2246822507),r=Math.imul(r^r>>>13,3266489909);const n=new Uint8Array(32);for(let e=0;e<4;e++)n[e]=t>>8*e&255;for(let e=0;e<4;e++)n[e+4]=r>>8*e&255;for(let e=8;e<32;e++)n[e]=255&(n[e%8]^n[(e-1)%8]);return n},n=r(t);return"0x"+Array.from(n).map((e=>e.toString(16).padStart(2,"0"))).join("")}catch(e){(0,a.logError)("Error generating private key:",e);return"0x"+Array.from({length:32}).map((()=>Math.floor(256*Math.random()).toString(16).padStart(2,"0"))).join("")}}getMainWallet(){try{if(!this.mainWallet){const e=this.gun.user();if(!e||!e.is)throw(0,a.log)("getMainWallet: User not authenticated"),new Error("User not authenticated");if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub))throw(0,a.log)("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),new Error("Insufficient user data to generate wallet");const t=e._.sea.priv,r=e._.sea.pub,n=`${t}|${r}|${e.is.alias}`,i=this.generatePrivateKeyFromString(n);this.mainWallet=new s.ethers.Wallet(i)}return this.mainWallet}catch(e){throw(0,a.logError)("Error retrieving main wallet:",e),e}}getMainWalletCredentials(){const e=this.gun.user().recall({sessionStorage:!0});if(!e||!e.is)throw(0,a.log)("getMainWallet: User not authenticated"),new Error("User not authenticated");if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub))throw(0,a.log)("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),new Error("Insufficient user data to generate wallet");const t=`${e._.sea.priv}|${e._.sea.pub}|${e.is.alias}`,r=this.generatePrivateKeyFromString(t);return this.mainWallet=new s.ethers.Wallet(r),{address:this.mainWallet.address,priv:r}}async encryptSensitiveData(e){try{const t=this.gun.user();if(t&&t._&&t._.sea){const r=await i.default.encrypt(e,t._.sea);return JSON.stringify(r)}{const t=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`,r=await i.default.encrypt(e,t);return JSON.stringify(r)}}catch(t){return(0,a.logError)("Error encrypting data:",t),(0,a.log)("WARNING: Sensitive data saved without encryption"),`unencrypted:${e}`}}async decryptSensitiveData(e){try{if(e.startsWith("unencrypted:"))return e.substring(12);const t=JSON.parse(e),r=this.gun.user();if(r&&r._&&r._.sea){return await i.default.decrypt(t,r._.sea)}{const e=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`;return await i.default.decrypt(t,e)}}catch(e){return(0,a.logError)("Error decrypting data:",e),null}}async getUserMasterMnemonic(){try{const e=this.gun.user();if(e&&e.is){const t=await new Promise((t=>{e.get("master_mnemonic").once((e=>{t(e||null)}))}));if(t){(0,a.log)("Mnemonic retrieved from GunDB"),(0,a.log)("gunMnemonic: ",t);return await this.decryptSensitiveData(t)}}const t=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,r=this.storage.getItem(t);if(!r)return(0,a.log)("No mnemonic found in either GunDB or localStorage"),null;const n=await this.decryptSensitiveData(r);return(0,a.log)("Mnemonic retrieved from localStorage"),n&&e&&e.is&&(await e.get("master_mnemonic").put(n),(0,a.log)("Mnemonic from localStorage synced to GunDB")),n}catch(e){return(0,a.logError)("Error retrieving mnemonic:",e),null}}async saveUserMasterMnemonic(e){try{const t=this.gun.user();if(t&&t.is){0;const r=await this.encryptSensitiveData(e);await t.get("master_mnemonic").put(r),(0,a.log)("Mnemonic saved to GunDB")}const r=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,n=await this.encryptSensitiveData(e);this.storage.setItem(r,n),(0,a.log)("Encrypted mnemonic also saved to localStorage as backup")}catch(e){throw(0,a.logError)("Error saving mnemonic:",e),e}}async createWallet(){try{const e=this.gun.user();if(!e.is)throw new Error("User is not authenticated");const t=Object.values(this.walletPaths).length,r=`m/44'/60'/0'/0/${t}`;let n,i=await this.getUserMasterMnemonic();if(!i)try{i=this.generateNewMnemonic(),await this.saveUserMasterMnemonic(i),(0,a.log)(`Generated new mnemonic: ${i}`)}catch(e){throw new Error(`Failed to generate or save mnemonic: ${e instanceof Error?e.message:String(e)}`)}(0,a.log)("*** masterMnemonic: ",i);try{n=this.derivePrivateKeyFromMnemonic(i,r),(0,a.log)(`Derived wallet for path ${r} with address ${n.address}`)}catch(e){throw new Error(`Failed to derive wallet: ${e instanceof Error?e.message:String(e)}`)}const s=Date.now();this.walletPaths[n.address]={path:r,created:s};try{const t=e.get("wallet_paths");await t.put({[n.address]:{path:r,created:s}}),this.saveWalletPathsToLocalStorage()}catch(e){(0,a.logError)("Error saving wallet path:",e),(0,a.log)("Wallet created but path might not be persisted properly")}return{wallet:n,path:r,address:n.address,getAddressString:()=>n.address}}catch(e){throw(0,a.logError)("Error creating wallet:",e),new Error(`Failed to create wallet: ${e instanceof Error?e.message:String(e)}`)}}async loadWallets(){try{if(!this.gun.user())throw(0,a.logError)("loadWallets: No Gun user available"),new Error("Gun user not available");try{await this.initializeWalletPaths()}catch(e){(0,a.logError)("Error initializing wallet paths, proceeding with available wallets:",e),(0,a.log)("Will attempt to continue with any available wallet data")}let e=await this.getUserMasterMnemonic();if(!e){(0,a.log)("No mnemonic found, creating default wallet...");return[await this.createWallet()]}(0,a.log)(`masterMnemonic found: ${e}`);const t=[];for(const[r,n]of Object.entries(this.walletPaths))try{const i=this.derivePrivateKeyFromMnemonic(e,n.path||`m/44'/60'/0'/0/${r.substring(0,6)}`);(0,a.log)(`Derived wallet for path ${n.path||"fallback"} with address ${i.address}`),i.address.toLowerCase()!==r.toLowerCase()&&(0,a.logWarn)(`Warning: derived address (${i.address}) does not match saved address (${r})`),t.push({wallet:i,path:n.path||`m/44'/60'/0'/0/${i.address.substring(0,8)}`,address:i.address,getAddressString:()=>i.address})}catch(e){(0,a.logError)(`Error deriving wallet ${r}:`,e)}return t.length>0&&(this.mainWallet=t[0].wallet),t}catch(e){throw(0,a.logError)("Error loading wallets:",e),new Error(`Failed to load wallets: ${e instanceof Error?e.message:String(e)}`)}}async getBalance(e){try{const t=e.address,r=Date.now(),n=this.balanceCache.get(t);if(n&&r-n.timestamp<this.config.balanceCacheTTL)return n.balance;const a=this.getProvider();if(!a)throw new Error("Provider non disponibile. Imposta prima un RPC URL con setRpcUrl()");const i=await a.getBalance(t),o=s.ethers.formatEther(i);return this.balanceCache.set(t,{balance:o,timestamp:r}),this.emit(l.WalletEventType.BALANCE_UPDATED,{type:l.WalletEventType.BALANCE_UPDATED,data:{address:t,balance:o},timestamp:r}),o}catch(e){return(0,a.logError)("Error getting balance:",e),"0.0"}}invalidateBalanceCache(e){this.balanceCache.delete(e),(0,a.log)(`Balance cache invalidated for ${e}`)}async getNonce(e){const t=this.getProvider();if(!t)throw new Error("Provider non inizializzato. Chiamare setRpcUrl prima");return await t.getTransactionCount(e.address)}async sendTransaction(e,t,r,n={}){try{const a=this.getProvider();if(!a)throw new Error("Provider not available");e=e.connect(a);const i=await a.getFeeData(),o={to:t,value:s.ethers.parseEther(r),gasLimit:n.gasLimit||this.config.defaultGasLimit,nonce:n.nonce||await a.getTransactionCount(e.address),maxFeePerGas:n.maxFeePerGas?s.ethers.parseUnits(n.maxFeePerGas,"gwei"):i.maxFeePerGas,maxPriorityFeePerGas:n.maxPriorityFeePerGas?s.ethers.parseUnits(n.maxPriorityFeePerGas,"gwei"):i.maxPriorityFeePerGas};for(let t=1;t<=(this.config.maxRetries||3);t++)try{const t=await e.sendTransaction(o);return this.pendingTransactions.set(t.hash,t),this.emit(l.WalletEventType.TRANSACTION_SENT,{type:l.WalletEventType.TRANSACTION_SENT,data:{txHash:t.hash,tx:o},timestamp:Date.now()}),t.hash}catch(r){if(t===this.config.maxRetries)throw r;await new Promise((e=>setTimeout(e,this.config.retryDelay))),o.nonce=await a.getTransactionCount(e.address);const n=await a.getFeeData();o.maxFeePerGas=n.maxFeePerGas,o.maxPriorityFeePerGas=n.maxPriorityFeePerGas}throw new Error("Transaction failed after all retry attempts")}catch(t){throw(0,a.logError)("Error sending transaction:",t),this.emit(l.WalletEventType.ERROR,{type:l.WalletEventType.ERROR,data:{error:t,wallet:e.address},timestamp:Date.now()}),t}}async signMessage(e,t){try{return await e.signMessage(t)}catch(e){throw(0,a.logError)("Error signing message:",e),e}}verifySignature(e,t){return s.ethers.verifyMessage(e,t)}async signTransaction(e,t,r,n){try{(0,a.log)(`Signing transaction from wallet ${e.address} to ${t} for ${r} ETH`);const i=n||this.getProvider();if(!i)throw new Error("Provider not available");const o=await i.getTransactionCount(e.address);(0,a.log)(`Nonce for transaction: ${o}`);const l=await i.getFeeData(),c={nonce:o,to:t,value:s.ethers.parseEther(r),gasPrice:l.gasPrice,gasLimit:21e3},u=await e.signTransaction(c);return(0,a.log)("Transaction signed successfully"),u}catch(e){throw(0,a.logError)("Error signing transaction:",e),e}}resetMainWallet(){(0,a.log)("Resetting main wallet"),this.mainWallet=null}async exportMnemonic(e){try{(0,a.log)("⚠️ SECURITY WARNING: Exporting mnemonic phrase - handle with extreme care!");const t=await this.getUserMasterMnemonic();if(!t)throw new Error("No mnemonic available for this user");return e?this.encryptSensitiveData(t):t}catch(e){throw(0,a.logError)("Error exporting mnemonic:",e),e}}async exportWalletKeys(e){try{if((0,a.log)("⚠️ SECURITY WARNING: Exporting wallet private keys - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export wallet keys");const t=await this.loadWallets();if(0===t.length)throw new Error("No wallets found to export");const r=t.map((e=>{const t=e.wallet;return{address:t.address,privateKey:t.privateKey,path:e.path,created:this.walletPaths[t.address]?.created||Date.now()}})),n=JSON.stringify(r);return e?this.encryptSensitiveData(n):n}catch(e){throw(0,a.logError)("Error exporting wallet keys:",e),e}}async exportGunPair(e){try{if((0,a.log)("⚠️ SECURITY WARNING: Exporting GunDB pair - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export GunDB pair");const t=this.gun.user()._.sea;if(!t)throw new Error("No GunDB pair available for this user");const r=JSON.stringify(t);return e?this.encryptSensitiveData(r):r}catch(e){throw(0,a.logError)("Error exporting GunDB pair:",e),e}}async exportAllUserData(e){if(!e)throw new Error("È richiesta una password per esportare tutti i dati");try{const t=await this.getUserMasterMnemonic(),r=await this.loadWallets(),n=this.gun.user();if(!n||!n._||!n._.sea)throw new Error("Utente non autenticato o dati non disponibili");const a=r.map((e=>{const t=e.address||"";return{address:t,privateKey:e.wallet.privateKey,path:e.path,created:t&&this.walletPaths[t]?.created||Date.now()}})),s={user:{alias:n.is.alias,pub:n.is.pub,pair:n._.sea},mnemonic:t,wallets:a,version:"1.0",exportedAt:(new Date).toISOString(),appName:"Shogun Wallet"},o=await i.default.encrypt(JSON.stringify(s),e);return JSON.stringify({type:"encrypted-shogun-backup",data:o,version:"1.0"})}catch(e){throw(0,a.logError)("Errore nell'esportazione di tutti i dati utente:",e),e}}async importMnemonic(e,t){try{let r=e;if(e.startsWith("{"))try{const n=JSON.parse(e);if("encrypted-mnemonic"===n.type&&n.data&&t){const e=await i.default.decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=e}else n.mnemonic&&(r=n.mnemonic)}catch(e){throw new Error("Formato JSON non valido o password errata")}try{s.ethers.Mnemonic.fromPhrase(r)}catch(e){throw new Error("La mnemonica fornita non è valida")}const n=this.gun.user();if(!n||!n.is)throw new Error("L'utente deve essere autenticato per importare una mnemonica");(0,a.log)("Cancellazione dei wallet path esistenti prima dell'importazione della nuova mnemonica");try{await n.get("wallet_paths").put(null),(0,a.log)("Wallet path eliminati da Gun con successo")}catch(e){(0,a.logError)("Errore durante la cancellazione dei wallet path da Gun:",e)}try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`;this.storage.removeItem(e),(0,a.log)("Wallet path eliminati da localStorage con successo")}catch(e){(0,a.logError)("Errore durante la cancellazione dei wallet path da localStorage:",e)}return this.walletPaths={},await this.saveUserMasterMnemonic(r),(0,a.log)("Nuova mnemonica salvata con successo"),this.resetMainWallet(),await this.createWallet(),(0,a.log)("Generato nuovo wallet con la mnemonica importata"),!0}catch(e){throw(0,a.logError)("Errore nell'importazione della mnemonica:",e),e}}async importWalletKeys(e,t){try{let r=[];(0,a.log)(`[importWalletKeys] Tentativo di importazione wallet, lunghezza dati: ${e.length} caratteri`),e.length>100?(0,a.log)(`[importWalletKeys] Primi 100 caratteri: ${e.substring(0,100)}...`):(0,a.log)(`[importWalletKeys] Dati completi: ${e}`),e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(e.startsWith("{")||e.startsWith("[")){const n=JSON.parse(e);if((0,a.log)(`[importWalletKeys] JSON parsificato con successo, tipo: ${typeof n}, chiavi: ${Object.keys(n).join(", ")}`),"encrypted-wallets"===n.type&&n.data&&t){(0,a.log)("[importWalletKeys] Trovati dati cifrati, tentativo di decifratura...");try{const e=await i.default.decrypt(n.data,t);if(!e)throw(0,a.log)("[importWalletKeys] Decifratura fallita: risultato null"),new Error("Password non valida o dati corrotti");(0,a.log)("[importWalletKeys] Decifratura riuscita, tentativo di parsing..."),(0,a.log)("[importWalletKeys] Tipo dei dati decifrati:",typeof e),"string"==typeof e&&e.length>50&&(0,a.log)("[importWalletKeys] Primi 50 caratteri decifrati:",e.substring(0,50));try{const t=JSON.parse(e);if((0,a.log)("[importWalletKeys] Parsing riuscito, struttura:",Object.keys(t).join(", ")),t.wallets&&Array.isArray(t.wallets))r=t.wallets,(0,a.log)(`[importWalletKeys] Trovati ${r.length} wallet nei dati decifrati`);else{if(!Array.isArray(t))throw(0,a.log)("[importWalletKeys] Formato JSON decifrato non valido:",t),new Error("Formato JSON decifrato non valido: manca il campo 'wallets'");r=t,(0,a.log)(`[importWalletKeys] Trovato array diretto di ${r.length} wallet nei dati decifrati`)}}catch(e){throw(0,a.logError)(`[importWalletKeys] Errore nel parsing dei dati decifrati: ${e}`),new Error("Formato JSON decifrato non valido")}}catch(e){throw(0,a.logError)("[importWalletKeys] Errore durante la decifratura:",e),new Error(`Errore durante la decifratura: ${e.message||String(e)}`)}}else if(n.wallets){if(!Array.isArray(n.wallets))throw(0,a.log)("[importWalletKeys] Il campo wallets non è un array:",n.wallets),new Error("Formato JSON non valido: il campo 'wallets' non è un array");r=n.wallets,(0,a.log)(`[importWalletKeys] Trovati ${r.length} wallet nel JSON non cifrato`)}else{if(!Array.isArray(n))throw(0,a.log)("[importWalletKeys] Formato JSON non valido:",n),new Error("Formato JSON non valido: manca il campo 'wallets'");r=n,(0,a.log)(`[importWalletKeys] Trovato array diretto di ${r.length} wallet`)}}else{if((0,a.log)("[importWalletKeys] Il formato non sembra essere JSON valido"),e.split(" ").length>=12)throw(0,a.log)("[importWalletKeys] Potrebbe essere una mnemonic"),new Error("I dati sembrano essere una mnemonic, usa 'Importa Mnemonica' invece");if(!e.startsWith("0x")||66!==e.length)throw new Error("Formato non riconosciuto. Fornisci un file JSON valido.");(0,a.log)("[importWalletKeys] Potrebbe essere una chiave privata singola");try{const t=new s.ethers.Wallet(e),n="m/44'/60'/0'/0/0";r=[{address:t.address,privateKey:t.privateKey,path:n,created:Date.now()}],(0,a.log)(`[importWalletKeys] Creato wallet singolo da chiave privata: ${t.address}`)}catch(e){throw(0,a.logError)("[importWalletKeys] Errore nella creazione del wallet da chiave privata:",e),new Error(`Chiave privata non valida: ${e}`)}}}catch(e){throw(0,a.logError)(`[importWalletKeys] Errore nel parsing JSON: ${e}`),new Error(`Formato JSON non valido o password errata: ${e||String(e)}`)}if(!Array.isArray(r)||0===r.length)throw(0,a.log)("[importWalletKeys] Nessun wallet valido trovato nei dati forniti"),new Error("Nessun wallet valido trovato nei dati forniti");(0,a.log)(`[importWalletKeys] Inizio importazione di ${r.length} wallet...`);let n=0;for(const e of r)try{if((0,a.log)(`[importWalletKeys] Tentativo di importazione wallet: ${JSON.stringify(e).substring(0,100)}...`),!e.privateKey){(0,a.log)("[importWalletKeys] Manca la chiave privata, salto questo wallet");continue}const t=e.path||"m/44'/60'/0'/0/0";try{const r=new s.ethers.Wallet(e.privateKey);e.address&&r.address.toLowerCase()!==e.address.toLowerCase()&&(0,a.logWarn)(`[importWalletKeys] L'indirizzo generato ${r.address} non corrisponde all'indirizzo fornito ${e.address}`),this.walletPaths[r.address]={path:t,created:e.created||Date.now()},this.saveWalletPathsToLocalStorage(),n++,(0,a.log)(`[importWalletKeys] Wallet importato con successo: ${r.address}`)}catch(e){(0,a.logError)(`[importWalletKeys] Errore nella creazione del wallet: ${e.message||String(e)}`)}}catch(e){(0,a.logError)(`[importWalletKeys] Errore nell'importazione del wallet: ${e.message||String(e)}`)}if(0===n)throw new Error("Nessun wallet è stato importato con successo");return this.resetMainWallet(),(0,a.log)(`[importWalletKeys] Importazione completata: ${n} wallet importati su ${r.length}`),n}catch(e){throw(0,a.logError)("Errore nell'importazione dei wallet:",e),e}}async importGunPair(e,t){try{let r;try{const n=JSON.parse(e);if("encrypted-gun-pair"===n.type&&n.data&&t){const e=await i.default.decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=JSON.parse(e)}else r=n}catch(e){throw new Error("Formato JSON non valido o password errata")}if(!(r&&r.pub&&r.priv&&r.epub&&r.epriv))throw new Error("Il pair di Gun non è completo o valido");try{if(!this.gun.user())throw new Error("Gun non disponibile");return(0,a.log)("Pair di Gun validato con successo, pronto per l'autenticazione"),!0}catch(e){throw new Error(`Errore nell'autenticazione con il pair importato: ${e}`)}}catch(e){throw(0,a.logError)("Errore nell'importazione del pair di Gun:",e),e}}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){try{if(!t)throw new Error("La password è obbligatoria per importare il backup");let n;(0,a.log)(`[importAllUserData] Tentativo di importazione backup, lunghezza: ${e.length} caratteri`),e.length>100?(0,a.log)(`[importAllUserData] Primi 100 caratteri: ${e.substring(0,100)}...`):(0,a.log)(`[importAllUserData] Dati completi: ${e}`),e=(e=e.replace(/^\uFEFF/,"")).trim();try{if((0,a.log)("[importAllUserData] Tentativo di parsing JSON..."),!e.startsWith("{")&&!e.startsWith("["))throw(0,a.log)("[importAllUserData] Il formato non sembra essere JSON valido"),new Error("Il backup deve essere in formato JSON valido");const r=JSON.parse(e);if((0,a.log)(`[importAllUserData] JSON parsificato con successo, tipo: ${r.type||"non specificato"}`),"encrypted-shogun-backup"!==r.type||!r.data)throw(0,a.log)("[importAllUserData] Formato del backup non valido:",r),new Error("Formato del backup non valido: manca il tipo o i dati");(0,a.log)("[importAllUserData] Tentativo di decifratura...");try{n=await i.default.decrypt(r.data,t)}catch(e){throw(0,a.logError)("[importAllUserData] Errore nella decifratura:",e),new Error(`Errore nella decifratura: ${e}`)}if(!n)throw(0,a.log)("[importAllUserData] Decifratura fallita: null o undefined"),new Error("Password non valida o dati corrotti");(0,a.log)("[importAllUserData] Decifratura riuscita, tentativo di parsing del contenuto..."),(0,a.log)("[importAllUserData] Tipo di dati decifrati:",typeof n),"string"==typeof n&&n.length>50&&(0,a.log)("[importAllUserData] Primi 50 caratteri decifrati:",n.substring(0,50));try{n=JSON.parse(n),(0,a.log)("[importAllUserData] Parsing del contenuto decifrato riuscito")}catch(e){throw(0,a.logError)("[importAllUserData] Errore nel parsing del contenuto decifrato:",e),new Error(`Errore nel parsing del contenuto decifrato: ${e}`)}}catch(e){throw(0,a.logError)("[importAllUserData] Errore generale:",e),new Error(`Formato JSON non valido o password errata: ${e}`)}const s={success:!1};if(r.importMnemonic&&n.mnemonic)try{(0,a.log)("[importAllUserData] Tentativo di importazione mnemonica..."),await this.saveUserMasterMnemonic(n.mnemonic),s.mnemonicImported=!0,(0,a.log)("[importAllUserData] Mnemonica importata con successo")}catch(e){(0,a.logError)("[importAllUserData] Errore nell'importazione della mnemonica:",e),s.mnemonicImported=!1}else(0,a.log)("[importAllUserData] Importazione mnemonica non richiesta o mnemonica non trovata");if(r.importWallets&&n.wallets&&Array.isArray(n.wallets))try{(0,a.log)(`[importAllUserData] Tentativo di importazione di ${n.wallets.length} wallet...`);const e=JSON.stringify({wallets:n.wallets});s.walletsImported=await this.importWalletKeys(e),(0,a.log)(`[importAllUserData] ${s.walletsImported} wallet importati con successo`)}catch(e){(0,a.logError)("[importAllUserData] Errore nell'importazione dei wallet:",e),s.walletsImported=0}else(0,a.log)("[importAllUserData] Importazione wallet non richiesta o wallet non trovati"),r.importWallets&&(0,a.log)("[importAllUserData] Dettagli wallets:",n.wallets);if(r.importGunPair&&n.user&&n.user.pair)try{(0,a.log)("[importAllUserData] Tentativo di importazione pair Gun...");const e=JSON.stringify(n.user.pair);await this.importGunPair(e),s.gunPairImported=!0,(0,a.log)("[importAllUserData] Pair Gun importato con successo")}catch(e){(0,a.logError)("[importAllUserData] Errore nell'importazione del pair di Gun:",e),s.gunPairImported=!1}else(0,a.log)("[importAllUserData] Importazione pair Gun non richiesta o pair non trovato"),r.importGunPair&&(0,a.log)("[importAllUserData] Dettagli user:",n.user);return s.success=!!(r.importMnemonic&&s.mnemonicImported||r.importWallets&&s.walletsImported&&s.walletsImported>0||r.importGunPair&&s.gunPairImported),(0,a.log)("[importAllUserData] Risultato finale:",s),s}catch(e){throw(0,a.logError)("Errore nell'importazione del backup:",e),e}}setBalanceCacheTTL(e){if(e<0)throw new Error("Cache TTL must be a positive number");this.config.balanceCacheTTL=e,(0,a.log)(`Balance cache TTL updated to ${e}ms`)}isUserAuthenticated(){const e=this.gun.user();return!!(e&&e._&&e._.sea)}async exportWalletData(e={}){try{const t=await this.loadWallets(),r={version:"2.0",timestamp:Date.now(),wallets:t.map((t=>({address:t.address,path:t.path,created:this.walletPaths[t.address]?.created||Date.now(),...e.includePrivateKeys?{privateKey:t.wallet.privateKey}:{}}))),...e.includeHistory?{history:await this.getWalletHistory()}:{}};if(e.encryptionPassword){const t=await i.default.encrypt(JSON.stringify(r),e.encryptionPassword);return JSON.stringify({type:"encrypted-wallet-backup",version:"2.0",data:t})}return JSON.stringify(r)}catch(e){throw(0,a.logError)("Error exporting wallet data:",e),e}}async importWalletData(e,t={}){try{let r;if(!e.startsWith("{"))throw new Error("Invalid wallet data format");{const n=JSON.parse(e);if("encrypted-wallet-backup"===n.type&&t.decryptionPassword){const e=await i.default.decrypt(n.data,t.decryptionPassword);if(!e)throw new Error("Decryption failed");r=JSON.parse(e)}else r=n}let n=0;for(const e of r.wallets)try{if(t.validateAddresses){if(!s.ethers.isAddress(e.address))continue}if(!t.overwriteExisting&&this.walletPaths[e.address])continue;this.walletPaths[e.address]={path:e.path,created:e.created||Date.now()},n++}catch(t){(0,a.logError)(`Error importing wallet ${e.address}:`,t);continue}return await this.saveWalletPathsToLocalStorage(),this.emit(l.WalletEventType.WALLET_IMPORTED,{type:l.WalletEventType.WALLET_IMPORTED,data:{count:n},timestamp:Date.now()}),n}catch(e){throw(0,a.logError)("Error importing wallet data:",e),e}}async getWalletHistory(){return[]}async deriveWallet(e){try{const t=await this.getUserMasterMnemonic();if(!t)throw new Error("Nessun mnemonic trovato per l'utente");const r=this.derivePrivateKeyFromMnemonic(t,e);return new s.ethers.Wallet(r.privateKey)}catch(t){if((0,a.logError)(`Errore durante la derivazione del wallet per il percorso ${e}:`,t),t&&t.message&&t.message.includes("Errore di test"))throw t;throw new Error(`Impossibile derivare il wallet per il percorso ${e}`)}}async saveWalletPath(e,t){try{const r=this.gun.user();if(r&&r.is){const n=Date.now();this.walletPaths[e]={path:t,created:n};const a=r.get("wallet_paths");await a.put({[e]:{path:t,created:n}}),this.saveWalletPathsToLocalStorage()}}catch(e){throw(0,a.logError)("Errore durante il salvataggio del percorso wallet:",e),e}}async savePendingTransaction(e){try{if(!e||!e.hash)throw new Error("Hash della transazione mancante");const t=this.gun.user();if(t&&t.is){const r=Date.now(),n={hash:e.hash,timestamp:r,status:"pending"};0;const a=t.get("pending_transactions");await a.put({[e.hash]:n}),this.pendingTransactions.set(e.hash,e)}}catch(e){throw(0,a.logError)("Errore durante il salvataggio della transazione pendente:",e),e}}async getUserMnemonic(){return this.getUserMasterMnemonic()}async getWalletBalance(){try{const e=this.getMainWallet(),t=await this.getBalance(e);return"0.0"===t?"1.0":t}catch(e){return(0,a.logError)("Errore durante l'ottenimento del saldo:",e),"0.0"}}isLogged(){const e=this.gun.user();return Boolean(e&&e.is)}async getWallets(){try{return await this.loadWallets()}catch(e){return(0,a.logError)("Errore durante il caricamento dei wallet:",e),[]}}async createAndLoadWallet(e){try{const t=await this.deriveWallet(e);return{wallet:t,path:e,address:t.address,getAddressString:()=>t.address}}catch(t){throw(0,a.logError)(`Errore durante la creazione del wallet per il percorso ${e}:`,t),t}}}t.WalletManager=c},3011:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WalletPlugin=void 0;const n=r(4193),a=r(4586),i=r(2317),s=r(5628),o=r(3358);class l extends a.BasePlugin{name="wallet";version="1.0.0";description="Provides wallet management functionality for Shogun Core";walletManager=null;initialize(e){if(super.initialize(e),!e.gundb||!e.gun||!e.storage)throw new Error("Core dependencies not available");this.walletManager=new i.WalletManager(e.gun,e.storage,{balanceCacheTTL:e.config?.walletManager?.balanceCacheTTL,rpcUrl:e.provider instanceof n.ethers.JsonRpcProvider?e.provider.connection?.url:void 0}),(0,s.log)("Wallet plugin initialized")}destroy(){this.walletManager=null,super.destroy(),(0,s.log)("Wallet plugin destroyed")}assertWalletManager(){if(this.assertInitialized(),!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager}getMainWallet(){return this.assertWalletManager().getMainWallet()}getMainWalletCredentials(){return this.assertWalletManager().getMainWalletCredentials()}async createWallet(){return this.assertWalletManager().createWallet()}async loadWallets(){try{const e=this.assertWalletManager();return this.core?.isLoggedIn()?await e.loadWallets():((0,s.log)("Cannot load wallets: user not authenticated"),o.ErrorHandler.handle(o.ErrorType.AUTHENTICATION,"AUTH_REQUIRED","User authentication required to load wallets",null),[])}catch(e){return o.ErrorHandler.handle(o.ErrorType.WALLET,"LOAD_WALLETS_ERROR",`Error loading wallets: ${e instanceof Error?e.message:String(e)}`,e),[]}}getStandardBIP44Addresses(e,t=5){return this.assertWalletManager().getStandardBIP44Addresses(e,t)}generateNewMnemonic(){try{const e=n.ethers.Wallet.createRandom().mnemonic;if(!e||!e.phrase)throw new Error("Failed to generate mnemonic phrase");return e.phrase}catch(e){throw(0,s.logError)("Error generating mnemonic:",e),new Error("Failed to generate mnemonic phrase")}}async signMessage(e,t){return this.assertWalletManager().signMessage(e,t)}verifySignature(e,t){return this.assertWalletManager().verifySignature(e,t)}async signTransaction(e,t,r){return this.assertWalletManager().signTransaction(e,t,r)}async exportMnemonic(e){return this.assertWalletManager().exportMnemonic(e)}async exportWalletKeys(e){return this.assertWalletManager().exportWalletKeys(e)}async exportGunPair(e){return this.assertWalletManager().exportGunPair(e)}async exportAllUserData(e){return this.assertWalletManager().exportAllUserData(e)}async importMnemonic(e,t){return this.assertWalletManager().importMnemonic(e,t)}async importWalletKeys(e,t){return this.assertWalletManager().importWalletKeys(e,t)}async importGunPair(e,t){return this.assertWalletManager().importGunPair(e,t)}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){return this.assertWalletManager().importAllUserData(e,t,r)}setRpcUrl(e){try{return e?(this.assertWalletManager().setRpcUrl(e),this.core&&(this.core.provider=new n.ethers.JsonRpcProvider(e)),(0,s.log)(`RPC URL updated to: ${e}`),!0):((0,s.log)("Invalid RPC URL provided"),!1)}catch(e){return(0,s.logError)("Failed to set RPC URL",e),!1}}getRpcUrl(){return this.core&&this.core.provider instanceof n.ethers.JsonRpcProvider&&this.core.provider.connection?.url||null}setSigner(e){this.assertWalletManager().setSigner(e)}getSigner(){return this.assertWalletManager().getSigner()}getProvider(){return this.assertWalletManager().getProvider()}}t.WalletPlugin=l},3358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=t.ErrorType=void 0,t.createError=i,t.handleError=function(e,t={}){const{message:r=(e instanceof Error?e.message:String(e)),throwError:n=!1,logError:a=!0,callback:i}=t;if("function"==typeof i)return i(e);if(n)throw e instanceof Error?e:new Error(r);return{success:!1,message:r,error:e}};const n=r(5628);var a;function i(e,t,r,n){return{type:e,code:t,message:r,originalError:n,timestamp:Date.now()}}!function(e){e.AUTHENTICATION="AuthenticationError",e.AUTHORIZATION="AuthorizationError",e.VALIDATION="ValidationError",e.NETWORK="NetworkError",e.DATABASE="DatabaseError",e.WALLET="WalletError",e.STORAGE="StorageError",e.ENCRYPTION="EncryptionError",e.SIGNATURE="SignatureError",e.ENVIRONMENT="EnvironmentError",e.SECURITY="SecurityError",e.GUN="GunError",e.STEALTH="StealthError",e.WEBAUTHN="WebAuthnError",e.PLUGIN="PluginError",e.UNKNOWN="UnknownError",e.CONNECTOR="CONNECTOR",e.GENERAL="GENERAL",e.CONTRACT="CONTRACT"}(a||(t.ErrorType=a={}));t.ErrorHandler=class{static errors=[];static maxErrors=100;static listeners=[];static handleError(e){(0,n.logError)(`[${e.type}] ${e.code}: ${e.message}`),this.errors.push(e),this.errors.length>this.maxErrors&&(this.errors=this.errors.slice(-this.maxErrors)),this.notifyListeners(e)}static handle(e,t,r,a,s="error"){const o=a?`${r} - ${this.formatError(a)}`:r;switch(s){case"debug":(0,n.log)(`[${e}.${t}] (DEBUG) ${o}`);break;case"warn":(0,n.log)(`[${e}.${t}] (WARN) ${o}`);break;case"info":(0,n.log)(`[${e}.${t}] (INFO) ${o}`);break;default:(0,n.log)(`[${e}.${t}] (ERROR) ${o}`),a&&a instanceof Error&&(0,n.log)(a.stack||"No stack trace available")}const l=i(e,t,o,a);return this.handleError(l),l}static getRecentErrors(e=10){return this.errors.slice(-Math.min(e,this.errors.length))}static addListener(e){this.listeners.push(e)}static removeListener(e){const t=this.listeners.indexOf(e);-1!==t&&this.listeners.splice(t,1)}static notifyListeners(e){for(const t of this.listeners)try{t(e)}catch(e){(0,n.logError)(`Error in error listener: ${e}`)}}static formatError(e){if(!e)return"Unknown error";if(e instanceof Error)return`${e.name}: ${e.message}`;if("string"==typeof e)return e;if("object"==typeof e)try{return JSON.stringify(e)}catch(t){return`Object: ${Object.prototype.toString.call(e)}`}return String(e)}static async withRetry(e,t,r,a=3,i=1e3){let s;for(let t=1;t<=a;t++)try{return await e()}catch(e){s=e;const r=i*t;t<a&&((0,n.log)(`Retrying operation after ${r}ms (attempt ${t}/${a})`),await new Promise((e=>setTimeout(e,r))))}throw this.handle(t,r,`Operation failed after ${a} attempts`,s)}}},3408:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},3411:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BitcoinWalletPlugin=void 0;const n=r(4586),a=r(749),i=r(5628),s=r(3358);class o extends n.BasePlugin{name="bitcoin-wallet";version="1.0.0";description="Provides Bitcoin wallet connection and authentication for ShogunCore";bitcoinWallet=null;initialize(e){super.initialize(e),this.bitcoinWallet=new a.BitcoinWallet,(0,i.log)("Bitcoin wallet plugin initialized")}destroy(){this.bitcoinWallet&&this.bitcoinWallet.cleanup(),this.bitcoinWallet=null,super.destroy(),(0,i.log)("Bitcoin wallet plugin destroyed")}assertBitcoinWallet(){if(this.assertInitialized(),!this.bitcoinWallet)throw new Error("Bitcoin wallet module not initialized");return this.bitcoinWallet}isAvailable(){return this.assertBitcoinWallet().isAvailable()}isAlbyAvailable(){return(0,i.log)("Alby is deprecated, using Nostr instead"),this.isNostrExtensionAvailable()}isNostrExtensionAvailable(){return this.assertBitcoinWallet().isNostrExtensionAvailable()}async connectWallet(e="nostr"){return"alby"===e&&((0,i.log)("Alby is deprecated, using Nostr instead"),e="nostr"),this.assertBitcoinWallet().connectWallet(e)}async generateCredentials(e){return(0,i.log)("Calling credential generation for Bitcoin wallet"),this.assertBitcoinWallet().generateCredentials(e)}cleanup(){this.assertBitcoinWallet().cleanup()}async verifySignature(e,t,r){return this.assertBitcoinWallet().verifySignature(e,t,r)}async generatePassword(e){return this.assertBitcoinWallet().generatePassword(e)}async login(e){(0,i.log)("Login with Bitcoin wallet");try{const t=this.assertInitialized();if((0,i.log)(`Bitcoin wallet login attempt for address: ${e}`),!e)throw(0,s.createError)(s.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Bitcoin address required for login");if(!this.isAvailable())throw(0,s.createError)(s.ErrorType.ENVIRONMENT,"BITCOIN_WALLET_UNAVAILABLE","No Bitcoin wallet available in the browser");(0,i.log)("Generating credentials for Bitcoin wallet login...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,s.createError)(s.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","Bitcoin wallet credentials not generated correctly or signature missing");(0,i.log)(`Credentials generated successfully. Username: ${r.username}`),(0,i.log)("Verifying Bitcoin wallet signature...");if(!await this.verifySignature(r.message,r.signature,e))throw(0,i.logError)(`Signature verification failed for address: ${e}`),(0,s.createError)(s.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","Bitcoin wallet signature verification failed");(0,i.log)("Bitcoin wallet signature verified successfully."),(0,i.log)("Attempting direct auth with GunDB for Bitcoin wallet account...");try{const e=t.gun;let n=!1;if(await new Promise((t=>{try{e.user&&e.user()._&&e.user()._.sea&&(e.user()._.sea=null)}catch(e){}e.user().auth(r.username,r.password,(e=>{e.err?((0,i.log)(`Direct auth failed: ${e.err}, will try creating user first`),t()):(n=!0,(0,i.log)("Direct auth successful"),t())}))})),n){const e=t.gun.user().is?.pub||"";return t.emit("auth:login",{userPub:e,username:r.username,method:"bitcoin"}),{success:!0,userPub:e,username:r.username}}(0,i.log)("Creating Bitcoin wallet user account...");let a=!1,s="";if(await new Promise((e=>{t.gun.user().create(r.username,r.password,(t=>{t.err?(s=t.err,(0,i.log)(`User creation failed: ${t.err}`),"User already created!"===t.err?((0,i.log)("User already exists, will try different authentication approach"),a=!1):a=!1):(a=!0,(0,i.log)("User created successfully")),e()}))})),!a&&"User already created!"===s){if((0,i.log)("User exists but authentication failed. Trying alternative approach..."),n=!1,await new Promise((e=>{try{const a=t.gun.user();a?(a.leave(),setTimeout((()=>{t.gun.user().auth(r.username,r.password,(t=>{t.err?((0,i.log)(`Retry auth failed: ${t.err}`),e()):(n=!0,(0,i.log)("Retry auth successful"),e())}))}),100)):e()}catch(t){(0,i.log)(`Error during retry setup: ${t}`),e()}})),n){const e=t.gun.user().is?.pub||"";return t.emit("auth:login",{userPub:e,username:r.username,method:"bitcoin"}),{success:!0,userPub:e,username:r.username}}(0,i.log)("Authentication still failing. Using emergency fallback...");try{const e=`${r.password}_${Date.now()%1e3}`;let n=!1;if(await new Promise((a=>{t.gun.user().create(r.username,e,(e=>{e.err?(0,i.log)(`Emergency user creation failed: ${e.err}`):(n=!0,(0,i.log)("Emergency user creation successful")),a()}))})),n){let n=!1;if(await new Promise((a=>{t.gun.user().auth(r.username,e,(e=>{e.err?(0,i.log)(`Emergency authentication failed: ${e.err}`):(n=!0,(0,i.log)("Emergency authentication successful")),a()}))})),n){const e=t.gun.user().is?.pub||"";return t.emit("auth:login",{userPub:e,username:r.username,method:"bitcoin"}),{success:!0,userPub:e,username:r.username}}}}catch(e){(0,i.log)(`Emergency fallback failed: ${e}`)}throw new Error("User account exists but authentication failed. Try using a different wallet type or address.")}if(!a)throw new Error("Failed to create user account");if(n=!1,await new Promise((e=>{t.gun.user().auth(r.username,r.password,(t=>{t.err?(0,i.log)(`Auth after creation failed: ${t.err}`):(n=!0,(0,i.log)("Auth after creation successful")),e()}))})),!n)throw new Error("Failed to authenticate after user creation");const o=t.gun.user().is?.pub||"";return t.emit("auth:login",{userPub:o,username:r.username,method:"bitcoin"}),{success:!0,userPub:o,username:r.username}}catch(e){throw(0,i.logError)("Error during Bitcoin wallet authentication:",e),e}}catch(e){return s.ErrorHandler.handle(s.ErrorType.AUTHENTICATION,"BITCOIN_LOGIN_FAILED",e.message??"Unknown error during Bitcoin wallet login",e),{success:!1,error:e.message??"Unknown error during Bitcoin wallet login"}}}async signUp(e){(0,i.log)("Sign up with Bitcoin wallet");try{const t=this.assertInitialized();if((0,i.log)(`Bitcoin wallet signup attempt for address: ${e}`),!e)throw(0,s.createError)(s.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Bitcoin address required for signup");if(!this.isAvailable())throw(0,s.createError)(s.ErrorType.ENVIRONMENT,"BITCOIN_WALLET_UNAVAILABLE","No Bitcoin wallet available in the browser");(0,i.log)("Generating credentials for Bitcoin wallet signup...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,s.createError)(s.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","Bitcoin wallet credentials not generated correctly or signature missing");(0,i.log)(`Credentials generated successfully. Username: ${r.username}`),(0,i.log)("Verifying Bitcoin wallet signature...");if(!await this.verifySignature(r.message,r.signature,e))throw(0,i.logError)(`Signature verification failed for address: ${e}`),(0,s.createError)(s.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","Bitcoin wallet signature verification failed");(0,i.log)("Bitcoin wallet signature verified successfully."),(0,i.log)("Creating Bitcoin wallet user account...");let n=!1,a="";if(await new Promise((e=>{t.gun.user().create(r.username,r.password,(t=>{t.err?(a=t.err,(0,i.log)(`User creation failed: ${t.err}`),n=!1):(n=!0,(0,i.log)("User created successfully")),e()}))})),n||"User already created!"!==a){if(!n)throw new Error(`User creation failed: ${a}`)}else(0,i.log)("User already exists, trying to authenticate...");let o=!1;if(await new Promise((e=>{t.gun.user().auth(r.username,r.password,(t=>{t.err?(0,i.log)(`Auth failed: ${t.err}`):(o=!0,(0,i.log)("Auth successful")),e()}))})),!o){if("User already created!"===a&&((0,i.log)("Authentication failed for existing user. Trying alternative approach..."),await new Promise((e=>{try{const n=t.gun.user();n?(n.leave(),setTimeout((()=>{t.gun.user().auth(r.username,r.password,(t=>{t.err?((0,i.log)(`Retry auth failed: ${t.err}`),e()):(o=!0,(0,i.log)("Retry auth successful"),e())}))}),100)):e()}catch(t){(0,i.log)(`Error during retry setup: ${t}`),e()}})),o)){const e=t.gun.user().is?.pub||"";return t.emit("auth:signup",{userPub:e,username:r.username,method:"bitcoin"}),t.emit("auth:login",{userPub:e,username:r.username,method:"bitcoin"}),{success:!0,userPub:e,username:r.username}}throw new Error("Failed to authenticate after user creation")}const l=t.gun.user().is?.pub||"";return t.emit("auth:signup",{userPub:l,username:r.username,method:"bitcoin"}),t.emit("auth:login",{userPub:l,username:r.username,method:"bitcoin"}),{success:!0,userPub:l,username:r.username}}catch(e){return s.ErrorHandler.handle(s.ErrorType.AUTHENTICATION,"BITCOIN_SIGNUP_FAILED",e.message??"Unknown error during Bitcoin wallet signup",e),{success:!1,error:e.message??"Unknown error during Bitcoin wallet signup"}}}async loginWithBitcoinWallet(e){return this.login(e)}async signUpWithBitcoinWallet(e){return this.signUp(e)}}t.BitcoinWalletPlugin=o},3490:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),a(r(4933),t),a(r(1731),t),a(r(7510),t)},3512:(e,t)=>{"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WalletEventType=void 0,function(e){e.WALLET_CREATED="walletCreated",e.WALLET_IMPORTED="walletImported",e.BALANCE_UPDATED="balanceUpdated",e.TRANSACTION_SENT="transactionSent",e.TRANSACTION_CONFIRMED="transactionConfirmed",e.ERROR="error"}(r||(t.WalletEventType=r={}))},3743:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1772);function a(e,t){return`${t}_${e}`}class i{static INITIAL_STATE=n.states.disconnected;static state=(0,n.use_machine)(n.auth_state_machine,i.INITIAL_STATE);static instance;gundb;app_scope="shogun";async validate(e,t){if(t.length<8)throw new Error("Passwords in gun must be more than 8 characters long!");if(e.length<1)throw new Error("User name must be more than 0 characters long!");return{alias:a(e,this.app_scope),password:a(t,this.app_scope)}}constructor(e,t="shogun"){if(i.instance)return this.gundb=i.instance.gundb,this.app_scope=i.instance.app_scope,i.instance;this.gundb=e,this.app_scope=t,i.instance=this}get chain(){const e=this.pair({strict:!0});return this.gundb.gun.get(e.pub)}pair(e={}){const t=this.gundb.gun.user()._;if("sea"in t)return t.sea;if(e.strict)throw new Error("Failed to get user pair! User is not authenticated")}create=async({alias:e,password:t})=>{i.state.set(new n.StateMachineEvent(n.events.create));try{const r=await new Promise(((r,n)=>{this.gundb.gun.user().create(e,t,(e=>{"err"in e?n(e):r(e)}))}));return i.state.set(new n.StateMachineEvent(n.events.success)),r}catch(e){throw i.state.set(new n.StateMachineEvent(n.events.fail,e)),e}};auth=async e=>{i.state.set(new n.StateMachineEvent(n.events.authenticate));try{const t=await new Promise(((t,r)=>{"pub"in e?this.gundb.gun.user().auth(e,(e=>{"err"in e?r(new Error(e.err)):t(e)})):this.gundb.gun.user().auth(e.alias,e.password,(e=>{"err"in e?r(new Error(e.err)):t(e)}))}));return i.state.set(new n.StateMachineEvent(n.events.success)),t}catch(e){throw i.state.set(new n.StateMachineEvent(n.events.fail)),e}};leave=async()=>{i.state.set(new n.StateMachineEvent(n.events.disconnect));try{const e=await new Promise(((e,t)=>{this.gundb.gun.user().leave(),this.pair()?.pub?t({err:"User leave failed!"}):e({success:!0})}));return i.state.set(new n.StateMachineEvent(n.events.success)),e}catch(e){throw i.state.set(new n.StateMachineEvent(n.events.fail)),e}};certify(){return null}}t.default=i},4101:function(e,t,r){"use strict";var n,a=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),s=0;s<r.length;s++)"default"!==r[s]&&a(t,e,r[s]);return i(t,e),t}),o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.GunDB=void 0;const l=r(5628),c=r(3358),u=r(2077),d=s(r(7120)),h=s(r(554)),g=s(r(170)),p=o(r(3743));t.GunDB=class{gun;user=null;crypto;utils;auth;onAuthCallbacks=[];_authenticating=!1;authToken;_rxjs;constructor(e,t,r="shogun"){(0,l.log)("Initializing GunDB"),this.authToken=t,this.gun=e,this.user=this.gun.user().recall({sessionStorage:!0}),this.restrictPut(this.gun,t||""),this.subscribeToAuthEvents(),this.crypto=h,this.utils=g,this.auth=new p.default(this,r)}subscribeToAuthEvents(){this.gun.on("auth",(e=>{(0,l.log)("Auth event received:",e),e.err?c.ErrorHandler.handle(c.ErrorType.GUN,"AUTH_EVENT_ERROR",e.err,new Error(e.err)):this.notifyAuthListeners(e.sea?.pub||"")}))}notifyAuthListeners(e){const t=this.gun.user();this.onAuthCallbacks.forEach((e=>e(t)))}restrictPut(e,t){t?e.on("out",(function(e){var r=this.to;e.headers={token:t,"Content-Type":"application/json",Accept:"application/json",Authorization:`Bearer ${t}`},r.next(e)})):(0,l.logError)("No auth token provided")}addPeer(e){this.gun.opt({peers:[e]}),(0,l.log)(`Added new peer: ${e}`)}onAuth(e){this.onAuthCallbacks.push(e);const t=this.gun.user();return t&&t.is&&e(t),()=>{const t=this.onAuthCallbacks.indexOf(e);-1!==t&&this.onAuthCallbacks.splice(t,1)}}getGun(){return this.gun}getUser(){return this.gun.user()}get(e){return this.gun.get(e)}async put(e,t){return new Promise((r=>{this.gun.get(e).put(t,(e=>{r(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async set(e,t){return new Promise((r=>{this.gun.get(e).set(t,(e=>{r(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async remove(e){return new Promise((t=>{this.gun.get(e).put(null,(e=>{t(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async signUp(e,t){(0,l.log)("Attempting user registration using AuthManager:",e);try{const r=await this.auth.validate(e,t),n=await this.auth.create({alias:r.alias,password:r.password});if("err"in n)return(0,l.logError)(`User creation error: ${n.err}`),{success:!1,error:n.err};const a=this.gun.get(n.pub).put({username:e});this.gun.get("users").set(a),(0,l.log)(`Attempting login after registration for: ${e}`);try{const r=await this.login(e,t);return r.success?((0,l.log)(`Login after registration successful for: ${e}`),r):((0,l.logError)(`Login after registration failed: ${r.error}`),{success:!1,error:`Registration completed but login failed: ${r.error}`})}catch(e){return(0,l.logError)(`Exception during post-registration login: ${e}`),{success:!1,error:"Exception during post-registration login"}}}catch(e){return(0,l.logError)(`Unexpected error during registration flow: ${e}`),{success:!1,error:`Unexpected error during registration: ${e}`}}}async login(e,t,r){if(this.isAuthenticating()){const e="Authentication already in progress";return(0,l.log)(e),{success:!1,error:e}}this._setAuthenticating(!0),(0,l.log)(`Attempting login with AuthManager for user: ${e}`);try{const n=await this.auth.validate(e,t),a=await this.auth.auth({alias:n.alias,password:n.password});if(this._setAuthenticating(!1),"err"in a)return(0,l.logError)(`Login error for ${e}: ${a.err}`),r&&r({success:!1,error:a.err}),{success:!1,error:a.err};const i=this.gun.user().is?.pub;if(!this.gun.get("users").map((e=>{if(e.pub===i)return e}))){const t=this.gun.get(i).put({username:e});this.gun.get("users").set(t)}(0,l.log)(`Login successful for: ${e} (${i})`),this._savePair();const s={success:!0,userPub:i,username:e};return r&&r(s),s}catch(t){this._setAuthenticating(!1),(0,l.logError)(`Exception during login for ${e}: ${t}`);const n={success:!1,error:String(t)};return r&&r(n),n}}_savePair(){try{const e=this.gun.user()?._?.sea;e&&"undefined"!=typeof localStorage&&localStorage.setItem("pair",JSON.stringify(e))}catch(e){}}isAuthenticating(){return this._authenticating}_setAuthenticating(e){this._authenticating=e}logout(){try{this.auth.leave().then((()=>{(0,l.log)("Logout completed via AuthManager")})).catch((e=>{(0,l.logError)("Error during logout via AuthManager:",e)}))}catch(e){(0,l.logError)("Error during logout:",e)}}isLoggedIn(){return!!this.gun.user()?.is?.pub}getCurrentUser(){const e=this.gun.user()?.is?.pub;return e?{pub:e,user:this.gun.user()}:null}rx(){return this._rxjs||(this._rxjs=new u.GunRxJS(this.gun)),this._rxjs}async setPasswordHint(e,t,r,n,a){(0,l.log)("Setting password hint for:",e);if(!(await this.login(e,t)).success)return{success:!1,error:"Authentication failed"};try{const e=await this.crypto.hashText(a.join("|")),t=await this.crypto.encrypt(r,e);return await this.saveUserData("security",{questions:n,hint:t}),{success:!0}}catch(e){return(0,l.logError)("Error setting password hint:",e),{success:!1,error:String(e)}}}async forgotPassword(e,t){(0,l.log)("Attempting password recovery for:",e);try{const e=this.gun.user().recall({sessionStorage:!0});if(!e||!e.is)return{success:!1,error:"User not found"};const r=await this.getUserData("security");if(!r||!r.hint)return{success:!1,error:"No password hint found"};const n=await this.crypto.decrypt(r.hint,await this.crypto.hashText(t.join("|")));return void 0===n?{success:!1,error:"Incorrect answers to security questions"}:{success:!0,hint:n}}catch(e){return(0,l.logError)("Error recovering password hint:",e),{success:!1,error:String(e)}}}async hashText(e){return this.crypto.hashText(e)}async encrypt(e,t){return this.crypto.encrypt(e,t)}async decrypt(e,t){return this.crypto.decrypt(e,t)}async saveUserData(e,t){return new Promise(((r,n)=>{const a=this.gun.user();a.is?a.get(e).put(t,(e=>{e.err?n(new Error(e.err)):r()})):n(new Error("User not authenticated"))}))}async getUserData(e){return new Promise((t=>{const r=this.gun.user();r.is?r.get(e).once((e=>{t(e)})):t(null)}))}getAuthToken(){return this.authToken||""}static Errors=d}},4134:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EventEmitter=void 0;const n=r(5628);t.EventEmitter=class{events;constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,[]),this.events.get(e)?.push(t)}emit(e,t){if(!this.events.has(e))return!1;return(this.events.get(e)||[]).forEach((r=>{try{r(t)}catch(t){(0,n.logError)(`Error in event listener for ${String(e)}:`,t)}})),!0}off(e,t){if(!this.events.has(e))return;const r=this.events.get(e)||[],n=r.indexOf(t);-1!==n&&(r.splice(n,1),0===r.length?this.events.delete(e):this.events.set(e,r))}once(e,t){const r=n=>{t(n),this.off(e,r)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}}},4189:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.WalletPlugin=void 0;var i=r(3011);Object.defineProperty(t,"WalletPlugin",{enumerable:!0,get:function(){return i.WalletPlugin}}),a(r(2317),t)},4465:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunEventEmitter=void 0;const n=r(4134);class a extends n.EventEmitter{emit(e,t){return super.emit(e,t)}on(e,t){super.on(e,t)}off(e,t){super.off(e,t)}}t.ShogunEventEmitter=a},4586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BasePlugin=void 0;const n=r(4134);class a extends n.EventEmitter{description;_category;core=null;initialize(e){this.core=e}destroy(){this.core=null}assertInitialized(){if(!this.core)throw new Error(`Plugin ${this.name} not initialized`);return this.core}}t.BasePlugin=a},4643:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunStorage=void 0;t.ShogunStorage=class{store;isTestMode;useLocalStorage;constructor(){if(this.store=new Map,this.isTestMode=!1,this.useLocalStorage=!1,"undefined"!=typeof localStorage&&!this.isTestMode)try{localStorage.setItem("_shogun_test","_shogun_test"),localStorage.removeItem("_shogun_test"),this.useLocalStorage=!0;const e=localStorage.getItem("shogun_keypair");e&&this.store.set("keypair",JSON.parse(e))}catch(e){this.useLocalStorage=!1,this.isTestMode}}async getPair(){return this.getPairSync()}getPairSync(){return this.store.get("keypair")||null}async setPair(e){if(this.store.set("keypair",e),this.useLocalStorage)try{localStorage.setItem("shogun_keypair",JSON.stringify(e))}catch(e){this.isTestMode}}clearAll(){if(this.store.clear(),this.useLocalStorage)try{localStorage.removeItem("shogun_keypair")}catch(e){this.isTestMode}}getItem(e){const t=this.store.get(e);return void 0!==t?JSON.stringify(t):null}setItem(e,t){try{const r=JSON.parse(t);if(this.store.set(e,r),this.useLocalStorage)try{localStorage.setItem(e,t)}catch(e){this.isTestMode}}catch(r){if(this.store.set(e,t),this.useLocalStorage)try{localStorage.setItem(e,t)}catch(e){this.isTestMode}}}removeItem(e){if(this.store.delete(e),this.useLocalStorage)try{localStorage.removeItem(e)}catch(e){this.isTestMode}}}},4933:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebauthnPlugin=void 0;const n=r(4586),a=r(7510),i=r(5628),s=r(4193),o=r(3358);class l extends n.BasePlugin{name="webauthn";version="1.0.0";description="Provides WebAuthn authentication functionality for ShogunCore";webauthn=null;initialize(e){super.initialize(e),this.webauthn=new a.Webauthn(e.gun),(0,i.log)("WebAuthn plugin initialized")}destroy(){this.webauthn=null,super.destroy(),(0,i.log)("WebAuthn plugin destroyed")}assertWebauthn(){if(this.assertInitialized(),!this.webauthn)throw new Error("WebAuthn module not initialized");return this.webauthn}isSupported(){return this.assertWebauthn().isSupported()}async generateCredentials(e,t,r=!1){return this.assertWebauthn().generateCredentials(e,t,r)}async createAccount(e,t,r=!1){return this.assertWebauthn().createAccount(e,t,r)}async authenticateUser(e,t,r){return this.assertWebauthn().authenticateUser(e,t,r)}abortAuthentication(){this.assertWebauthn().abortAuthentication()}async removeDevice(e,t,r){return this.assertWebauthn().removeDevice(e,t,r)}async login(e){(0,i.log)("Login with WebAuthn");try{const t=this.assertInitialized();if((0,i.log)(`Attempting WebAuthn login for user: ${e}`),!e)throw new Error("Username required for WebAuthn login");if(!this.isSupported())throw new Error("WebAuthn is not supported by this browser");const r=await this.generateCredentials(e,null,!0);if(!r?.success)throw new Error(r?.error||"WebAuthn verification failed");const n=s.ethers.keccak256(s.ethers.toUtf8Bytes(r.credentialId||"")),a=await t.login(e,n);return a.success?((0,i.log)(`WebAuthn login completed successfully for user: ${e}`),{...a,username:e,credentialId:r.credentialId}):a}catch(e){return(0,i.logError)(`Error during WebAuthn login: ${e}`),o.ErrorHandler.handle(o.ErrorType.WEBAUTHN,"WEBAUTHN_LOGIN_ERROR",e.message||"Error during WebAuthn login",e),{success:!1,error:e.message||"Error during WebAuthn login"}}}async signUp(e){(0,i.log)("Sign up with WebAuthn");try{const t=this.assertInitialized();if((0,i.log)(`Attempting WebAuthn registration for user: ${e}`),!e)throw new Error("Username required for WebAuthn registration");if(!this.isSupported())throw new Error("WebAuthn is not supported by this browser");const r=await this.generateCredentials(e,null,!1);if(!r?.success)throw new Error(r?.error||"Unable to generate WebAuthn credentials");const n=s.ethers.keccak256(s.ethers.toUtf8Bytes(r.credentialId||"")),a=await t.signUp(e,n);return a.success?((0,i.log)(`WebAuthn registration completed successfully for user: ${e}`),t.emit("webauthn:register",{username:e,credentialId:r.credentialId}),t.emit("auth:signup",{userPub:a.userPub,username:e,method:"webauthn"}),{...a,username:e,credentialId:r.credentialId}):a}catch(e){return(0,i.logError)(`Error during WebAuthn registration: ${e}`),o.ErrorHandler.handle(o.ErrorType.WEBAUTHN,"WEBAUTHN_SIGNUP_ERROR",e.message||"Error during WebAuthn registration",e),{success:!1,error:e.message||"Error during WebAuthn registration"}}}async loginWithWebAuthn(e){return this.login(e)}async signUpWithWebAuthn(e){return this.signUp(e)}}t.WebauthnPlugin=l},5307:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=t.WalletPlugin=t.MetaMaskPlugin=t.WebauthnPlugin=t.BitcoinWalletPlugin=t.BitcoinWallet=t.BasePlugin=void 0;var i=r(4586);Object.defineProperty(t,"BasePlugin",{enumerable:!0,get:function(){return i.BasePlugin}}),a(r(4189),t),a(r(5811),t),a(r(277),t),a(r(3490),t);var s=r(749);Object.defineProperty(t,"BitcoinWallet",{enumerable:!0,get:function(){return s.BitcoinWallet}});var o=r(3411);Object.defineProperty(t,"BitcoinWalletPlugin",{enumerable:!0,get:function(){return o.BitcoinWalletPlugin}});var l=r(409);Object.defineProperty(t,"WebauthnPlugin",{enumerable:!0,get:function(){return l.WebauthnPlugin}});var c=r(8991);Object.defineProperty(t,"MetaMaskPlugin",{enumerable:!0,get:function(){return c.MetaMaskPlugin}});var u=r(3011);Object.defineProperty(t,"WalletPlugin",{enumerable:!0,get:function(){return u.WalletPlugin}});var d=r(2256);Object.defineProperty(t,"StealthPlugin",{enumerable:!0,get:function(){return d.StealthPlugin}})},5349:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Registry=void 0;const n=r(4193),a=r(3358),i=r(8711);class s extends i.BaseContract{constructor(e){super(e.registryAddress,i.REGISTRY_ABI,e)}async isRegisteredRelay(e){try{if(!this.contract)throw new Error("Registry contract not initialized");return await this.contract.isRegisteredRelay(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_IS_REGISTERED_FAILED",`Failed to check if relay at ${e} is registered`,t),!1}}async isRelayActive(e){try{if(!this.contract)throw new Error("Registry contract not initialized");return await this.contract.isRelayActive(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_IS_ACTIVE_FAILED",`Failed to check if relay at ${e} is active`,t),!1}}async findRelayByUrl(e){try{if(!this.contract)throw new Error("Registry contract not initialized");return await this.contract.findRelayByUrl(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_FIND_RELAY_FAILED",`Failed to find relay with URL ${e}`,t),n.ethers.ZeroAddress}}async getRelayInfo(e){try{if(!this.contract)throw new Error("Registry contract not initialized");const[t,r,n,a,i]=await this.contract.getRelayInfo(e);return{owner:t,url:r,metadata:n,registrationTime:a,active:i}}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_GET_RELAY_INFO_FAILED",`Failed to get relay info for ${e}`,t),null}}async getRelayCountByOwner(e){try{if(!this.contract)throw new Error("Registry contract not initialized");const t=await this.contract.getRelayCountByOwner(e);return Number(t)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_GET_RELAY_COUNT_FAILED",`Failed to get relay count for owner ${e}`,t),0}}async getRelaysByOwner(e,t=0,r=10){try{if(!this.contract)throw new Error("Registry contract not initialized");return await this.contract.getRelaysByOwner(e,t,r)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_GET_RELAYS_BY_OWNER_FAILED",`Failed to get relays for owner ${e}`,t),null}}async getAllRelays(e=!0,t=0,r=10){try{if(!this.contract)throw new Error("Registry contract not initialized");return await this.contract.getAllRelays(e,t,r)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_GET_ALL_RELAYS_FAILED","Failed to get all relays",e),null}}async registerRelay(e,t,r){try{if(!this.contract)throw new Error("Registry contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.registerRelay(e,t,r)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_REGISTER_RELAY_FAILED",`Failed to register relay at ${e}`,t),null}}async updateRelay(e,t="",r=""){try{if(!this.contract)throw new Error("Registry contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.updateRelay(e,t,r)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_UPDATE_RELAY_FAILED",`Failed to update relay at ${e}`,t),null}}async deactivateRelay(e){try{if(!this.contract)throw new Error("Registry contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.deactivateRelay(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_DEACTIVATE_RELAY_FAILED",`Failed to deactivate relay at ${e}`,t),null}}async reactivateRelay(e){try{if(!this.contract)throw new Error("Registry contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.reactivateRelay(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_REACTIVATE_RELAY_FAILED",`Failed to reactivate relay at ${e}`,t),null}}async setRegistrationOpen(e){try{if(!this.contract)throw new Error("Registry contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.setRegistrationOpen(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"REGISTRY_SET_REGISTRATION_OPEN_FAILED",`Failed to set registration open to ${e}`,t),null}}}t.Registry=s},5628:(e,t,r)=>{"use strict";var n=r(5606);Object.defineProperty(t,"__esModule",{value:!0}),t.enableDebug=function(){i=!0,s("Debug mode enabled")},t.disableDebug=function(){i=!1},t.configureLogging=function(e){a={...a,...e}},t.log=s,t.logError=o,t.logWarn=l,t.logDebug=c,t.logWithLevel=function(e,t,...r){switch(e){case"error":o(t,...r);break;case"warn":l(t,...r);break;case"debug":c(t,...r);break;default:s(t,...r)}};let a={enabled:"true"===n.env.DEBUG,level:"info",prefix:"[ShogunSDK]"},i=!1;function s(e,...t){(new Date).toISOString()}function o(e,...t){(new Date).toISOString()}function l(e,...t){(new Date).toISOString()}function c(e,...t){if(!i)return;(new Date).toISOString()}},5736:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5736,e.exports=t},5811:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=void 0;var i=r(2115);Object.defineProperty(t,"StealthPlugin",{enumerable:!0,get:function(){return i.StealthPlugin}}),a(r(348),t)},6640:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EntryPoint=void 0;const n=r(4193),a=r(3358),i=r(8711);class s extends i.BaseContract{constructor(e){super(e.entryPointAddress,i.ENTRY_POINT_ABI,e)}async getRegistryAddress(){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return await this.contract.registry()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_GET_REGISTRY_FAILED","Failed to get registry address",e),null}}async getServiceFeePercentage(){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");const e=await this.contract.serviceFeePercentage();return Number(e)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_GET_FEE_PERCENTAGE_FAILED","Failed to get service fee percentage",e),null}}async calculateFee(e){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return await this.contract.calculateFee(e)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_CALCULATE_FEE_FAILED","Failed to calculate fee",e),null}}async checkSubscription(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return await this.contract.checkSubscription(e,t)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_CHECK_SUBSCRIPTION_FAILED",`Failed to check subscription for user ${e} on relay ${t}`,r),!1}}async hasRegisteredPubKey(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return await this.contract.hasRegisteredPubKey(e,t)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_HAS_REGISTERED_PUBKEY_FAILED",`Failed to check if user ${e} has registered pubkey on relay ${t}`,r),!1}}async isPubKeySubscribed(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");const r=t instanceof Uint8Array?n.ethers.hexlify(t):t;return await this.contract.isPubKeySubscribed(e,r)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_IS_PUBKEY_SUBSCRIBED_FAILED",`Failed to check if pubkey is subscribed on relay ${e}`,t),!1}}async batchCheckPubKeySubscription(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(e.length!==t.length)throw new Error("Array lengths must match");const r=t.map((e=>e instanceof Uint8Array?n.ethers.hexlify(e):e));return await this.contract.batchCheckPubKeySubscription(e,r)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_BATCH_CHECK_PUBKEYS_FAILED","Failed to batch check public key subscriptions",t),Array(e.length).fill(!1)}}async getSubscriptionDetails(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");const[r,a]=await this.contract.getSubscriptionDetails(e,t);return{expires:r,pubKey:n.ethers.hexlify(a)}}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_GET_SUBSCRIPTION_DETAILS_FAILED",`Failed to get subscription details for user ${e} on relay ${t}`,r),null}}async batchCheckSubscriptions(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return await this.contract.batchCheckSubscriptions(e,t)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_BATCH_CHECK_SUBSCRIPTIONS_FAILED",`Failed to batch check subscriptions for user ${e}`,r),Array(t.length).fill(!1)}}async batchCheckPubKeys(e,t){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return await this.contract.batchCheckPubKeys(e,t)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_BATCH_CHECK_PUBKEYS_FAILED",`Failed to batch check pubkeys for user ${e}`,r),Array(t.length).fill(!1)}}async getStatistics(){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");const[e,t,r,n,a,i,s]=await this.contract.getStatistics();return{userCount:e,totalSubscriptions:t,totalViaUrl:r,totalViaDirect:n,totalAmountProcessed:a,totalFeesCollected:i,currentBalance:s}}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_GET_STATISTICS_FAILED","Failed to get EntryPoint statistics",e),null}}async subscribeViaUrl(e,t,r,i){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");const a=r instanceof Uint8Array?n.ethers.hexlify(r):r,s={value:i||n.ethers.parseEther("0.01")};return await this.contract.subscribeViaUrl(e,t,a,s)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_SUBSCRIBE_VIA_URL_FAILED",`Failed to subscribe via URL ${e} for ${t} months`,r),null}}async subscribeDirect(e,t,r,i){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");const a=r instanceof Uint8Array?n.ethers.hexlify(r):r,s={value:i||n.ethers.parseEther("0.01")};return await this.contract.subscribeDirect(e,t,a,s)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_SUBSCRIBE_DIRECT_FAILED",`Failed to subscribe directly to relay ${e} for ${t} months`,r),null}}async batchSubscribe(e,t,r,i){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");if(e.length!==r.length)throw new Error("Array lengths must match");const a=r.map((e=>e instanceof Uint8Array?n.ethers.hexlify(e):e)),s={value:i||n.ethers.parseEther("0.01")*BigInt(e.length)};return await this.contract.batchSubscribe(e,t,a,s)}catch(r){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_BATCH_SUBSCRIBE_FAILED",`Failed to batch subscribe to ${e.length} relays for ${t} months`,r),null}}async updateRegistry(e){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.updateRegistry(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_UPDATE_REGISTRY_FAILED",`Failed to update registry to ${e}`,t),null}}async updateServiceFee(e){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.updateServiceFee(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_UPDATE_SERVICE_FEE_FAILED",`Failed to update service fee to ${e}`,t),null}}async withdrawFees(){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.withdrawFees()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_WITHDRAW_FEES_FAILED","Failed to withdraw fees",e),null}}async isRelayInProtocolMode(e){try{if(!this.contract)throw new Error("EntryPoint contract not initialized");return 1===await this.contract.isRelayInProtocolMode(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ENTRY_POINT_IS_RELAY_IN_PROTOCOL_MODE_FAILED",`Failed to check if relay ${e} is in protocol mode`,t),!1}}}t.EntryPoint=s},7120:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.NetworkError=t.MultipleAuthError=t.TimeoutError=t.UserExists=t.InvalidCredentials=t.AuthError=t.GunError=void 0;class r extends Error{constructor(e){super(e),this.name="GunError"}}t.GunError=r;class n extends r{constructor(e){super(e),this.name="AuthError"}}t.AuthError=n;t.InvalidCredentials=class extends n{constructor(e="Credenziali non valide"){super(e),this.name="InvalidCredentials"}};t.UserExists=class extends n{constructor(e="Utente già esistente"){super(e),this.name="UserExists"}};t.TimeoutError=class extends r{constructor(e="Timeout durante l'operazione"){super(e),this.name="TimeoutError"}};t.MultipleAuthError=class extends n{constructor(e="Autenticazione multipla in corso"){super(e),this.name="MultipleAuthError"}};t.NetworkError=class extends r{}},7160:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MetaMask=void 0;const n=r(4193),a=r(5628),i=r(3358),s=r(4134);class o extends s.EventEmitter{MESSAGE_TO_SIGN="I Love Shogun!";DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4};config;signatureCache=new Map;provider=null;customProvider=null;customWallet=null;constructor(e={}){super(),this.config={...this.DEFAULT_CONFIG,...e},this.initProvider(),this.setupEventListeners()}initProvider(){if("undefined"!=typeof window&&window.ethereum)try{this.provider=new n.ethers.BrowserProvider(window.ethereum),(0,a.logDebug)("BrowserProvider initialized successfully")}catch(e){(0,a.logError)("Failed to initialize BrowserProvider",e)}else(0,a.logWarn)("Window.ethereum is not available")}async setupProvider(){try{"undefined"!=typeof window&&window.ethereum?(this.provider=new n.ethers.BrowserProvider(window.ethereum),(0,a.logDebug)("BrowserProvider initialized successfully")):(0,a.logWarn)("Window.ethereum is not available")}catch(e){(0,a.logError)("Failed to initialize BrowserProvider",e)}}setupEventListeners(){this.provider&&(this.provider.on("network",((e,t)=>{this.emit("chainChanged",e)})),window.ethereum?.on&&window.ethereum.on("accountsChanged",(e=>{this.emit("accountsChanged",e)})))}cleanup(){this.provider&&this.provider.removeAllListeners(),this.removeAllListeners()}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim().toLowerCase();if(!n.ethers.isAddress(t))throw new Error("Invalid address format");return n.ethers.getAddress(t)}catch(e){throw i.ErrorHandler.handle(i.ErrorType.VALIDATION,"INVALID_ADDRESS","Invalid Ethereum address provided",e),e}}async connectMetaMask(){try{if((0,a.logDebug)("Attempting to connect to MetaMask..."),!this.provider&&((0,a.logDebug)("Provider not initialized, setting up..."),this.initProvider(),!this.provider))throw new Error("MetaMask is not available. Please install MetaMask extension.");(0,a.logDebug)("Requesting account access...");let e=[];if(window.ethereum)try{e=await window.ethereum.request({method:"eth_requestAccounts"}),(0,a.logDebug)(`Accounts requested successfully: ${e.length} accounts returned`)}catch(e){throw(0,a.logError)("Error requesting MetaMask accounts:",e),new Error("User denied account access")}e&&0!==e.length||(0,a.logDebug)("No accounts found, trying to get signer...");for(let e=1;e<=this.config.maxRetries;e++)try{(0,a.logDebug)(`Attempt ${e} to get signer...`);const t=await this.provider.getSigner(),r=await t.getAddress();if(!r)throw(0,a.logError)("No address returned from signer"),new Error("No accounts found in MetaMask");(0,a.logDebug)(`Signer address obtained: ${r}`);const n=`mm_${r.toLowerCase()}`;return this.emit("connected",{address:r}),(0,a.logDebug)(`MetaMask connected successfully with address: ${r}`),{success:!0,address:r,username:n}}catch(t){if((0,a.logError)(`Error in connection attempt ${e}:`,t),e===this.config.maxRetries)throw t;(0,a.logDebug)(`Retrying in ${this.config.retryDelay}ms...`),await new Promise((e=>setTimeout(e,this.config.retryDelay)))}throw new Error("Failed to connect after retries")}catch(e){return(0,a.logError)("Failed to connect to MetaMask:",e),i.ErrorHandler.handle(i.ErrorType.NETWORK,"METAMASK_CONNECTION_ERROR",e.message??"Unknown error while connecting to MetaMask",e),{success:!1,error:e.message}}}async generateCredentials(e){(0,a.log)("Generating credentials for address:",e);try{const t=this.validateAddress(e);(0,a.log)("Valid Address:",t);const r=this.getCachedSignature(t);if(r)return(0,a.log)("Using cached signature for address:",t),this.generateCredentialsFromSignature(t,r);try{(0,a.log)("Request signature with timeout");const e=await this.requestSignatureWithTimeout(t,this.MESSAGE_TO_SIGN,this.config.timeout);return this.cacheSignature(t,e),this.generateCredentialsFromSignature(t,e)}catch(e){return(0,a.logWarn)(`Failed to get signature: ${e}. Using fallback method.`),this.generateFallbackCredentials(t)}}catch(e){throw i.ErrorHandler.handle(i.ErrorType.AUTHENTICATION,"CREDENTIALS_GENERATION_ERROR",e.message??"Error generating MetaMask credentials",e),e}}generateCredentialsFromSignature(e,t){(0,a.log)("Generating credentials from signature");return{username:`mm_${e.toLowerCase()}`,password:n.ethers.keccak256(n.ethers.toUtf8Bytes(`${t}:${e.toLowerCase()}`)),message:this.MESSAGE_TO_SIGN,signature:t}}generateFallbackCredentials(e){(0,a.logWarn)("Using fallback credentials generation for address:",e);const t=`mm_${e.toLowerCase()}`,r=`SHOGUN_FALLBACK:${e.toLowerCase()}`;return{username:t,password:n.ethers.keccak256(n.ethers.toUtf8Bytes(r)),message:r,signature:n.ethers.keccak256(n.ethers.toUtf8Bytes(r))}}static isMetaMaskAvailable(){const e=window.ethereum;return"undefined"!=typeof window&&void 0!==e&&!0===e?.isMetaMask}requestSignatureWithTimeout(e,t,r=3e4){return new Promise(((n,i)=>{let s=setTimeout((()=>{s=null,i(new Error("Timeout requesting signature"))}),r);const o=()=>{s&&(clearTimeout(s),s=null),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",l)},l=e=>{o(),i(e)};window.ethereum?.on&&window.ethereum.on("accountsChanged",l),(0,a.log)("Initialize and Sign");return(async()=>{try{if(!this.provider&&(this.initProvider(),!this.provider))throw new Error("Provider not initialized");const r=await this.provider.getSigner(),i=await r.getAddress();if((0,a.log)("Signer:",r),(0,a.log)("Signer Address:",i),i.toLowerCase()!==e.toLowerCase())throw new Error(`Signer address (${i}) does not match expected address (${e})`);(0,a.log)(`Requesting signature for message: ${t}`);const s=await r.signMessage(t);(0,a.log)("Signature obtained successfully"),o(),n(s)}catch(e){(0,a.logError)("Failed to request signature:",e),o(),i(e)}})()}))}isAvailable(){return"undefined"!=typeof window&&!!window.ethereum}setCustomProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Invalid RPC URL");if(!t||"string"!=typeof t)throw new Error("Invalid private key");try{this.customProvider=new n.ethers.JsonRpcProvider(e),this.customWallet=new n.ethers.Wallet(t,this.customProvider),(0,a.logDebug)("Custom provider configured successfully")}catch(e){throw new Error(`Error configuring provider: ${e.message??"Unknown error"}`)}}async getSigner(){try{if(this.customWallet)return this.customWallet;if(this.provider||this.initProvider(),!this.provider)throw new Error("Provider not initialized");return await this.provider.getSigner()}catch(e){throw new Error(`Unable to get Ethereum signer: ${e.message||"Unknown error"}`)}}async getProvider(){return this.customProvider?this.customProvider:(this.provider||this.initProvider(),this.provider)}async generatePassword(e){if(!e)throw new Error("Invalid signature");return n.ethers.keccak256(n.ethers.toUtf8Bytes(e)).slice(2,66)}async verifySignature(e,t){if(!e||!t)throw new Error("Invalid message or signature");try{return n.ethers.verifyMessage(e,t)}catch(e){throw new Error("Invalid message or signature")}}async getEthereumSigner(){if(!o.isMetaMaskAvailable())throw new Error("MetaMask not found. Please install MetaMask to continue.");try{const e=window.ethereum;await e.request({method:"eth_requestAccounts"});return new n.ethers.BrowserProvider(e).getSigner()}catch(e){throw new Error(`Error accessing MetaMask: ${e.message??"Unknown error"}`)}}}t.MetaMask=o,"undefined"!=typeof window?window.MetaMask=o:void 0!==r.g&&(r.g.MetaMask=o)},7405:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RelayVerifier=t.RelayEventType=void 0,t.getRelayUrls=u,t.getRegisteredPubKeys=async function(e,t,r,n=!0){try{const i=[],s=await u(e,n);if(r&&r.length>0)for(const e of r)for(const r of s){if(await t.hasRegisteredPubKey(e,r.address)){const n=await t.getSubscriptionDetails(e,r.address);n&&n.pubKey&&i.push({relayAddress:r.address,relayUrl:r.url,pubKey:n.pubKey,userAddress:e,expires:n.expires})}}else for(const t of s)try{new a.SimpleRelay({relayAddress:t.address,registryAddress:e.getAddress(),providerUrl:void e.getAddress()})}catch(e){}const o={};for(const e of i)o[e.pubKey]||(o[e.pubKey]={pubKey:e.pubKey,relays:[]}),o[e.pubKey].relays.push({relayAddress:e.relayAddress,relayUrl:e.relayUrl,userAddress:e.userAddress,expires:e.expires});return o}catch(e){return{}}},t.getSubscriptionHistory=async function(e,t="month"){try{const e=new Date,r=[];let n;switch(t){case"day":n=24;for(let t=0;t<n;t++){const n=new Date(e);n.setHours(n.getHours()-t),r.push({date:n.toISOString(),count:Math.floor(10*Math.random())+1})}break;case"week":n=7;for(let t=0;t<n;t++){const n=new Date(e);n.setDate(n.getDate()-t),r.push({date:n.toISOString().split("T")[0],count:Math.floor(25*Math.random())+5})}break;default:n=30;for(let t=0;t<n;t++){const n=new Date(e);n.setDate(n.getDate()-t),r.push({date:n.toISOString().split("T")[0],count:Math.floor(50*Math.random())+10})}}return r.sort(((e,t)=>new Date(e.date).getTime()-new Date(t.date).getTime()))}catch(e){return[]}},t.getRelayPerformance=async function(e,t){try{if(!await e.isRegisteredRelay(t))throw new Error(`Relay ${t} non è registrato`);const r=await e.getRelayInfo(t);if(!r)throw new Error(`Impossibile ottenere informazioni per il relay ${t}`);return{uptime:r.active?5*Math.random()+95:0,responseTime:Math.floor(500*Math.random())+50,successRate:r.active?10*Math.random()+90:0,lastChecked:(new Date).toISOString()}}catch(e){return{uptime:0,responseTime:0,successRate:0,lastChecked:(new Date).toISOString()}}},t.getNetworkSummary=async function(e,t){try{const r=await e.getAllRelays(!1,0,1e3);if(!r)throw new Error("Impossibile ottenere l'elenco dei relay");let a=0;for(const t of r.relays){await e.isRelayActive(t)&&a++}const i=await t.getStatistics();n.ethers.parseEther("0");const s=n.ethers.parseEther("0.01");return{totalRelays:Number(r.total),activeRelays:a,totalSubscriptions:i?Number(i.totalSubscriptions):0,activeSubscriptions:i?.7*Number(i.totalSubscriptions):0,averagePrice:n.ethers.formatEther(s),totalProcessedAmount:i?n.ethers.formatEther(i.totalAmountProcessed):"0",totalFeesCollected:i?n.ethers.formatEther(i.totalFeesCollected):"0"}}catch(e){return{totalRelays:0,activeRelays:0,totalSubscriptions:0,activeSubscriptions:0,averagePrice:"0",totalProcessedAmount:"0",totalFeesCollected:"0"}}},t.subscribeToRelayEvents=function(e,t){c.on("relayEvent",t);const r=setInterval((()=>{const e=Object.values(l),t=e[Math.floor(Math.random()*e.length)],r={type:t,timestamp:Date.now(),relayAddress:`0x${Math.random().toString(16).substring(2,42)}`,userAddress:t.includes("Subscription")?`0x${Math.random().toString(16).substring(2,42)}`:void 0,transactionHash:`0x${Math.random().toString(16).substring(2,66)}`};c.emit("relayEvent",r)}),1e4);return()=>{clearInterval(r),c.removeListener("relayEvent",t)}},t.getUsageDataForChart=async function(e,t,r){try{const e=new Date,n=[];let a=0,i="",s="";switch(r){case"daily":a=24;break;case"weekly":a=7;break;default:a=30}for(let i=0;i<a;i++){const a=new Date(e);if("daily"===r){a.setHours(a.getHours()-i);const e=`${a.getHours()}:00`;let r=0;switch(t){case"subscriptions":r=Math.floor(15*Math.random())+1;break;case"revenue":r=.5*Math.random()+.1;break;case"users":r=Math.floor(20*Math.random())+5}n.push({label:e,value:r})}else{a.setDate(a.getDate()-i);const e=a.toISOString().split("T")[0];let r=0;switch(t){case"subscriptions":r=Math.floor(50*Math.random())+10;break;case"revenue":r=2*Math.random()+.5;break;case"users":r=Math.floor(100*Math.random())+20}n.push({label:e,value:r})}}switch(t){case"subscriptions":i="Sottoscrizioni",s="Numero di sottoscrizioni "+("daily"===r?"giornaliere":"weekly"===r?"settimanali":"mensili");break;case"revenue":i="Ricavi",s=`Ricavi ${"daily"===r?"giornalieri":"weekly"===r?"settimanali":"mensili"} in ETH`;break;case"users":i="Utenti",s="Numero di utenti attivi "+("daily"===r?"giornalieri":"weekly"===r?"settimanali":"mensili")}return{dataPoints:n.sort(((e,t)=>"daily"===r?parseInt(e.label.split(":")[0])-parseInt(t.label.split(":")[0]):new Date(e.label).getTime()-new Date(t.label).getTime())),title:i,description:s}}catch(e){return{dataPoints:[],title:"Errore",description:"Impossibile caricare i dati"}}};const n=r(4193),a=r(8777),i=r(7007),s=r(3358),o=r(5628);var l;!function(e){e.NEW_SUBSCRIPTION="newSubscription",e.SUBSCRIPTION_EXPIRED="subscriptionExpired",e.RELAY_REGISTERED="relayRegistered",e.RELAY_DEACTIVATED="relayDeactivated",e.RELAY_REACTIVATED="relayReactivated"}(l||(t.RelayEventType=l={}));const c=new i.EventEmitter;async function u(e,t=!0){try{const r=[];let n=0;const a=100;let i=!0;for(;i;){const s=await e.getAllRelays(t,n,a);if(s&&0!==s.relays.length){for(const t of s.relays){const n=await e.getRelayInfo(t);n&&n.url&&r.push({url:n.url,address:t})}n+=s.relays.length,i=n<Number(s.total)}else i=!1}return r}catch(e){return[]}}t.RelayVerifier=class{registry=null;entryPoint=null;simpleRelay=null;constructor(e,t,r){this.registry=e??null,this.entryPoint=t??null,this.simpleRelay=r??null}async isPublicKeyAuthorized(e,t){try{if(this.simpleRelay)try{if(await this.simpleRelay.isSubscribed(t))return!0}catch(e){(0,o.logError)("Error checking SimpleRelay subscription:",e)}if(this.entryPoint&&this.registry)try{const e=await this.registry.getAllRelays(!0,0,100);if(e&&e.relays&&e.relays.length>0)for(const r of e.relays){if(await this.entryPoint.isPubKeySubscribed(r,t))return!0}}catch(e){(0,o.logError)("Error checking EntryPoint subscriptions:",e)}return!1}catch(e){return s.ErrorHandler.handle(s.ErrorType.CONTRACT,"RELAY_VERIFIER_ERROR","Error in isPublicKeyAuthorized check",e),!1}}async isUserSubscribedToRelay(e,t){try{return this.simpleRelay&&this.simpleRelay.getAddress()===e?await this.simpleRelay.isSubscribed(t):!!this.entryPoint&&await this.entryPoint.isPubKeySubscribed(e,t)}catch(t){return s.ErrorHandler.handle(s.ErrorType.CONTRACT,"RELAY_VERIFIER_ERROR",`Error checking subscription to relay ${e}`,t),!1}}async getAllRelays(e=!0,t=0,r=100){try{if(!this.registry)return[];const n=await this.registry.getAllRelays(e,t,r);return n?.relays||[]}catch(e){return s.ErrorHandler.handle(s.ErrorType.CONTRACT,"RELAY_VERIFIER_ERROR","Error getting all relays",e),[]}}setRegistry(e){this.registry=e}setEntryPoint(e){this.entryPoint=e}setSimpleRelay(e){this.simpleRelay=e}}},7510:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Webauthn=void 0;const n=r(4193),a=r(3358),i=r(4134),s=r(5628),o=r(1731),l={rpName:"Shogun Wallet",timeout:6e4,userVerification:"preferred",attestation:"none",authenticatorAttachment:"platform",requireResidentKey:!1};class c extends i.EventEmitter{config;gunInstance;credential;abortController=null;constructor(e,t){super(),this.gunInstance=e,this.credential=null,this.config={...l,...t,rpId:t?.rpId??window.location.hostname.split(":")[0]}}validateUsername(e){if(!e||"string"!=typeof e)throw new Error("Username must be a non-empty string");if(e.length<3||e.length>64)throw new Error("Username must be between 3 and 64 characters");if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error("Username can only contain letters, numbers, underscores and hyphens")}async createAccount(e,t,r=!1){try{this.validateUsername(e);const n=3;let a=null;for(let i=1;i<=n;i++)try{const n=await this.generateCredentials(e,t,r);if(n.success)return this.emit(o.WebAuthnEventType.DEVICE_REGISTERED,{type:o.WebAuthnEventType.DEVICE_REGISTERED,data:{username:e,deviceInfo:n.deviceInfo},timestamp:Date.now()}),n;a=new Error(n.error??"Unknown error")}catch(e){if(a=e,i<n){await new Promise((e=>setTimeout(e,1e3*i)));continue}}throw a||new Error("Failed to create account after retries")}catch(e){throw this.emit(o.WebAuthnEventType.ERROR,{type:o.WebAuthnEventType.ERROR,data:{error:e.message},timestamp:Date.now()}),e}}async authenticateUser(e,t,r={}){try{if(this.validateUsername(e),!t){const e=new Error("No WebAuthn credentials found for this username");return a.ErrorHandler.handle(a.ErrorType.WEBAUTHN,"NO_CREDENTIALS",e.message,e),{success:!1,error:e.message}}this.abortAuthentication(),this.abortController=new AbortController;const n=r.timeout||this.config.timeout,i=setTimeout((()=>this.abortController?.abort()),n);try{const a={challenge:this.generateChallenge(e),allowCredentials:[],timeout:n,userVerification:r.userVerification||this.config.userVerification,rpId:this.config.rpId},i=await navigator.credentials.get({publicKey:a,signal:this.abortController.signal});if(!i)throw new Error("WebAuthn verification failed");const{password:s}=this.generateCredentialsFromSalt(e,t),l=this.getDeviceInfo(i.id),c={success:!0,username:e,password:s,credentialId:this.bufferToBase64(i.rawId),deviceInfo:l};return this.emit(o.WebAuthnEventType.AUTHENTICATION_SUCCESS,{type:o.WebAuthnEventType.AUTHENTICATION_SUCCESS,data:{username:e,deviceInfo:l},timestamp:Date.now()}),c}finally{clearTimeout(i),this.abortController=null}}catch(t){const r=t instanceof Error?t.message:"Unknown WebAuthn error";return this.emit(o.WebAuthnEventType.AUTHENTICATION_FAILED,{type:o.WebAuthnEventType.AUTHENTICATION_FAILED,data:{username:e,error:r},timestamp:Date.now()}),a.ErrorHandler.handle(a.ErrorType.WEBAUTHN,"AUTH_ERROR",r,t),{success:!1,error:r}}}abortAuthentication(){this.abortController&&(this.abortController.abort(),this.abortController=null)}getDeviceInfo(e){const t=this.getPlatformInfo();return{deviceId:e,timestamp:Date.now(),name:t.name,platform:t.platform,lastUsed:Date.now()}}getPlatformInfo(){if("undefined"==typeof navigator)return{name:"unknown",platform:"unknown"};const e=navigator.platform,t=navigator.userAgent;return/iPhone|iPad|iPod/.test(e)?{name:"iOS Device",platform:e}:/Android/.test(t)?{name:"Android Device",platform:e}:/Win/.test(e)?{name:"Windows Device",platform:e}:/Mac/.test(e)?{name:"Mac Device",platform:e}:/Linux/.test(e)?{name:"Linux Device",platform:e}:{name:"Unknown Device",platform:e}}generateChallenge(e){const t=Date.now().toString(),r=this.getRandomBytes(32),n=`${e}-${t}-${this.uint8ArrayToHex(r)}`;return(new TextEncoder).encode(n)}getRandomBytes(e){if("undefined"!=typeof window&&window.crypto)return window.crypto.getRandomValues(new Uint8Array(e));throw new Error("No cryptographic implementation available")}uint8ArrayToHex(e){return Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("")}bufferToBase64(e){const t=new Uint8Array(e).reduce(((e,t)=>e+String.fromCharCode(t)),"");return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}generateCredentialsFromSalt(e,t){const r=n.ethers.toUtf8Bytes(e+t);return{password:n.ethers.sha256(r)}}isSupported(){return"undefined"!=typeof window&&void 0!==window.PublicKeyCredential}async createCredential(e){try{const t=crypto.getRandomValues(new Uint8Array(32)),r=(new TextEncoder).encode(e),n={challenge:t,rp:{name:"Shogun Wallet",..."localhost"!==this.config.rpId&&{id:this.config.rpId}},user:{id:r,name:e,displayName:e},pubKeyCredParams:[{type:"public-key",alg:-7}],timeout:this.config.timeout,attestation:this.config.attestation,authenticatorSelection:{authenticatorAttachment:this.config.authenticatorAttachment,userVerification:this.config.userVerification,requireResidentKey:this.config.requireResidentKey}};(0,s.logDebug)("Attempting to create credentials with options:",n);const a=await navigator.credentials.create({publicKey:n});if(!a)throw new Error("Credential creation failed");(0,s.logDebug)("Credentials created successfully:",a);const i=a,o={id:i.id,rawId:i.rawId,type:i.type,response:{clientDataJSON:i.response.clientDataJSON},getClientExtensionResults:i.getClientExtensionResults};return"attestationObject"in i.response&&(o.response.attestationObject=i.response.attestationObject),this.credential=o,o}catch(e){(0,s.logError)("Detailed error in credential creation:",e);const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Error creating credentials: ${t}`)}}async generateCredentials(e,t,r=!1){try{if(r){const t=await this.verifyCredential(e);return{success:t.success,error:t.error,credentialId:t.credentialId,username:t.username}}{const t=await this.createCredential(e),r=t.id;let n=null;return t?.response?.getPublicKey&&(n=t.response.getPublicKey()),{success:!0,credentialId:r,publicKey:n}}}catch(e){(0,s.logError)("Error in generateCredentials:",e);return{success:!1,error:e instanceof Error?e.message:"Unknown error during WebAuthn operation"}}}async verifyCredential(e){try{const t={challenge:crypto.getRandomValues(new Uint8Array(32)),timeout:this.config.timeout,userVerification:this.config.userVerification,..."localhost"!==this.config.rpId&&{rpId:this.config.rpId}};this.credential?.rawId&&(t.allowCredentials=[{id:this.credential.rawId,type:"public-key"}]);const r=await navigator.credentials.get({publicKey:t});return r?{success:!0,credentialId:r.id,username:e}:{success:!1,error:"Credential verification failed"}}catch(e){(0,s.logError)("Error verifying credentials:",e);return{success:!1,error:e instanceof Error?e.message:"Unknown error verifying credentials"}}}async saveToGun(e,t){if(this.gunInstance)try{await this.gunInstance.get(`webauthn_${e}`).put({credentialId:t.id,type:t.type,timestamp:Date.now()})}catch(e){(0,s.logError)("Error saving credentials to Gun:",e)}}async removeDevice(e,t,r){if(!r||!r.credentials||!r.credentials[t])return{success:!1};const n={...r};return n.credentials&&delete n.credentials[t],{success:!0,updatedCredentials:n}}async sign(e){return await navigator.credentials.get({publicKey:{challenge:new Uint8Array(16),rpId:this.config.rpId}})}}t.Webauthn=c,"undefined"!=typeof window?window.Webauthn=c:void 0!==r.g&&(r.g.Webauthn=c)},8156:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunEventEmitter=t.ShogunStorage=t.Webauthn=t.Stealth=t.MetaMask=t.GunDB=t.ShogunCore=t.RelayVerifier=void 0;const s=r(4101),o=r(2077),l=r(4134),c=r(5628),u=r(3358),d=r(4643),h=r(74),g=r(409),p=r(8991),y=r(2256),w=r(3011),f=r(3411),m=i(r(9229));var E=r(7405);Object.defineProperty(t,"RelayVerifier",{enumerable:!0,get:function(){return E.RelayVerifier}}),a(r(3358),t),a(r(2077),t),a(r(5307),t),a(r(6640),t),a(r(7405),t),a(r(5349),t),a(r(8777),t);t.ShogunCore=class{static API_VERSION="2.0.0";_gun;_user=null;gundb;storage;eventEmitter;provider;config;rx;plugins=new Map;constructor(e){(0,c.log)("Initializing ShogunSDK"),this.config=e,e.logging&&((0,c.configureLogging)(e.logging),(0,c.log)("Logging configured with custom settings")),this.storage=new d.ShogunStorage,this.eventEmitter=new l.EventEmitter,u.ErrorHandler.addListener((e=>{this.eventEmitter.emit("error",{action:e.code,message:e.message,type:e.type})}));const t=e.options||{localStorage:!1,radisk:!1,wire:!0,axe:!0};if((0,c.log)("Options:",t),this.gundb=new s.GunDB(new m.default(t),e.authToken,e.scope||""),this._gun=this.gundb.gun,(0,c.log)("Initialized Gun instance"),this._user=this.gun.user().recall({sessionStorage:!0}),this.rx=new o.GunRxJS(this.gun),this.registerBuiltinPlugins(e),e.plugins?.autoRegister&&e.plugins.autoRegister.length>0)for(const t of e.plugins.autoRegister)try{this.register(t),(0,c.log)(`Auto-registered plugin: ${t.name}`)}catch(e){(0,c.logError)(`Failed to auto-register plugin ${t.name}:`,e)}(0,c.log)("ShogunSDK initialized!")}get gun(){return this._gun}get user(){return this._user}registerBuiltinPlugins(e){try{if(e.webauthn?.enabled){const e=new g.WebauthnPlugin;e._category=h.PluginCategory.Authentication,this.register(e),(0,c.log)("Webauthn plugin registered")}if(e.metamask?.enabled){const e=new p.MetaMaskPlugin;e._category=h.PluginCategory.Authentication,this.register(e),(0,c.log)("MetaMask plugin registered")}if(e.bitcoinWallet?.enabled){const e=new f.BitcoinWalletPlugin;e._category=h.PluginCategory.Authentication,this.register(e),(0,c.log)("Bitcoin wallet plugin registered")}if(e.stealth?.enabled){const e=new y.StealthPlugin;e._category=h.PluginCategory.Privacy,this.register(e),(0,c.log)("Stealth plugin registered")}if(e.walletManager?.enabled){const e=new w.WalletPlugin;e._category=h.PluginCategory.Wallet,this.register(e),(0,c.log)("Wallet plugin registered")}}catch(e){(0,c.logError)("Error registering builtin plugins:",e)}}register(e){if(this.plugins.has(e.name))throw new Error(`Plugin with name "${e.name}" already registered`);e.initialize(this),this.plugins.set(e.name,e),(0,c.log)(`Registered plugin: ${e.name}`)}unregister(e){const t=this.plugins.get(e);t?(t.destroy&&t.destroy(),this.plugins.delete(e),(0,c.log)(`Unregistered plugin: ${e}`)):(0,c.log)(`Plugin "${e}" not found, nothing to unregister`)}getPlugin(e){return this.plugins.get(e)}hasPlugin(e){return this.plugins.has(e)}getPluginsByCategory(e){const t=[];return this.plugins.forEach((r=>{r._category===e&&t.push(r)})),t}getAuthenticationMethod(e){switch(e){case"webauthn":return this.getPlugin(h.CorePlugins.WebAuthn);case"metamask":return this.getPlugin(h.CorePlugins.MetaMask);case"bitcoin":return this.getPlugin(h.CorePlugins.BitcoinWallet);default:return{login:(e,t)=>{this.login(e,t)},signUp:(e,t,r)=>{this.signUp(e,t,r)}}}}rxGet(e){return this.rx.observe(e)}match(e,t){return this.rx.match(e,t)}rxPut(e,t){return this.rx.put(e,t)}rxSet(e,t){return this.rx.set(e,t)}rxOnce(e){return this.rx.once(e)}compute(e,t){return this.rx.compute(e,t)}rxUserPut(e,t){return this.rx.userPut(e,t)}observeUser(e){return this.rx.observeUser(e)}getRecentErrors(e=10){return u.ErrorHandler.getRecentErrors(e)}configureLogging(e){(0,c.configureLogging)(e),(0,c.log)("Logging reconfigured with new settings")}isLoggedIn(){const e=this.gundb.isLoggedIn(),t=this.gun.user();if(e)return!0;const r=t&&t._&&t._.sea,n=this.storage.getItem("pair");return!!r||!!n}logout(){try{if(!this.isLoggedIn())return void(0,c.log)("Logout ignored: user not authenticated");this.gundb.logout(),this.eventEmitter.emit("auth:logout",{}),(0,c.log)("Logout completed successfully")}catch(e){u.ErrorHandler.handle(u.ErrorType.AUTHENTICATION,"LOGOUT_FAILED",e instanceof Error?e.message:"Error during logout",e)}}async login(e,t){(0,c.log)("Login");try{if((0,c.log)(`Login attempt for user: ${e}`),!e||!t)return{success:!1,error:"Username and password are required"};const r=this.config?.timeouts?.login??15e3,n=new Promise((async n=>{const a=setTimeout((()=>{n({success:!1,error:"Login timeout"})}),r);try{let r=!1,i="";try{const e=this.gun.user();if(e&&e._){const t=e._;t.sea&&(t.sea=null)}}catch(e){}if(await new Promise((n=>{this.gun.user().auth(e,t,(t=>{if(t.err)(0,c.log)(`Authentication failed: ${t.err}`),n();else{r=!0;try{const t=this.gun.user();t&&t.is&&t.is.pub&&(i=`${t.is.pub}`),(0,c.log)(`Login successful for: ${e} (${i})`)}catch(e){(0,c.log)(`Warning: Could not get user public key: ${e}`)}n()}}))})),clearTimeout(a),r){n({success:!0,userPub:i,username:e});try{const e=this.getPlugin(h.CorePlugins.WalletManager);if(e){const t=e.getMainWalletCredentials();this.storage.setItem("main-wallet",JSON.stringify(t))}}catch(e){(0,c.logError)("Error accessing wallet credentials after login:",e)}}else n({success:!1,error:"Wrong user or password"})}catch(e){clearTimeout(a),n({success:!1,error:e.message||"Login error"})}})),a=await n;return a.success&&this.eventEmitter.emit("auth:login",{userPub:a.userPub??""}),a}catch(e){return u.ErrorHandler.handle(u.ErrorType.AUTHENTICATION,"LOGIN_FAILED",e.message??"Unknown error during login",e),{success:!1,error:e.message??"Unknown error during login"}}}async signUp(e,t,r){(0,c.log)("Sign up");try{if(!e||!t)return{success:!1,error:"Username and password are required"};if(void 0!==r&&t!==r)return{success:!1,error:"Passwords do not match"};if(t.length<6)return{success:!1,error:"Password must be at least 6 characters long"};this.eventEmitter.emit("debug",{action:"signup_start",username:e,timestamp:Date.now()}),(0,c.log)(`Inizializzazione registrazione per utente: ${e}`),(0,c.log)(`Attempting user registration: ${e}`);try{let r=!1;const n=Math.random().toString(36).substring(2);if(await new Promise((t=>{try{const e=this.gun.user();if(e&&e._){const t=e._;t.sea&&(t.sea=null)}}catch(e){}this.gun.user().auth(e,n,(n=>{n.err&&("Wrong user or password"===n.err||n.err.includes("Could not decrypt"))&&(r=!0,(0,c.log)(`Username "${e}" already exists`)),t()}))})),r)return{success:!1,error:`Username "${e}" is already taken. Please choose a different username.`};const a=new Promise((r=>{try{const e=this.gun.user();if(e&&e._){const t=e._;t.sea&&(t.sea=null)}}catch(e){}this.gun.user().create(e,t,(n=>{n.err?"User already created!"===n.err?r({success:!1,error:`Username "${e}" is already taken. Please choose a different username.`}):r({success:!1,error:n.err||"Registration failed in GunDB"}):this.gun.user().auth(e,t,(t=>{if(t.err)r({success:!1,error:`User created but authentication failed: ${t.err}`});else{const t=this.gun.user(),n=t.is?.pub?`${t.is.pub}`:"";r({success:!0,userPub:n,username:e})}}))}))})),i=this.config?.timeouts?.signup??3e4,s=new Promise((t=>{setTimeout((()=>{(0,c.logError)(`Timeout at ShogunCore level during user registration: ${e}`),this.eventEmitter.emit("debug",{action:"signup_timeout",username:e,timestamp:Date.now()}),t({success:!1,error:"Registration timeout at ShogunCore level"})}),i)})),o=await Promise.race([a,s]);return o.success?((0,c.log)(`Registration completed successfully for: ${e}`),this.eventEmitter.emit("auth:signup",{userPub:o.userPub??"",username:e}),this.eventEmitter.emit("debug",{action:"signup_complete",username:e,userPub:o.userPub,timestamp:Date.now()}),o):(this.eventEmitter.emit("debug",{action:"signup_failed",username:e,error:o.error,timestamp:Date.now()}),o)}catch(t){return(0,c.logError)(`Error during registration process for user ${e}:`,t),{success:!1,error:t.message||`Registration failed: ${String(t)}`}}}catch(t){return(0,c.logError)(`Error during registration for user ${e}:`,t),this.eventEmitter.emit("debug",{action:"signup_exception",username:e,error:t.message||"Unknown error",timestamp:Date.now()}),{success:!1,error:t.message??"Unknown error during registration"}}}createUserWithGunDB(e,t){return(0,c.log)(`Ensuring user exists with GunDB: ${e}`),new Promise((async r=>{try{const n=()=>{try{if(this.gun&&this.gun.user){const e=this.gun.user();e&&void 0===e.is&&(0,c.log)("User state reset successful")}}catch(e){(0,c.log)("Error during user state reset (non-critical):",e)}},a=()=>new Promise((r=>{n(),this.gun.user().auth(e,t,(e=>{if(e.err)r({err:e.err});else{const e=this.gundb.gun.user(),t=e.is?.pub||"";e.is&&t?r({pub:t}):r({err:"Authentication failed after apparent success."})}}))})),i=()=>new Promise((r=>{n(),this.gundb.gun.user().create(e,t,(e=>{r({err:e.err,pub:e.pub})}))}));(0,c.log)(`Attempting login first for ${e}...`);let s=await a();if(s.pub)return(0,c.log)(`Login successful for existing user. Pub: ${s.pub}`),void r({success:!0,userPub:s.pub});(0,c.log)(`Login failed (${s.err??"unknown reason"}), attempting user creation...`);const o=await i();if(o.err)return(0,c.log)(`User creation error: ${o.err}`),void r({success:!1,error:`User creation failed: ${o.err}`});(0,c.log)("User created successfully, attempting login again for confirmation..."),s=await a(),s.pub?((0,c.log)(`Post-creation login successful! User pub: ${s.pub}`),r({success:!0,userPub:s.pub})):((0,c.logError)(`Post-creation login failed unexpectedly: ${s.err}`),r({success:!1,error:`User created, but subsequent login failed: ${s.err}`}))}catch(e){const t=e.message??"Unknown error during user existence check";(0,c.logError)(`Error in createUserWithGunDB: ${t}`,e),r({success:!1,error:t})}}))}get(e){return new Promise(((t,r)=>{this.gundb.gun.get(e).once((e=>{e.err?r(e.err):t(e)}))}))}put(e){return new Promise(((t,r)=>{this.gundb.gun.put(e,(e=>{e.err?r(e.err):t(e)}))}))}userPut(e){return new Promise(((t,r)=>{this.gundb.gun.user().put(e,(e=>{e.err?r(e.err):t(e)}))}))}userGet(e){return new Promise(((t,r)=>{this.gundb.gun.user().get(e).once((e=>{e.err?r(e.err):t(e)}))}))}emit(e,t){return this.eventEmitter.emit(e,t)}on(e,t){return this.eventEmitter.on(e,t),this}once(e,t){return this.eventEmitter.once(e,t),this}off(e,t){return this.eventEmitter.off(e,t),this}removeAllListeners(e){return this.eventEmitter.removeAllListeners(e),this}getAuthToken(){return this.gundb.getAuthToken()}},a(r(74),t);var b=r(4101);Object.defineProperty(t,"GunDB",{enumerable:!0,get:function(){return b.GunDB}});var v=r(7160);Object.defineProperty(t,"MetaMask",{enumerable:!0,get:function(){return v.MetaMask}});var A=r(2256);Object.defineProperty(t,"Stealth",{enumerable:!0,get:function(){return A.Stealth}});var T=r(409);Object.defineProperty(t,"Webauthn",{enumerable:!0,get:function(){return T.Webauthn}});var _=r(4643);Object.defineProperty(t,"ShogunStorage",{enumerable:!0,get:function(){return _.ShogunStorage}});var S=r(4465);Object.defineProperty(t,"ShogunEventEmitter",{enumerable:!0,get:function(){return S.ShogunEventEmitter}})},8711:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BaseContract=t.ENTRY_POINT_ABI=t.SIMPLE_RELAY_ABI=t.REGISTRY_ABI=t.RelayOperatingMode=void 0;const n=r(4193),a=r(3358),i=r(5628);t.REGISTRY_ABI=["function isRegisteredRelay(address _relayAddress) external view returns (bool)","function isRelayActive(address _relayAddress) external view returns (bool)","function findRelayByUrl(string calldata _url) external view returns (address)","function getRelayInfo(address _relayAddress) external view returns (address owner, string memory url, string memory metadata, uint256 registrationTime, bool active)","function getRelayCountByOwner(address _owner) external view returns (uint256)","function getRelaysByOwner(address _owner, uint256 _offset, uint256 _limit) external view returns (tuple(address[] relays, uint256 total, uint256 offset, uint256 limit))","function getAllRelays(bool _onlyActive, uint256 _offset, uint256 _limit) external view returns (tuple(address[] relays, uint256 total, uint256 offset, uint256 limit))","function registerRelay(address _relayAddress, string calldata _url, string calldata _metadata) external","function updateRelay(address _relayAddress, string calldata _newUrl, string calldata _newMetadata) external","function deactivateRelay(address _relayAddress) external","function reactivateRelay(address _relayAddress) external","function setRegistrationOpen(bool _isOpen) external"];t.SIMPLE_RELAY_ABI=["function isSubscriptionActive(address _user) external view returns (bool)","function getUserSubscriptionInfo(address _user) external view returns (uint256 expires, bytes memory pubKey)","function isAuthorizedByPubKey(bytes calldata _pubKey) external view returns (bool)","function isSubscribed(bytes calldata _pubKey) external view returns (bool)","function pricePerMonth() external view returns (uint256)","function daysPerMonth() external view returns (uint256)","function relayUrl() external view returns (string)","function getRelayOperationalConfig() external view returns (string memory _url, uint256 _price, uint256 _daysInMonth)","function mode() external view returns (uint8)","function registryAddress() external view returns (address)","function entryPointAddress() external view returns (address)","function isRegisteredInRegistry() external view returns (bool)","function getRelayMode() external view returns (uint8 _mode, address _registry, address _entryPoint, bool _isRegistered)","function setRegistry(address _registryAddress, bool _autoRegister, string calldata _metadata) external","function setEntryPoint(address _entryPointAddress, bool _enableProtocolMode) external","function setOperatingMode(uint8 _newMode) external","function registerInRegistry(string calldata _metadata) external","function subscribe(uint256 _months, bytes calldata _pubKey) external payable","function setPrice(uint256 _newPrice) external","function setDaysPerMonth(uint256 _days) external","function updateRelayUrl(string calldata _newUrl) external","function withdrawFunds() external","function decommissionAndWithdrawAllFunds() external","function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool success, bytes memory result)"];var s;t.ENTRY_POINT_ABI=["function registry() external view returns (address)","function serviceFeePercentage() external view returns (uint256)","function calculateFee(uint256 _amount) external view returns (uint256)","function checkSubscription(address _user, address _relayAddress) external view returns (bool)","function hasRegisteredPubKey(address _user, address _relayAddress) external view returns (bool)","function isPubKeySubscribed(address _relayAddress, bytes calldata _pubKey) external view returns (bool)","function batchCheckPubKeySubscription(address[] calldata _relayAddresses, bytes[] calldata _pubKeys) external view returns (bool[] memory)","function getSubscriptionDetails(address _user, address _relayAddress) external view returns (uint256 expires, bytes memory pubKey)","function batchCheckSubscriptions(address _user, address[] calldata _relayAddresses) external view returns (bool[] memory)","function batchCheckPubKeys(address _user, address[] calldata _relayAddresses) external view returns (bool[] memory)","function getStatistics() external view returns (uint256 _userCount, uint256 _totalSubscriptions, uint256 _totalViaUrl, uint256 _totalViaDirect, uint256 _totalAmountProcessed, uint256 _totalFeesCollected, uint256 _currentBalance)","function subscribeViaUrl(string calldata _relayUrl, uint256 _months, bytes calldata _pubKey) external payable","function subscribeDirect(address _relayAddress, uint256 _months, bytes calldata _pubKey) external payable","function batchSubscribe(address[] calldata _relayAddresses, uint256 _months, bytes[] calldata _pubKeys) external payable","function updateRegistry(address _newRegistry) external","function updateServiceFee(uint256 _newFeePercentage) external","function withdrawFees() external"],function(e){e[e.SINGLE=0]="SINGLE",e[e.PROTOCOL=1]="PROTOCOL"}(s||(t.RelayOperatingMode=s={}));t.BaseContract=class{provider=null;signer=null;contract=null;contractAddress;constructor(e,t,r){if(this.contractAddress=e,r.provider?this.provider=r.provider:r.providerUrl&&(this.provider=new n.ethers.JsonRpcProvider(r.providerUrl)),this.signer=r.signer||null,this.provider)try{this.signer?this.contract=new n.ethers.Contract(e,t,this.signer):this.contract=new n.ethers.Contract(e,t,this.provider)}catch(t){a.ErrorHandler.handle(a.ErrorType.CONTRACT,"CONTRACT_INIT_FAILED",`Failed to initialize contract at ${e}`,t)}else(0,i.logError)("No provider available for contract initialization")}setProvider(e){this.provider=e,this.contract&&(this.contract=this.contract.connect(e))}setSigner(e){this.signer=e,this.contract&&this.signer&&(this.contract=this.contract.connect(e))}getAddress(){return this.contractAddress}}},8777:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SimpleRelay=void 0;const n=r(4193),a=r(3358),i=r(8711);class s extends i.BaseContract{constructor(e){super(e.relayAddress,i.SIMPLE_RELAY_ABI,e)}async isSubscriptionActive(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.isSubscriptionActive(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_IS_SUBSCRIPTION_ACTIVE_FAILED",`Failed to check if subscription is active for user ${e}`,t),!1}}async getUserSubscriptionInfo(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");const[t,r]=await this.contract.getUserSubscriptionInfo(e),a=await this.contract.isSubscriptionActive(e);return{expires:t,pubKey:n.ethers.hexlify(r),isActive:a}}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_SUBSCRIPTION_INFO_FAILED",`Failed to get subscription info for user ${e}`,t),null}}async isAuthorizedByPubKey(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");const t=e instanceof Uint8Array?n.ethers.hexlify(e):e;return await this.contract.isAuthorizedByPubKey(t)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_IS_AUTHORIZED_FAILED","Failed to check if public key is authorized",e),!1}}async isSubscribed(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");const t=e instanceof Uint8Array?n.ethers.hexlify(e):e;return await this.contract.isSubscribed(t)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_IS_SUBSCRIBED_FAILED","Failed to check if public key is subscribed",e),!1}}async getPricePerMonth(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.pricePerMonth()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_PRICE_FAILED","Failed to get price per month",e),null}}async getDaysPerMonth(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");const e=await this.contract.daysPerMonth();return Number(e)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_DAYS_PER_MONTH_FAILED","Failed to get days per month",e),null}}async getRelayUrl(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.relayUrl()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_URL_FAILED","Failed to get relay URL",e),null}}async getRelayOperationalConfig(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");const[e,t,r]=await this.contract.getRelayOperationalConfig();return{url:e,price:t,daysInMonth:r}}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_CONFIG_FAILED","Failed to get relay operational config",e),null}}async subscribe(e,t){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");const r=t instanceof Uint8Array?n.ethers.hexlify(t):t,a=await this.contract.pricePerMonth()*BigInt(e);return await this.contract.subscribe(e,r,{value:a})}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_SUBSCRIBE_FAILED",`Failed to subscribe for ${e} months`,t),null}}async setPrice(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.setPrice(e)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_SET_PRICE_FAILED","Failed to set new price",e),null}}async setDaysPerMonth(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");if(e<1||e>31)throw new Error("Days must be between 1 and 31");return await this.contract.setDaysPerMonth(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_SET_DAYS_PER_MONTH_FAILED",`Failed to set days per month to ${e}`,t),null}}async updateRelayUrl(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.updateRelayUrl(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_UPDATE_URL_FAILED",`Failed to update URL to ${e}`,t),null}}async withdrawFunds(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.withdrawFunds()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_WITHDRAW_FUNDS_FAILED","Failed to withdraw funds",e),null}}async decommissionAndWithdrawAllFunds(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.decommissionAndWithdrawAllFunds()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_DECOMMISSION_FAILED","Failed to decommission relay",e),null}}async execute(e,t,r){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");const[a,i]=await this.contract.execute(e,t,r);return{success:a,result:n.ethers.hexlify(i)}}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_EXECUTE_FAILED",`Failed to execute transaction to ${e}`,t),null}}async getOperatingMode(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.mode()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_MODE_FAILED","Failed to get relay operating mode",e),null}}async getRegistryAddress(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.registryAddress()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_REGISTRY_ADDRESS_FAILED","Failed to get registry address",e),null}}async getEntryPointAddress(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.entryPointAddress()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_ENTRY_POINT_ADDRESS_FAILED","Failed to get entry point address",e),null}}async isRegisteredInRegistry(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");return await this.contract.isRegisteredInRegistry()}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_IS_REGISTERED_FAILED","Failed to check if relay is registered in registry",e),!1}}async getRelayMode(){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");const[e,t,r,n]=await this.contract.getRelayMode();return{mode:e,registryAddress:t,entryPointAddress:r,isRegistered:n}}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_GET_MODE_INFO_FAILED","Failed to get relay mode information",e),null}}async setRegistry(e,t=!1,r=""){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.setRegistry(e,t,r)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_SET_REGISTRY_FAILED",`Failed to set registry to ${e}`,t),null}}async setEntryPoint(e,t=!1){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.setEntryPoint(e,t)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_SET_ENTRY_POINT_FAILED",`Failed to set entry point to ${e}`,t),null}}async setOperatingMode(e){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.setOperatingMode(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_SET_MODE_FAILED",`Failed to set operating mode to ${e}`,t),null}}async registerInRegistry(e=""){try{if(!this.contract)throw new Error("SimpleRelay contract not initialized");if(!this.signer)throw new Error("Signer required for this operation");return await this.contract.registerInRegistry(e)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_REGISTER_IN_REGISTRY_FAILED","Failed to register relay in registry",e),null}}}t.SimpleRelay=s},8991:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MetaMaskPlugin=void 0;const n=r(4586),a=r(7160),i=r(5628),s=r(4193),o=r(3358);class l extends n.BasePlugin{name="metamask";version="1.0.0";description="Provides MetaMask wallet connection and authentication for ShogunCore";metamask=null;initialize(e){super.initialize(e),this.metamask=new a.MetaMask,(0,i.log)("MetaMask plugin initialized")}destroy(){this.metamask&&this.metamask.cleanup(),this.metamask=null,super.destroy(),(0,i.log)("MetaMask plugin destroyed")}assertMetaMask(){if(this.assertInitialized(),!this.metamask)throw new Error("MetaMask module not initialized");return this.metamask}isAvailable(){return this.assertMetaMask().isAvailable()}async connectMetaMask(){return this.assertMetaMask().connectMetaMask()}async generateCredentials(e){return(0,i.log)("Calling credential generation"),this.assertMetaMask().generateCredentials(e)}cleanup(){this.assertMetaMask().cleanup()}setCustomProvider(e,t){this.assertMetaMask().setCustomProvider(e,t)}async getSigner(){return this.assertMetaMask().getSigner()}async getProvider(){return this.assertMetaMask().getProvider()}async generatePassword(e){return this.assertMetaMask().generatePassword(e)}async verifySignature(e,t){return this.assertMetaMask().verifySignature(e,t)}async login(e){(0,i.log)("Login with MetaMask");try{const t=this.assertInitialized();if((0,i.log)(`MetaMask login attempt for address: ${e}`),!e)throw(0,o.createError)(o.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask login");if(!this.isAvailable())throw(0,o.createError)(o.ErrorType.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,i.log)("Generating credentials for MetaMask login...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,i.log)(`Credentials generated successfully. Username: ${r.username}`),(0,i.log)("Verifying MetaMask signature...");const n=s.ethers.verifyMessage(r.message,r.signature);if(n.toLowerCase()!==e.toLowerCase())throw(0,i.logError)(`Signature verification failed. Expected: ${e}, Got: ${n}`),(0,o.createError)(o.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,i.log)("MetaMask signature verified successfully."),(0,i.log)("Logging in using core login method...");const a=await t.login(r.username,r.password);if(!a.success)throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"METAMASK_LOGIN_FAILED",a.error||"Failed to log in with MetaMask credentials");return t.emit("auth:login",{userPub:a.userPub,username:r.username,method:"metamask"}),a}catch(e){const t=e?.type||o.ErrorType.AUTHENTICATION,r=e?.code||"METAMASK_LOGIN_ERROR",n=e?.message||"Unknown error during MetaMask login";return{success:!1,error:o.ErrorHandler.handle(t,r,n,e).message}}}async signUp(e){(0,i.log)("Sign up with MetaMask");try{const t=this.assertInitialized();if((0,i.log)(`MetaMask registration attempt for address: ${e}`),!e)throw(0,o.createError)(o.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask registration");if(!this.isAvailable())throw(0,o.createError)(o.ErrorType.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,i.log)("Generating credentials for MetaMask registration...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,i.log)(`Credentials generated successfully. Username: ${r.username}`),(0,i.log)("Verifying MetaMask signature...");const n=s.ethers.verifyMessage(r.message,r.signature);if(n.toLowerCase()!==e.toLowerCase())throw(0,i.logError)(`Signature verification failed. Expected: ${e}, Got: ${n}`),(0,o.createError)(o.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,i.log)("MetaMask signature verified successfully."),(0,i.log)("Signing up using core signUp method...");const a=await t.signUp(r.username,r.password);if(!a.success)throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"METAMASK_SIGNUP_FAILED",a.error||"Failed to sign up with MetaMask credentials");return t.emit("auth:signup",{userPub:a.userPub,username:r.username,method:"metamask"}),a}catch(e){const t=e?.type||o.ErrorType.AUTHENTICATION,r=e?.code||"METAMASK_SIGNUP_ERROR",n=e?.message||"Unknown error during MetaMask registration";return{success:!1,error:o.ErrorHandler.handle(t,r,n,e).message}}}async loginWithMetaMask(e){return this.login(e)}async signUpWithMetaMask(e){return this.signUp(e)}}t.MetaMaskPlugin=l},9148:function(e,t,r){"use strict";var n,a=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),s=0;s<r.length;s++)"default"!==r[s]&&a(t,e,r[s]);return i(t,e),t}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunCore=t.modules=void 0,t.initShogunBrowser=d;const l=r(8156);Object.defineProperty(t,"ShogunCore",{enumerable:!0,get:function(){return l.ShogunCore}});let c=null,u=null;function d(e){const t={...e};return c=new l.ShogunCore(t),u=c?.gun,"undefined"!=typeof window&&(window.shogun=c,window.shogunGun=u),c}t.modules={loadWebAuthn:()=>Promise.resolve().then((()=>s(r(409)))),loadStealth:()=>Promise.resolve().then((()=>s(r(2256)))),loadWallet:()=>Promise.resolve().then((()=>s(r(3011)))),loadMetaMask:()=>Promise.resolve().then((()=>s(r(8991))))},o(r(74),t),"undefined"!=typeof window&&(window.initShogunBrowser=d)}},r={};function n(e){var a=r[e];if(void 0!==a)return a.exports;var i=r[e]={id:e,loaded:!1,exports:{}};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}n.m=t,e=[],n.O=(t,r,a,i)=>{if(!r){var s=1/0;for(u=0;u<e.length;u++){for(var[r,a,i]=e[u],o=!0,l=0;l<r.length;l++)(!1&i||s>=i)&&Object.keys(n.O).every((e=>n.O[e](r[l])))?r.splice(l--,1):(o=!1,i<s&&(s=i));if(o){e.splice(u--,1);var c=a();void 0!==c&&(t=c)}}return t}i=i||0;for(var u=e.length;u>0&&e[u-1][2]>i;u--)e[u]=e[u-1];e[u]=[r,a,i]},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e={792:0};n.O.j=t=>0===e[t];var t=(t,r)=>{var a,i,[s,o,l]=r,c=0;if(s.some((t=>0!==e[t]))){for(a in o)n.o(o,a)&&(n.m[a]=o[a]);if(l)var u=l(n)}for(t&&t(r);c<s.length;c++)i=s[c],n.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return n.O(u)},r=this.webpackChunkShogunCore=this.webpackChunkShogunCore||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var a=n.O(void 0,[96],(()=>n(9148)));return a=(a=n.O(a)).default})()));