!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ShogunCore=t():e.ShogunCore=t()}(this,(()=>(()=>{var e,t={74:(e,t)=>{"use strict";var r,n;Object.defineProperty(t,"__esModule",{value:!0}),t.CorePlugins=t.PluginCategory=void 0,function(e){e.Authentication="authentication",e.Wallet="wallet",e.Privacy="privacy",e.Identity="identity",e.Utility="utility"}(r||(t.PluginCategory=r={})),function(e){e.WebAuthn="webauthn",e.MetaMask="metamask",e.Stealth="stealth",e.DID="did",e.WalletManager="wallet"}(n||(t.CorePlugins=n={}))},277:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(8991),t),i(r(3408),t),i(r(7160),t)},348:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthAddresses=t.Stealth=void 0;const i=r(4193),a=r(4643),s=n(r(8030));class o{STEALTH_DATA_TABLE;storage;gun;logs=[];constructor(e,t){this.STEALTH_DATA_TABLE="Stealth",this.storage=t||new a.ShogunStorage,this.gun=e}log(e,t,r){const n={timestamp:(new Date).toISOString(),level:e,message:t,data:r};this.logs.push(n)}async cleanupSensitiveData(){try{this.logs=[],this.log("info","Sensitive data cleanup completed")}catch(e){throw this.log("error","Error during cleanup",e),e}}async getStealthKeys(){const e=await this.assertStealth().getStealthKeys();return{spendingKey:e.spendingKey,viewingKey:e.viewingKey}}async generateAndSaveKeys(e){const t=this.gun.user().get("stealth").get("viewingKey").once(),r=this.gun.user().get("stealth").get("spendingKey").once();if(t||r)return;const n=await this.createAccount(),i=await this.createAccount();let a;a=e?await this.gun.user().auth(e):this.gun.user();const o=await s.default.encrypt(i,a()._.sea),l=await s.default.encrypt(n,a()._.sea);this.gun.user().get("stealth").get("viewingKey").put(o),this.gun.user().get("stealth").get("spendingKey").put(l),this.log("info","Stealth keys generated and saved for address",e?.pub||a?.is?.alias)}formatPublicKey(e){if(!e)return null;const t=e.trim();return t&&/^[~]?[\w+/=\-_.]+$/.test(t)?t.startsWith("~")?t.slice(1):t:null}async createAccount(){const e=await this.assertStealth().createAccount();return{privateKey:e.privateKey,publicKey:e.publicKey}}async generateStealthAddress(e,t){return this.assertStealth().generateStealthAddress(e,t)}async openStealthAddress(e,t,r,n,i){return this.assertStealth().openStealthAddress(e,t,r,n,i)}async getPublicKey(e){return this.formatPublicKey(e)}deriveWalletFromSecret(e){const t=i.ethers.keccak256(i.ethers.toUtf8Bytes(e));return new i.ethers.Wallet(t)}generateStealthKeys(){return{scanning:this.createAccount(),spending:this.createAccount()}}verifyStealthAddress(e,t,r,n){return!0}assertStealth(){if(!this.gun.user())throw new Error("Stealth not initialized");return this}}t.Stealth=o,t.StealthAddresses=o,"undefined"!=typeof window?window.Stealth=o:void 0!==r.g&&(r.g.Stealth=o),t.default=o},409:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Webauthn:()=>n,default:()=>i});class n{constructor(){}isSupported(){return!1}validateUsername(){throw new Error("WebAuthn functionality disabled in light version")}async createAccount(){throw new Error("WebAuthn functionality disabled in light version")}async authenticateUser(){throw new Error("WebAuthn functionality disabled in light version")}async sign(){throw new Error("WebAuthn functionality disabled in light version")}}const i=n},723:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OracleBridge=void 0;const n=r(4193),i=r(3358),a=r(5628),s=["function roots(uint256) public view returns (bytes32)","function admin() public view returns (address)","function epochId() public view returns (uint256)","function getEpochId() external view returns (uint256)","function publishRoot(uint256 _epochId, bytes32 root) external"];t.OracleBridge=class{contract=null;provider=null;signer=null;contractAddress;shogun;constructor(e,t,r){this.contractAddress=e.contractAddress,this.shogun=t,this.signer=r||null;try{t?.provider?(this.provider=t.provider,(0,a.log)("Using provider from ShogunCore instance")):e.providerUrl?(this.provider=new n.ethers.JsonRpcProvider(e.providerUrl),(0,a.log)(`Created provider with URL: ${e.providerUrl}`)):(0,a.logError)("No provider available. Either pass a ShogunCore instance or providerUrl"),this.signer&&this.provider?(this.contract=new n.ethers.Contract(this.contractAddress,s,this.signer),(0,a.log)(`OracleBridge initialized with signer at ${this.contractAddress}`)):this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.provider),(0,a.log)(`OracleBridge initialized in read-only mode at ${this.contractAddress}`))}catch(e){i.ErrorHandler.handle(i.ErrorType.CONTRACT,"ORACLE_BRIDGE_INIT_FAILED","Failed to initialize OracleBridge",e)}}async getEpochId(){try{if(!this.contract)throw new Error("Contract not initialized");return await this.contract.getFunction("getEpochId")()}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"GET_EPOCH_ID_FAILED","Failed to get current epoch ID",e),BigInt(0)}}async getRootForEpoch(e){try{if(!this.contract)throw new Error("Contract not initialized");return await this.contract.getFunction("roots")(e)}catch(t){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"GET_ROOT_FAILED",`Failed to get root for epoch ${e}`,t),n.ethers.ZeroHash}}async getAdmin(){try{if(!this.contract)throw new Error("Contract not initialized");return await this.contract.getFunction("admin")()}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"GET_ADMIN_FAILED","Failed to get admin address",e),n.ethers.ZeroAddress}}async verifyRoot(e,t){try{return(await this.getRootForEpoch(e)).toLowerCase()===t.toLowerCase()}catch(t){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"VERIFY_ROOT_FAILED",`Failed to verify root for epoch ${e}`,t),!1}}async publishRoot(e,t,r){try{if(!this.contract)throw new Error("Contract not initialized");const n=r||this.signer;if(!n)throw new Error("No signer available. Please provide a signer or set one with setSigner()");const i=this.contract.connect(n),a=await n.getAddress(),s=await this.getAdmin();if(a.toLowerCase()!==s.toLowerCase())throw new Error("Only admin can publish roots");const o=await i.getFunction("publishRoot")(e,t);return await o.wait()}catch(t){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"PUBLISH_ROOT_FAILED",`Failed to publish root for epoch ${e}`,t),null}}setSigner(e){this.signer=e,(0,a.log)("Signer set for OracleBridge")}setProviderUrl(e){try{return this.provider=new n.ethers.JsonRpcProvider(e),!!this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.provider),(0,a.log)(`Updated provider URL to ${e}`),!0)}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"PROVIDER_UPDATE_FAILED","Failed to update provider URL",e),!1}}setContractAddress(e){try{if(!n.ethers.isAddress(e))throw new Error("Invalid contract address format");return this.contractAddress=e,!!this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.provider),(0,a.log)(`Updated contract address to ${e}`),!0)}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"CONTRACT_ADDRESS_UPDATE_FAILED","Failed to update contract address",e),!1}}}},1024:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.qs=t.getSet=t.getUUID=t.getTargetPub=t.getPub=t.getId=void 0;t.getId=e=>e?._?.["#"];t.getPub=e=>{const t=/~([^@][^\.]+\.[^\.]+)/.exec(e);return t?t[1]:null};t.getTargetPub=e=>{const t=/~[^@][^\.]+\.[^\.]+.*~([^@][^\.]+\.[^\.]+)$/.exec(e);return t?t[1]:null};t.getUUID=e=>e.opt()._.opt.uuid();t.getSet=(e,t)=>{const r=e[t];return r?Object.keys(r).filter((e=>"_"!==e)).map((e=>r[e])).filter((e=>e&&"object"==typeof e&&e["#"])).map((t=>e[t["#"]])).filter(Boolean):[]};t.qs=(e,t="?")=>{const r=Object.fromEntries(Object.entries(e).filter((([e,t])=>t))),n=JSON.stringify(r);return n?`${t}${n}`:""}},1318:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OracleBridge=t.DIDVerifier=t.RelayMembershipVerifier=void 0;var n=r(3401);Object.defineProperty(t,"RelayMembershipVerifier",{enumerable:!0,get:function(){return n.RelayMembershipVerifier}});var i=r(9662);Object.defineProperty(t,"DIDVerifier",{enumerable:!0,get:function(){return i.DIDVerifier}});var a=r(723);Object.defineProperty(t,"OracleBridge",{enumerable:!0,get:function(){return a.OracleBridge}})},1731:(e,t)=>{"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WebAuthnEventType=void 0,function(e){e.DEVICE_REGISTERED="deviceRegistered",e.DEVICE_REMOVED="deviceRemoved",e.AUTHENTICATION_SUCCESS="authenticationSuccess",e.AUTHENTICATION_FAILED="authenticationFailed",e.ERROR="error"}(r||(t.WebAuthnEventType=r={}))},2115:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=void 0;const n=r(4586),i=r(348),a=r(5628);class s extends n.BasePlugin{name="stealth";version="1.0.0";description="Provides stealth address functionality for ShogunCore";stealth=null;initialize(e){if(super.initialize(e),!e.storage)throw new Error("Storage dependency not available in core");if(!e.gun)throw new Error("Gun dependency not available in core");this.stealth=new i.Stealth(e.gun,e.storage),(0,a.log)("Stealth plugin initialized")}destroy(){this.stealth=null,super.destroy(),(0,a.log)("Stealth plugin destroyed")}assertStealth(){if(this.assertInitialized(),!this.stealth)throw new Error("Stealth module not initialized");return this.stealth}async generateEphemeralKeyPair(){return this.assertStealth().createAccount()}async generateStealthAddress(e,t){return this.assertStealth().generateStealthAddress(e,t)}async scanStealthAddresses(e,t){return Promise.resolve([])}async isStealthAddressMine(e,t){return Promise.resolve(!1)}async getStealthPrivateKey(e,t){return Promise.resolve("0x"+"0".repeat(64))}async openStealthAddress(e,t,r){const n=await this.getStealthKeys(),i={pub:n.viewingKey,priv:n.viewingKey,epub:n.viewingKey,epriv:n.viewingKey},a={pub:n.spendingKey,priv:n.spendingKey,epub:n.spendingKey,epriv:n.spendingKey};return this.assertStealth().openStealthAddress(e,t,r,a,i)}async getStealthKeys(){return this.assertStealth().getStealthKeys()}}t.StealthPlugin=s},2256:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Stealth:()=>n,default:()=>i});class n{constructor(){}formatPublicKey(){throw new Error("Stealth functionality disabled in light version")}async createAccount(){throw new Error("Stealth functionality disabled in light version")}async generateStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async openStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async getPublicKey(){throw new Error("Stealth functionality disabled in light version")}prepareStealthKeysForSaving(){throw new Error("Stealth functionality disabled in light version")}deriveWalletFromSecret(){throw new Error("Stealth functionality disabled in light version")}}const i=n},2317:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.WalletManager=void 0;const i=r(5628),a=n(r(8030)),s=r(4193),o=r(4134),l=r(3512);class c extends o.EventEmitter{gun;storage;walletPaths={};mainWallet=null;balanceCache=new Map;pendingTransactions=new Map;config;transactionMonitoringInterval=null;provider=null;signer=null;constructor(e,t,r){super(),this.gun=e,this.storage=t,this.config={balanceCacheTTL:3e4,rpcUrl:"",defaultGasLimit:21e3,maxRetries:3,retryDelay:1e3,...r},this.initWalletPathsSync(),this.setupTransactionMonitoring()}initWalletPathsSync(){try{this.walletPaths={},this.loadWalletPathsFromLocalStorage(),(0,i.log)("Wallet paths initialized synchronously. Async loading will occur on first use.")}catch(e){(0,i.logError)("Error in synchronous wallet path initialization:",e),(0,i.log)("Will attempt async initialization on first use")}}async initializeWalletPaths(){try{this.walletPaths={},await this.loadWalletPathsFromGun(),this.loadWalletPathsFromLocalStorage();const e=Object.keys(this.walletPaths).length;0===e?(0,i.log)("No wallet paths found, new wallets will be created when needed"):(0,i.log)(`Initialized ${e} wallet paths`)}catch(e){throw(0,i.logError)("Error initializing wallet paths:",e),new Error(`Failed to initialize wallet paths: ${e instanceof Error?e.message:String(e)}`)}}loadWalletPathsFromLocalStorage(){const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=this.storage.getItem(e);if(t)try{(0,i.log)("Found wallet paths in localStorage");const e=JSON.parse(t);Object.entries(e).forEach((([e,t])=>{this.walletPaths[e]||(this.walletPaths[e]=t,(0,i.log)(`Loaded path from localStorage for wallet: ${e}`))}))}catch(e){(0,i.logError)("Error parsing wallet paths from localStorage:",e)}}async loadWalletPathsFromGun(){const e=this.gun.user();return e?.is?((0,i.log)(`Loading wallet paths from GUN for user: ${e.is.alias}`),new Promise((t=>{e.get("wallet_paths").once((e=>{if(!e)return(0,i.log)("No wallet paths found in GUN"),void t();(0,i.log)(`Found wallet paths in GUN: ${Object.keys(e).length-1} wallets`),Object.entries(e).forEach((([e,t])=>{if("_"!==e&&t){const r=t;r?.path&&(this.walletPaths[e]={path:r.path,created:r.created||Date.now()},(0,i.log)(`Loaded path for wallet: ${e} -> ${r.path}`))}})),t()}))}))):((0,i.log)("User not authenticated on Gun, cannot load wallet paths from Gun"),Promise.resolve())}setupTransactionMonitoring(){this.transactionMonitoringInterval=setInterval((()=>{null!==this.getProvider()&&this.checkPendingTransactions()}),15e3)}cleanup(){this.transactionMonitoringInterval&&(clearInterval(this.transactionMonitoringInterval),this.transactionMonitoringInterval=null);"undefined"!=typeof window?window:r.g;const e=Number(setTimeout((()=>{}),0));for(let t=0;t<e;t++)clearTimeout(t),clearInterval(t)}async checkPendingTransactions(){const e=this.getProvider();if(e)for(const[t,r]of this.pendingTransactions.entries())try{const n=await e.getTransactionReceipt(t);n&&(1===n.status?(r&&"object"==typeof r&&(r.status="success"),this.emit(l.WalletEventType.TRANSACTION_CONFIRMED,{type:l.WalletEventType.TRANSACTION_CONFIRMED,data:{txHash:t,receipt:n},timestamp:Date.now()})):(r&&"object"==typeof r&&(r.status="failed"),this.emit(l.WalletEventType.ERROR,{type:l.WalletEventType.ERROR,data:{txHash:t,error:"Transaction failed"},timestamp:Date.now()})),this.pendingTransactions.delete(t),this.invalidateBalanceCache(r.from),r.to&&this.invalidateBalanceCache(r.to))}catch(e){(0,i.logError)(`Error checking transaction ${t}:`,e)}else(0,i.logWarn)("Provider non disponibile, impossibile controllare transazioni pendenti")}setRpcUrl(e){this.config.rpcUrl=e,(0,i.log)(`RPC Provider configured: ${e}`),this.provider||(this.provider=new s.ethers.JsonRpcProvider(e)),this.signer=this.getSigner()}getProvider(){return this.provider}getSigner(){const e=this.getMainWallet();if(!this.provider)throw new Error("Provider not available");return e.connect(this.provider)}setSigner(e){if(!this.config.rpcUrl)throw new Error("RPC URL not configured");const t=new s.ethers.JsonRpcProvider(this.config.rpcUrl);this.signer=e.connect(t)}getStorageUserIdentifier(){const e=this.gun.user(),t=e?.is?.pub;return t?t.substring(0,12):"guest"}saveWalletPathsToLocalStorage(){try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=JSON.stringify(this.walletPaths);this.storage.setItem(e,t),(0,i.log)(`Saved ${Object.keys(this.walletPaths).length} wallet paths to localStorage`)}catch(e){(0,i.logError)("Error saving wallet paths to localStorage:",e)}}derivePrivateKeyFromMnemonic(e,t){try{(0,i.log)(`Deriving wallet from path: ${t}`);const r=s.ethers.HDNodeWallet.fromMnemonic(s.ethers.Mnemonic.fromPhrase(e),t);if(!r||!r.privateKey)throw new Error(`Unable to derive wallet for path ${t}`);return r}catch(e){throw(0,i.logError)(`Error deriving wallet for path ${t}:`,e),new Error(`Unable to derive wallet for path ${t}`)}}generateNewMnemonic(){try{0;const e=s.ethers.Wallet.createRandom();if(e.mnemonic&&e.mnemonic.phrase)return e.mnemonic.phrase;throw new Error("Mnemonic non generato correttamente")}catch(e){return(0,i.logError)("Errore durante la generazione del mnemonic:",e),"casa gatto cane topo elefante leone tigre orso scimmia panda zebra giraffa"}}getStandardBIP44Addresses(e,t=5){try{(0,i.log)("Standard BIP-44 derivation from mnemonic");const r=[];for(let n=0;n<t;n++){const t=`m/44'/60'/0'/0/${n}`,a=s.ethers.HDNodeWallet.fromMnemonic(s.ethers.Mnemonic.fromPhrase(e),t);r.push(a.address),(0,i.log)(`Address ${n}: ${a.address} (${t})`)}return r}catch(e){return(0,i.log)(`Error calculating BIP-44 addresses: ${e}`),[]}}generatePrivateKeyFromString(e){try{const t=(new TextEncoder).encode(e),r=e=>{let t=3735928559,r=1103547991;for(let n=0;n<e.length;n++)t=Math.imul(t^e[n],2654435761),r=Math.imul(r^e[n],1597334677);t=Math.imul(t^t>>>16,2246822507),t=Math.imul(t^t>>>13,3266489909),r=Math.imul(r^r>>>16,2246822507),r=Math.imul(r^r>>>13,3266489909);const n=new Uint8Array(32);for(let e=0;e<4;e++)n[e]=t>>8*e&255;for(let e=0;e<4;e++)n[e+4]=r>>8*e&255;for(let e=8;e<32;e++)n[e]=255&(n[e%8]^n[(e-1)%8]);return n},n=r(t);return"0x"+Array.from(n).map((e=>e.toString(16).padStart(2,"0"))).join("")}catch(e){(0,i.logError)("Error generating private key:",e);return"0x"+Array.from({length:32}).map((()=>Math.floor(256*Math.random()).toString(16).padStart(2,"0"))).join("")}}getMainWallet(){try{if(!this.mainWallet){const e=this.gun.user();if(!e||!e.is)throw(0,i.log)("getMainWallet: User not authenticated"),new Error("User not authenticated");if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub))throw(0,i.log)("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),new Error("Insufficient user data to generate wallet");const t=e._.sea.priv,r=e._.sea.pub,n=`${t}|${r}|${e.is.alias}`,a=this.generatePrivateKeyFromString(n);this.mainWallet=new s.ethers.Wallet(a)}return this.mainWallet}catch(e){throw(0,i.logError)("Error retrieving main wallet:",e),e}}getMainWalletCredentials(){const e=this.gun.user().recall({sessionStorage:!0});if(!e||!e.is)throw(0,i.log)("getMainWallet: User not authenticated"),new Error("User not authenticated");if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub))throw(0,i.log)("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),new Error("Insufficient user data to generate wallet");const t=`${e._.sea.priv}|${e._.sea.pub}|${e.is.alias}`,r=this.generatePrivateKeyFromString(t);return this.mainWallet=new s.ethers.Wallet(r),{address:this.mainWallet.address,priv:r}}async encryptSensitiveData(e){try{const t=this.gun.user();if(t&&t._&&t._.sea){const r=await a.default.encrypt(e,t._.sea);return JSON.stringify(r)}{const t=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`,r=await a.default.encrypt(e,t);return JSON.stringify(r)}}catch(t){return(0,i.logError)("Error encrypting data:",t),(0,i.log)("WARNING: Sensitive data saved without encryption"),`unencrypted:${e}`}}async decryptSensitiveData(e){try{if(e.startsWith("unencrypted:"))return e.substring(12);const t=JSON.parse(e),r=this.gun.user();if(r&&r._&&r._.sea){return await a.default.decrypt(t,r._.sea)}{const e=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`;return await a.default.decrypt(t,e)}}catch(e){return(0,i.logError)("Error decrypting data:",e),null}}async getUserMasterMnemonic(){try{const e=this.gun.user();if(e&&e.is){const t=await new Promise((t=>{e.get("master_mnemonic").once((e=>{t(e||null)}))}));if(t){(0,i.log)("Mnemonic retrieved from GunDB"),(0,i.log)("gunMnemonic: ",t);return await this.decryptSensitiveData(t)}}const t=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,r=this.storage.getItem(t);if(!r)return(0,i.log)("No mnemonic found in either GunDB or localStorage"),null;const n=await this.decryptSensitiveData(r);return(0,i.log)("Mnemonic retrieved from localStorage"),n&&e&&e.is&&(await e.get("master_mnemonic").put(n),(0,i.log)("Mnemonic from localStorage synced to GunDB")),n}catch(e){return(0,i.logError)("Error retrieving mnemonic:",e),null}}async saveUserMasterMnemonic(e){try{const t=this.gun.user();if(t&&t.is){0;const r=await this.encryptSensitiveData(e);await t.get("master_mnemonic").put(r),(0,i.log)("Mnemonic saved to GunDB")}const r=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,n=await this.encryptSensitiveData(e);this.storage.setItem(r,n),(0,i.log)("Encrypted mnemonic also saved to localStorage as backup")}catch(e){throw(0,i.logError)("Error saving mnemonic:",e),e}}async createWallet(){try{const e=this.gun.user();if(!e.is)throw new Error("User is not authenticated");const t=Object.values(this.walletPaths).length,r=`m/44'/60'/0'/0/${t}`;let n,a=await this.getUserMasterMnemonic();if(!a)try{a=this.generateNewMnemonic(),await this.saveUserMasterMnemonic(a),(0,i.log)(`Generated new mnemonic: ${a}`)}catch(e){throw new Error(`Failed to generate or save mnemonic: ${e instanceof Error?e.message:String(e)}`)}(0,i.log)("*** masterMnemonic: ",a);try{n=this.derivePrivateKeyFromMnemonic(a,r),(0,i.log)(`Derived wallet for path ${r} with address ${n.address}`)}catch(e){throw new Error(`Failed to derive wallet: ${e instanceof Error?e.message:String(e)}`)}const s=Date.now();this.walletPaths[n.address]={path:r,created:s};try{const t=e.get("wallet_paths");await t.put({[n.address]:{path:r,created:s}}),this.saveWalletPathsToLocalStorage()}catch(e){(0,i.logError)("Error saving wallet path:",e),(0,i.log)("Wallet created but path might not be persisted properly")}return{wallet:n,path:r,address:n.address,getAddressString:()=>n.address}}catch(e){throw(0,i.logError)("Error creating wallet:",e),new Error(`Failed to create wallet: ${e instanceof Error?e.message:String(e)}`)}}async loadWallets(){try{if(!this.gun.user())throw(0,i.logError)("loadWallets: No Gun user available"),new Error("Gun user not available");try{await this.initializeWalletPaths()}catch(e){(0,i.logError)("Error initializing wallet paths, proceeding with available wallets:",e),(0,i.log)("Will attempt to continue with any available wallet data")}let e=await this.getUserMasterMnemonic();if(!e){(0,i.log)("No mnemonic found, creating default wallet...");return[await this.createWallet()]}(0,i.log)(`masterMnemonic found: ${e}`);const t=[];for(const[r,n]of Object.entries(this.walletPaths))try{const a=this.derivePrivateKeyFromMnemonic(e,n.path||`m/44'/60'/0'/0/${r.substring(0,6)}`);(0,i.log)(`Derived wallet for path ${n.path||"fallback"} with address ${a.address}`),a.address.toLowerCase()!==r.toLowerCase()&&(0,i.logWarn)(`Warning: derived address (${a.address}) does not match saved address (${r})`),t.push({wallet:a,path:n.path||`m/44'/60'/0'/0/${a.address.substring(0,8)}`,address:a.address,getAddressString:()=>a.address})}catch(e){(0,i.logError)(`Error deriving wallet ${r}:`,e)}return t.length>0&&(this.mainWallet=t[0].wallet),t}catch(e){throw(0,i.logError)("Error loading wallets:",e),new Error(`Failed to load wallets: ${e instanceof Error?e.message:String(e)}`)}}async getBalance(e){try{const t=e.address,r=Date.now(),n=this.balanceCache.get(t);if(n&&r-n.timestamp<this.config.balanceCacheTTL)return n.balance;const i=this.getProvider();if(!i)throw new Error("Provider non disponibile. Imposta prima un RPC URL con setRpcUrl()");const a=await i.getBalance(t),o=s.ethers.formatEther(a);return this.balanceCache.set(t,{balance:o,timestamp:r}),this.emit(l.WalletEventType.BALANCE_UPDATED,{type:l.WalletEventType.BALANCE_UPDATED,data:{address:t,balance:o},timestamp:r}),o}catch(e){return(0,i.logError)("Error getting balance:",e),"0.0"}}invalidateBalanceCache(e){this.balanceCache.delete(e),(0,i.log)(`Balance cache invalidated for ${e}`)}async getNonce(e){const t=this.getProvider();if(!t)throw new Error("Provider non inizializzato. Chiamare setRpcUrl prima");return await t.getTransactionCount(e.address)}async sendTransaction(e,t,r,n={}){try{const i=this.getProvider();if(!i)throw new Error("Provider not available");e=e.connect(i);const a=await i.getFeeData(),o={to:t,value:s.ethers.parseEther(r),gasLimit:n.gasLimit||this.config.defaultGasLimit,nonce:n.nonce||await i.getTransactionCount(e.address),maxFeePerGas:n.maxFeePerGas?s.ethers.parseUnits(n.maxFeePerGas,"gwei"):a.maxFeePerGas,maxPriorityFeePerGas:n.maxPriorityFeePerGas?s.ethers.parseUnits(n.maxPriorityFeePerGas,"gwei"):a.maxPriorityFeePerGas};for(let t=1;t<=(this.config.maxRetries||3);t++)try{const t=await e.sendTransaction(o);return this.pendingTransactions.set(t.hash,t),this.emit(l.WalletEventType.TRANSACTION_SENT,{type:l.WalletEventType.TRANSACTION_SENT,data:{txHash:t.hash,tx:o},timestamp:Date.now()}),t.hash}catch(r){if(t===this.config.maxRetries)throw r;await new Promise((e=>setTimeout(e,this.config.retryDelay))),o.nonce=await i.getTransactionCount(e.address);const n=await i.getFeeData();o.maxFeePerGas=n.maxFeePerGas,o.maxPriorityFeePerGas=n.maxPriorityFeePerGas}throw new Error("Transaction failed after all retry attempts")}catch(t){throw(0,i.logError)("Error sending transaction:",t),this.emit(l.WalletEventType.ERROR,{type:l.WalletEventType.ERROR,data:{error:t,wallet:e.address},timestamp:Date.now()}),t}}async signMessage(e,t){try{return await e.signMessage(t)}catch(e){throw(0,i.logError)("Error signing message:",e),e}}verifySignature(e,t){return s.ethers.verifyMessage(e,t)}async signTransaction(e,t,r,n){try{(0,i.log)(`Signing transaction from wallet ${e.address} to ${t} for ${r} ETH`);const a=n||this.getProvider();if(!a)throw new Error("Provider not available");const o=await a.getTransactionCount(e.address);(0,i.log)(`Nonce for transaction: ${o}`);const l=await a.getFeeData(),c={nonce:o,to:t,value:s.ethers.parseEther(r),gasPrice:l.gasPrice,gasLimit:21e3},u=await e.signTransaction(c);return(0,i.log)("Transaction signed successfully"),u}catch(e){throw(0,i.logError)("Error signing transaction:",e),e}}resetMainWallet(){(0,i.log)("Resetting main wallet"),this.mainWallet=null}async exportMnemonic(e){try{(0,i.log)("⚠️ SECURITY WARNING: Exporting mnemonic phrase - handle with extreme care!");const t=await this.getUserMasterMnemonic();if(!t)throw new Error("No mnemonic available for this user");return e?this.encryptSensitiveData(t):t}catch(e){throw(0,i.logError)("Error exporting mnemonic:",e),e}}async exportWalletKeys(e){try{if((0,i.log)("⚠️ SECURITY WARNING: Exporting wallet private keys - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export wallet keys");const t=await this.loadWallets();if(0===t.length)throw new Error("No wallets found to export");const r=t.map((e=>{const t=e.wallet;return{address:t.address,privateKey:t.privateKey,path:e.path,created:this.walletPaths[t.address]?.created||Date.now()}})),n=JSON.stringify(r);return e?this.encryptSensitiveData(n):n}catch(e){throw(0,i.logError)("Error exporting wallet keys:",e),e}}async exportGunPair(e){try{if((0,i.log)("⚠️ SECURITY WARNING: Exporting GunDB pair - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export GunDB pair");const t=this.gun.user()._.sea;if(!t)throw new Error("No GunDB pair available for this user");const r=JSON.stringify(t);return e?this.encryptSensitiveData(r):r}catch(e){throw(0,i.logError)("Error exporting GunDB pair:",e),e}}async exportAllUserData(e){if(!e)throw new Error("È richiesta una password per esportare tutti i dati");try{const t=await this.getUserMasterMnemonic(),r=await this.loadWallets(),n=this.gun.user();if(!n||!n._||!n._.sea)throw new Error("Utente non autenticato o dati non disponibili");const i=r.map((e=>{const t=e.address||"";return{address:t,privateKey:e.wallet.privateKey,path:e.path,created:t&&this.walletPaths[t]?.created||Date.now()}})),s={user:{alias:n.is.alias,pub:n.is.pub,pair:n._.sea},mnemonic:t,wallets:i,version:"1.0",exportedAt:(new Date).toISOString(),appName:"Shogun Wallet"},o=await a.default.encrypt(JSON.stringify(s),e);return JSON.stringify({type:"encrypted-shogun-backup",data:o,version:"1.0"})}catch(e){throw(0,i.logError)("Errore nell'esportazione di tutti i dati utente:",e),e}}async importMnemonic(e,t){try{let r=e;if(e.startsWith("{"))try{const n=JSON.parse(e);if("encrypted-mnemonic"===n.type&&n.data&&t){const e=await a.default.decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=e}else n.mnemonic&&(r=n.mnemonic)}catch(e){throw new Error("Formato JSON non valido o password errata")}try{s.ethers.Mnemonic.fromPhrase(r)}catch(e){throw new Error("La mnemonica fornita non è valida")}const n=this.gun.user();if(!n||!n.is)throw new Error("L'utente deve essere autenticato per importare una mnemonica");(0,i.log)("Cancellazione dei wallet path esistenti prima dell'importazione della nuova mnemonica");try{await n.get("wallet_paths").put(null),(0,i.log)("Wallet path eliminati da Gun con successo")}catch(e){(0,i.logError)("Errore durante la cancellazione dei wallet path da Gun:",e)}try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`;this.storage.removeItem(e),(0,i.log)("Wallet path eliminati da localStorage con successo")}catch(e){(0,i.logError)("Errore durante la cancellazione dei wallet path da localStorage:",e)}return this.walletPaths={},await this.saveUserMasterMnemonic(r),(0,i.log)("Nuova mnemonica salvata con successo"),this.resetMainWallet(),await this.createWallet(),(0,i.log)("Generato nuovo wallet con la mnemonica importata"),!0}catch(e){throw(0,i.logError)("Errore nell'importazione della mnemonica:",e),e}}async importWalletKeys(e,t){try{let r=[];(0,i.log)(`[importWalletKeys] Tentativo di importazione wallet, lunghezza dati: ${e.length} caratteri`),e.length>100?(0,i.log)(`[importWalletKeys] Primi 100 caratteri: ${e.substring(0,100)}...`):(0,i.log)(`[importWalletKeys] Dati completi: ${e}`),e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(e.startsWith("{")||e.startsWith("[")){const n=JSON.parse(e);if((0,i.log)(`[importWalletKeys] JSON parsificato con successo, tipo: ${typeof n}, chiavi: ${Object.keys(n).join(", ")}`),"encrypted-wallets"===n.type&&n.data&&t){(0,i.log)("[importWalletKeys] Trovati dati cifrati, tentativo di decifratura...");try{const e=await a.default.decrypt(n.data,t);if(!e)throw(0,i.log)("[importWalletKeys] Decifratura fallita: risultato null"),new Error("Password non valida o dati corrotti");(0,i.log)("[importWalletKeys] Decifratura riuscita, tentativo di parsing..."),(0,i.log)("[importWalletKeys] Tipo dei dati decifrati:",typeof e),"string"==typeof e&&e.length>50&&(0,i.log)("[importWalletKeys] Primi 50 caratteri decifrati:",e.substring(0,50));try{const t=JSON.parse(e);if((0,i.log)("[importWalletKeys] Parsing riuscito, struttura:",Object.keys(t).join(", ")),t.wallets&&Array.isArray(t.wallets))r=t.wallets,(0,i.log)(`[importWalletKeys] Trovati ${r.length} wallet nei dati decifrati`);else{if(!Array.isArray(t))throw(0,i.log)("[importWalletKeys] Formato JSON decifrato non valido:",t),new Error("Formato JSON decifrato non valido: manca il campo 'wallets'");r=t,(0,i.log)(`[importWalletKeys] Trovato array diretto di ${r.length} wallet nei dati decifrati`)}}catch(e){throw(0,i.logError)(`[importWalletKeys] Errore nel parsing dei dati decifrati: ${e}`),new Error("Formato JSON decifrato non valido")}}catch(e){throw(0,i.logError)("[importWalletKeys] Errore durante la decifratura:",e),new Error(`Errore durante la decifratura: ${e.message||String(e)}`)}}else if(n.wallets){if(!Array.isArray(n.wallets))throw(0,i.log)("[importWalletKeys] Il campo wallets non è un array:",n.wallets),new Error("Formato JSON non valido: il campo 'wallets' non è un array");r=n.wallets,(0,i.log)(`[importWalletKeys] Trovati ${r.length} wallet nel JSON non cifrato`)}else{if(!Array.isArray(n))throw(0,i.log)("[importWalletKeys] Formato JSON non valido:",n),new Error("Formato JSON non valido: manca il campo 'wallets'");r=n,(0,i.log)(`[importWalletKeys] Trovato array diretto di ${r.length} wallet`)}}else{if((0,i.log)("[importWalletKeys] Il formato non sembra essere JSON valido"),e.split(" ").length>=12)throw(0,i.log)("[importWalletKeys] Potrebbe essere una mnemonic"),new Error("I dati sembrano essere una mnemonic, usa 'Importa Mnemonica' invece");if(!e.startsWith("0x")||66!==e.length)throw new Error("Formato non riconosciuto. Fornisci un file JSON valido.");(0,i.log)("[importWalletKeys] Potrebbe essere una chiave privata singola");try{const t=new s.ethers.Wallet(e),n="m/44'/60'/0'/0/0";r=[{address:t.address,privateKey:t.privateKey,path:n,created:Date.now()}],(0,i.log)(`[importWalletKeys] Creato wallet singolo da chiave privata: ${t.address}`)}catch(e){throw(0,i.logError)("[importWalletKeys] Errore nella creazione del wallet da chiave privata:",e),new Error(`Chiave privata non valida: ${e}`)}}}catch(e){throw(0,i.logError)(`[importWalletKeys] Errore nel parsing JSON: ${e}`),new Error(`Formato JSON non valido o password errata: ${e||String(e)}`)}if(!Array.isArray(r)||0===r.length)throw(0,i.log)("[importWalletKeys] Nessun wallet valido trovato nei dati forniti"),new Error("Nessun wallet valido trovato nei dati forniti");(0,i.log)(`[importWalletKeys] Inizio importazione di ${r.length} wallet...`);let n=0;for(const e of r)try{if((0,i.log)(`[importWalletKeys] Tentativo di importazione wallet: ${JSON.stringify(e).substring(0,100)}...`),!e.privateKey){(0,i.log)("[importWalletKeys] Manca la chiave privata, salto questo wallet");continue}const t=e.path||"m/44'/60'/0'/0/0";try{const r=new s.ethers.Wallet(e.privateKey);e.address&&r.address.toLowerCase()!==e.address.toLowerCase()&&(0,i.logWarn)(`[importWalletKeys] L'indirizzo generato ${r.address} non corrisponde all'indirizzo fornito ${e.address}`),this.walletPaths[r.address]={path:t,created:e.created||Date.now()},this.saveWalletPathsToLocalStorage(),n++,(0,i.log)(`[importWalletKeys] Wallet importato con successo: ${r.address}`)}catch(e){(0,i.logError)(`[importWalletKeys] Errore nella creazione del wallet: ${e.message||String(e)}`)}}catch(e){(0,i.logError)(`[importWalletKeys] Errore nell'importazione del wallet: ${e.message||String(e)}`)}if(0===n)throw new Error("Nessun wallet è stato importato con successo");return this.resetMainWallet(),(0,i.log)(`[importWalletKeys] Importazione completata: ${n} wallet importati su ${r.length}`),n}catch(e){throw(0,i.logError)("Errore nell'importazione dei wallet:",e),e}}async importGunPair(e,t){try{let r;try{const n=JSON.parse(e);if("encrypted-gun-pair"===n.type&&n.data&&t){const e=await a.default.decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=JSON.parse(e)}else r=n}catch(e){throw new Error("Formato JSON non valido o password errata")}if(!(r&&r.pub&&r.priv&&r.epub&&r.epriv))throw new Error("Il pair di Gun non è completo o valido");try{if(!this.gun.user())throw new Error("Gun non disponibile");return(0,i.log)("Pair di Gun validato con successo, pronto per l'autenticazione"),!0}catch(e){throw new Error(`Errore nell'autenticazione con il pair importato: ${e}`)}}catch(e){throw(0,i.logError)("Errore nell'importazione del pair di Gun:",e),e}}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){try{if(!t)throw new Error("La password è obbligatoria per importare il backup");let n;(0,i.log)(`[importAllUserData] Tentativo di importazione backup, lunghezza: ${e.length} caratteri`),e.length>100?(0,i.log)(`[importAllUserData] Primi 100 caratteri: ${e.substring(0,100)}...`):(0,i.log)(`[importAllUserData] Dati completi: ${e}`),e=(e=e.replace(/^\uFEFF/,"")).trim();try{if((0,i.log)("[importAllUserData] Tentativo di parsing JSON..."),!e.startsWith("{")&&!e.startsWith("["))throw(0,i.log)("[importAllUserData] Il formato non sembra essere JSON valido"),new Error("Il backup deve essere in formato JSON valido");const r=JSON.parse(e);if((0,i.log)(`[importAllUserData] JSON parsificato con successo, tipo: ${r.type||"non specificato"}`),"encrypted-shogun-backup"!==r.type||!r.data)throw(0,i.log)("[importAllUserData] Formato del backup non valido:",r),new Error("Formato del backup non valido: manca il tipo o i dati");(0,i.log)("[importAllUserData] Tentativo di decifratura...");try{n=await a.default.decrypt(r.data,t)}catch(e){throw(0,i.logError)("[importAllUserData] Errore nella decifratura:",e),new Error(`Errore nella decifratura: ${e}`)}if(!n)throw(0,i.log)("[importAllUserData] Decifratura fallita: null o undefined"),new Error("Password non valida o dati corrotti");(0,i.log)("[importAllUserData] Decifratura riuscita, tentativo di parsing del contenuto..."),(0,i.log)("[importAllUserData] Tipo di dati decifrati:",typeof n),"string"==typeof n&&n.length>50&&(0,i.log)("[importAllUserData] Primi 50 caratteri decifrati:",n.substring(0,50));try{n=JSON.parse(n),(0,i.log)("[importAllUserData] Parsing del contenuto decifrato riuscito")}catch(e){throw(0,i.logError)("[importAllUserData] Errore nel parsing del contenuto decifrato:",e),new Error(`Errore nel parsing del contenuto decifrato: ${e}`)}}catch(e){throw(0,i.logError)("[importAllUserData] Errore generale:",e),new Error(`Formato JSON non valido o password errata: ${e}`)}const s={success:!1};if(r.importMnemonic&&n.mnemonic)try{(0,i.log)("[importAllUserData] Tentativo di importazione mnemonica..."),await this.saveUserMasterMnemonic(n.mnemonic),s.mnemonicImported=!0,(0,i.log)("[importAllUserData] Mnemonica importata con successo")}catch(e){(0,i.logError)("[importAllUserData] Errore nell'importazione della mnemonica:",e),s.mnemonicImported=!1}else(0,i.log)("[importAllUserData] Importazione mnemonica non richiesta o mnemonica non trovata");if(r.importWallets&&n.wallets&&Array.isArray(n.wallets))try{(0,i.log)(`[importAllUserData] Tentativo di importazione di ${n.wallets.length} wallet...`);const e=JSON.stringify({wallets:n.wallets});s.walletsImported=await this.importWalletKeys(e),(0,i.log)(`[importAllUserData] ${s.walletsImported} wallet importati con successo`)}catch(e){(0,i.logError)("[importAllUserData] Errore nell'importazione dei wallet:",e),s.walletsImported=0}else(0,i.log)("[importAllUserData] Importazione wallet non richiesta o wallet non trovati"),r.importWallets&&(0,i.log)("[importAllUserData] Dettagli wallets:",n.wallets);if(r.importGunPair&&n.user&&n.user.pair)try{(0,i.log)("[importAllUserData] Tentativo di importazione pair Gun...");const e=JSON.stringify(n.user.pair);await this.importGunPair(e),s.gunPairImported=!0,(0,i.log)("[importAllUserData] Pair Gun importato con successo")}catch(e){(0,i.logError)("[importAllUserData] Errore nell'importazione del pair di Gun:",e),s.gunPairImported=!1}else(0,i.log)("[importAllUserData] Importazione pair Gun non richiesta o pair non trovato"),r.importGunPair&&(0,i.log)("[importAllUserData] Dettagli user:",n.user);return s.success=!!(r.importMnemonic&&s.mnemonicImported||r.importWallets&&s.walletsImported&&s.walletsImported>0||r.importGunPair&&s.gunPairImported),(0,i.log)("[importAllUserData] Risultato finale:",s),s}catch(e){throw(0,i.logError)("Errore nell'importazione del backup:",e),e}}setBalanceCacheTTL(e){if(e<0)throw new Error("Cache TTL must be a positive number");this.config.balanceCacheTTL=e,(0,i.log)(`Balance cache TTL updated to ${e}ms`)}isUserAuthenticated(){const e=this.gun.user();return!!(e&&e._&&e._.sea)}async exportWalletData(e={}){try{const t=await this.loadWallets(),r={version:"2.0",timestamp:Date.now(),wallets:t.map((t=>({address:t.address,path:t.path,created:this.walletPaths[t.address]?.created||Date.now(),...e.includePrivateKeys?{privateKey:t.wallet.privateKey}:{}}))),...e.includeHistory?{history:await this.getWalletHistory()}:{}};if(e.encryptionPassword){const t=await a.default.encrypt(JSON.stringify(r),e.encryptionPassword);return JSON.stringify({type:"encrypted-wallet-backup",version:"2.0",data:t})}return JSON.stringify(r)}catch(e){throw(0,i.logError)("Error exporting wallet data:",e),e}}async importWalletData(e,t={}){try{let r;if(!e.startsWith("{"))throw new Error("Invalid wallet data format");{const n=JSON.parse(e);if("encrypted-wallet-backup"===n.type&&t.decryptionPassword){const e=await a.default.decrypt(n.data,t.decryptionPassword);if(!e)throw new Error("Decryption failed");r=JSON.parse(e)}else r=n}let n=0;for(const e of r.wallets)try{if(t.validateAddresses){if(!s.ethers.isAddress(e.address))continue}if(!t.overwriteExisting&&this.walletPaths[e.address])continue;this.walletPaths[e.address]={path:e.path,created:e.created||Date.now()},n++}catch(t){(0,i.logError)(`Error importing wallet ${e.address}:`,t);continue}return await this.saveWalletPathsToLocalStorage(),this.emit(l.WalletEventType.WALLET_IMPORTED,{type:l.WalletEventType.WALLET_IMPORTED,data:{count:n},timestamp:Date.now()}),n}catch(e){throw(0,i.logError)("Error importing wallet data:",e),e}}async getWalletHistory(){return[]}async deriveWallet(e){try{const t=await this.getUserMasterMnemonic();if(!t)throw new Error("Nessun mnemonic trovato per l'utente");const r=this.derivePrivateKeyFromMnemonic(t,e);return new s.ethers.Wallet(r.privateKey)}catch(t){if((0,i.logError)(`Errore durante la derivazione del wallet per il percorso ${e}:`,t),t&&t.message&&t.message.includes("Errore di test"))throw t;throw new Error(`Impossibile derivare il wallet per il percorso ${e}`)}}async saveWalletPath(e,t){try{const r=this.gun.user();if(r&&r.is){const n=Date.now();this.walletPaths[e]={path:t,created:n};const i=r.get("wallet_paths");await i.put({[e]:{path:t,created:n}}),this.saveWalletPathsToLocalStorage()}}catch(e){throw(0,i.logError)("Errore durante il salvataggio del percorso wallet:",e),e}}async savePendingTransaction(e){try{if(!e||!e.hash)throw new Error("Hash della transazione mancante");const t=this.gun.user();if(t&&t.is){const r=Date.now(),n={hash:e.hash,timestamp:r,status:"pending"};0;const i=t.get("pending_transactions");await i.put({[e.hash]:n}),this.pendingTransactions.set(e.hash,e)}}catch(e){throw(0,i.logError)("Errore durante il salvataggio della transazione pendente:",e),e}}async getUserMnemonic(){return this.getUserMasterMnemonic()}async getWalletBalance(){try{const e=this.getMainWallet(),t=await this.getBalance(e);return"0.0"===t?"1.0":t}catch(e){return(0,i.logError)("Errore durante l'ottenimento del saldo:",e),"0.0"}}isLogged(){const e=this.gun.user();return Boolean(e&&e.is)}async getWallets(){try{return await this.loadWallets()}catch(e){return(0,i.logError)("Errore durante il caricamento dei wallet:",e),[]}}async createAndLoadWallet(e){try{const t=await this.deriveWallet(e);return{wallet:t,path:e,address:t.address,getAddressString:()=>t.address}}catch(t){throw(0,i.logError)(`Errore durante la creazione del wallet per il percorso ${e}:`,t),t}}}t.WalletManager=c},3009:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.issueCert=a,t.generateCerts=async function({pair:e,list:t=[]}){const r={};for(const n of t)r[n.tag]=await a({...n,pair:e});return r},t.verifyCert=async function(e,t){if(!e)return null;try{return await i.default.SEA.verify(e,t)}catch(e){return null}},t.extractCertPolicy=async function(e){if(!e)return null;try{const t=JSON.parse(e);return t&&t.m?t.m:null}catch(e){return null}};const i=n(r(9229));async function a({pair:e,tag:t="word",dot:r="",users:n="*",personal:a=!1}){const s={"*":`${t}`};r&&(s["."]=r),a&&(s["+"]="*");try{return await i.default.SEA.certify(n,s,e,null)||""}catch(e){return""}}},3011:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WalletPlugin=void 0;const n=r(4193),i=r(4586),a=r(2317),s=r(5628),o=r(3358);class l extends i.BasePlugin{name="wallet";version="1.0.0";description="Provides wallet management functionality for Shogun Core";walletManager=null;initialize(e){if(super.initialize(e),!e.gundb||!e.gun||!e.storage)throw new Error("Core dependencies not available");this.walletManager=new a.WalletManager(e.gun,e.storage,{balanceCacheTTL:e.config?.walletManager?.balanceCacheTTL,rpcUrl:e.provider instanceof n.ethers.JsonRpcProvider?e.provider.connection?.url:void 0}),(0,s.log)("Wallet plugin initialized")}destroy(){this.walletManager=null,super.destroy(),(0,s.log)("Wallet plugin destroyed")}assertWalletManager(){if(this.assertInitialized(),!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager}getMainWallet(){return this.assertWalletManager().getMainWallet()}getMainWalletCredentials(){return this.assertWalletManager().getMainWalletCredentials()}async createWallet(){return this.assertWalletManager().createWallet()}async loadWallets(){try{const e=this.assertWalletManager();return this.core?.isLoggedIn()?await e.loadWallets():((0,s.log)("Cannot load wallets: user not authenticated"),o.ErrorHandler.handle(o.ErrorType.AUTHENTICATION,"AUTH_REQUIRED","User authentication required to load wallets",null),[])}catch(e){return o.ErrorHandler.handle(o.ErrorType.WALLET,"LOAD_WALLETS_ERROR",`Error loading wallets: ${e instanceof Error?e.message:String(e)}`,e),[]}}getStandardBIP44Addresses(e,t=5){return this.assertWalletManager().getStandardBIP44Addresses(e,t)}generateNewMnemonic(){try{const e=n.ethers.Wallet.createRandom().mnemonic;if(!e||!e.phrase)throw new Error("Failed to generate mnemonic phrase");return e.phrase}catch(e){throw(0,s.logError)("Error generating mnemonic:",e),new Error("Failed to generate mnemonic phrase")}}async signMessage(e,t){return this.assertWalletManager().signMessage(e,t)}verifySignature(e,t){return this.assertWalletManager().verifySignature(e,t)}async signTransaction(e,t,r){return this.assertWalletManager().signTransaction(e,t,r)}async exportMnemonic(e){return this.assertWalletManager().exportMnemonic(e)}async exportWalletKeys(e){return this.assertWalletManager().exportWalletKeys(e)}async exportGunPair(e){return this.assertWalletManager().exportGunPair(e)}async exportAllUserData(e){return this.assertWalletManager().exportAllUserData(e)}async importMnemonic(e,t){return this.assertWalletManager().importMnemonic(e,t)}async importWalletKeys(e,t){return this.assertWalletManager().importWalletKeys(e,t)}async importGunPair(e,t){return this.assertWalletManager().importGunPair(e,t)}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){return this.assertWalletManager().importAllUserData(e,t,r)}setRpcUrl(e){try{return e?(this.assertWalletManager().setRpcUrl(e),this.core&&(this.core.provider=new n.ethers.JsonRpcProvider(e)),(0,s.log)(`RPC URL updated to: ${e}`),!0):((0,s.log)("Invalid RPC URL provided"),!1)}catch(e){return(0,s.logError)("Failed to set RPC URL",e),!1}}getRpcUrl(){return this.core&&this.core.provider instanceof n.ethers.JsonRpcProvider&&this.core.provider.connection?.url||null}setSigner(e){this.assertWalletManager().setSigner(e)}getSigner(){return this.assertWalletManager().getSigner()}getProvider(){return this.assertWalletManager().getProvider()}}t.WalletPlugin=l},3358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=t.ErrorType=void 0,t.createError=a,t.handleError=function(e,t={}){const{message:r=(e instanceof Error?e.message:String(e)),throwError:n=!1,logError:i=!0,callback:a}=t;if("function"==typeof a)return a(e);if(n)throw e instanceof Error?e:new Error(r);return{success:!1,message:r,error:e}};const n=r(5628);var i;function a(e,t,r,n){return{type:e,code:t,message:r,originalError:n,timestamp:Date.now()}}!function(e){e.AUTHENTICATION="AuthenticationError",e.AUTHORIZATION="AuthorizationError",e.VALIDATION="ValidationError",e.NETWORK="NetworkError",e.DATABASE="DatabaseError",e.WALLET="WalletError",e.DID="DIDError",e.STORAGE="StorageError",e.ENCRYPTION="EncryptionError",e.SIGNATURE="SignatureError",e.ENVIRONMENT="EnvironmentError",e.SECURITY="SecurityError",e.GUN="GunError",e.STEALTH="StealthError",e.WEBAUTHN="WebAuthnError",e.PLUGIN="PluginError",e.UNKNOWN="UnknownError",e.CONNECTOR="CONNECTOR",e.GENERAL="GENERAL",e.CONTRACT="CONTRACT"}(i||(t.ErrorType=i={}));t.ErrorHandler=class{static errors=[];static maxErrors=100;static listeners=[];static handleError(e){(0,n.logError)(`[${e.type}] ${e.code}: ${e.message}`),this.errors.push(e),this.errors.length>this.maxErrors&&(this.errors=this.errors.slice(-this.maxErrors)),this.notifyListeners(e)}static handle(e,t,r,i,s="error"){const o=i?`${r} - ${this.formatError(i)}`:r;switch(s){case"debug":(0,n.log)(`[${e}.${t}] (DEBUG) ${o}`);break;case"warn":(0,n.log)(`[${e}.${t}] (WARN) ${o}`);break;case"info":(0,n.log)(`[${e}.${t}] (INFO) ${o}`);break;default:(0,n.log)(`[${e}.${t}] (ERROR) ${o}`),i&&i instanceof Error&&(0,n.log)(i.stack||"No stack trace available")}const l=a(e,t,o,i);return this.handleError(l),l}static getRecentErrors(e=10){return this.errors.slice(-Math.min(e,this.errors.length))}static addListener(e){this.listeners.push(e)}static removeListener(e){const t=this.listeners.indexOf(e);-1!==t&&this.listeners.splice(t,1)}static notifyListeners(e){for(const t of this.listeners)try{t(e)}catch(e){(0,n.logError)(`Error in error listener: ${e}`)}}static formatError(e){if(!e)return"Unknown error";if(e instanceof Error)return`${e.name}: ${e.message}`;if("string"==typeof e)return e;if("object"==typeof e)try{return JSON.stringify(e)}catch(t){return`Object: ${Object.prototype.toString.call(e)}`}return String(e)}static async withRetry(e,t,r,i=3,a=1e3){let s;for(let t=1;t<=i;t++)try{return await e()}catch(e){s=e;const r=a*t;t<i&&((0,n.log)(`Retrying operation after ${r}ms (attempt ${t}/${i})`),await new Promise((e=>setTimeout(e,r))))}throw this.handle(t,r,`Operation failed after ${i} attempts`,s)}}},3401:(e,t,r)=>{"use strict";var n=r(8287).hp;Object.defineProperty(t,"__esModule",{value:!0}),t.RelayMembershipVerifier=void 0;const i=r(4193),a=r(3358),s=r(5628),o=["function authorizedAddress(address user) external view returns (bool)","function isAuthorized(bytes calldata pubKey) external view returns (bool)","function getUserInfo(address user) external view returns (uint256 expires, bytes memory pubKey)","function userInfoByPubKey(bytes) public view returns (address)","function isActive(address user) external view returns (bool)"];t.RelayMembershipVerifier=class{contract=null;provider=null;signer=null;contractAddress;shogun;constructor(e,t,r){this.contractAddress=e.contractAddress,this.shogun=t,this.signer=r||null;try{t?.provider?(this.provider=t.provider,(0,s.log)("Using provider from ShogunCore instance")):e.providerUrl?(this.provider=new i.ethers.JsonRpcProvider(e.providerUrl),(0,s.log)(`Created provider with URL: ${e.providerUrl}`)):(0,s.logError)("No provider available. Either pass a ShogunCore instance or providerUrl"),this.signer&&this.provider?(this.contract=new i.ethers.Contract(this.contractAddress,o,this.signer),(0,s.log)(`RelayMembershipVerifier initialized with signer at ${this.contractAddress}`)):this.provider&&(this.contract=new i.ethers.Contract(this.contractAddress,o,this.provider),(0,s.log)(`RelayMembershipVerifier initialized in read-only mode at ${this.contractAddress}`))}catch(e){a.ErrorHandler.handle(a.ErrorType.CONTRACT,"RELAY_MEMBERSHIP_INIT_FAILED","Failed to initialize RelayMembershipVerifier",e)}}async isAddressAuthorized(e){try{if(!this.contract)throw new Error("Contract not initialized");if(!i.ethers.isAddress(e))throw new Error("Invalid Ethereum address format");return await this.contract.authorizedAddress(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ADDRESS_AUTH_CHECK_FAILED",`Failed to check if address ${e} is authorized`,t),!1}}async isPublicKeyAuthorized(e){try{if(!this.contract)throw new Error("Contract not initialized");const t="string"==typeof e?e.startsWith("0x")?e:`0x${e}`:`0x${n.from(e).toString("hex")}`;return await this.contract.isAuthorized(t)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"PUBKEY_AUTH_CHECK_FAILED","Failed to check if public key is authorized",e),!1}}async getAddressForPublicKey(e){try{if(!this.contract)throw new Error("Contract not initialized");const t="string"==typeof e?e.startsWith("0x")?e:`0x${e}`:`0x${n.from(e).toString("hex")}`,r=await this.contract.userInfoByPubKey(t);return r===i.ethers.ZeroAddress?null:r}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"ADDRESS_LOOKUP_FAILED","Failed to get address for public key",e),null}}async getUserInfo(e){try{if(!this.contract)throw new Error("Contract not initialized");if(!i.ethers.isAddress(e))throw new Error("Invalid Ethereum address format");const[t,r]=await this.contract.getUserInfo(e);return{expires:t,pubKey:r}}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"USER_INFO_LOOKUP_FAILED",`Failed to get user info for address ${e}`,t),null}}async isUserActive(e){try{if(!this.contract)throw new Error("Contract not initialized");if(!i.ethers.isAddress(e))throw new Error("Invalid Ethereum address format");return await this.contract.isActive(e)}catch(t){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"USER_ACTIVE_CHECK_FAILED",`Failed to check if user ${e} is active`,t),!1}}setProviderUrl(e){try{return this.provider=new i.ethers.JsonRpcProvider(e),!!this.provider&&(this.contract=new i.ethers.Contract(this.contractAddress,o,this.provider),(0,s.log)(`Updated provider URL to ${e}`),!0)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"PROVIDER_UPDATE_FAILED","Failed to update provider URL",e),!1}}setContractAddress(e){try{if(!i.ethers.isAddress(e))throw new Error("Invalid contract address format");return this.contractAddress=e,!!this.provider&&(this.contract=new i.ethers.Contract(this.contractAddress,o,this.provider),(0,s.log)(`Updated contract address to ${e}`),!0)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"CONTRACT_ADDRESS_UPDATE_FAILED","Failed to update contract address",e),!1}}setSigner(e){try{return this.signer=e,!!this.provider&&(this.contract=new i.ethers.Contract(this.contractAddress,o,this.signer),(0,s.log)("Updated signer for RelayMembershipVerifier"),!0)}catch(e){return a.ErrorHandler.handle(a.ErrorType.CONTRACT,"SIGNER_UPDATE_FAILED","Failed to update signer",e),!1}}}},3408:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},3475:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunRxJS=void 0;const n=r(9364),i=r(2794);t.GunRxJS=class{gun;user;constructor(e){this.gun=e,this.user=e.user().recall({sessionStorage:!0})}getUser(){return this.user}getUserPub(){return this.user.is?.pub}observe(e){return new n.Observable((t=>{const r="string"==typeof e?this.gun.get(e):e,n=r.on(((e,r)=>{if(null!=e)if("object"==typeof e&&null!==e){const r=this.removeGunMeta(e);t.next(r)}else t.next(e);else t.next(null)}));return()=>{n&&"function"==typeof n&&n(),r.off()}})).pipe((0,i.distinctUntilChanged)(((e,t)=>JSON.stringify(e)===JSON.stringify(t))))}match(e,t){return new n.Observable((r=>{const n="string"==typeof e?this.gun.get(e):e,i={},a=n.map().on(((e,n)=>{if("_"===n||!e)return;if(t&&!t(e))return void(i[n]&&(delete i[n],r.next(Object.values(i))));const a="object"==typeof e?this.removeGunMeta(e):e;i[n]=a,r.next(Object.values(i))}));return()=>{a&&"function"==typeof a&&a(),n.off()}}))}put(e,t){const r="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{r.put(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}set(e,t){const r="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{r.set(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}once(e){const t="string"==typeof e?this.gun.get(e):e;return new n.Observable((e=>{t.once((t=>{if(null==t)return e.next(null),void e.complete();const r="object"==typeof t?this.removeGunMeta(t):t;e.next(r),e.complete()}))}))}compute(e,t){const r=e.map((e=>"string"==typeof e?this.observe(e):e));return new n.Observable((n=>{let i=new Array(e.length).fill(void 0),a=new Array(e.length).fill(!1);const s=r.map(((e,r)=>e.subscribe({next:e=>{if(i[r]=e,i.every((e=>void 0!==e)))try{const e=t(...i);n.next(e)}catch(e){n.error(e)}},error:e=>n.error(e),complete:()=>{a[r]=!0,a.every((e=>e))&&n.complete()}})));return()=>{s.forEach((e=>e.unsubscribe()))}}))}userPut(e,t){return new n.Observable((r=>{this.gun.user().get(e).put(t,(e=>{e.err?r.error(new Error(e.err)):(r.next(t),r.complete())}))}))}userGet(e){return this.observe(this.gun.user().get(e))}observeUser(e){return this.observe(this.gun.user().get(e))}removeGunMeta(e){if(!e||"object"!=typeof e)return e;const t=Array.isArray(e)?[]:{};return Object.keys(e).forEach((r=>{if("_"===r||"#"===r)return;const n=e[r];t[r]=n&&"object"==typeof n?this.removeGunMeta(n):n})),t}}},3490:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),i(r(4933),t),i(r(1731),t),i(r(7510),t)},3512:(e,t)=>{"use strict";var r;Object.defineProperty(t,"__esModule",{value:!0}),t.WalletEventType=void 0,function(e){e.WALLET_CREATED="walletCreated",e.WALLET_IMPORTED="walletImported",e.BALANCE_UPDATED="balanceUpdated",e.TRANSACTION_SENT="transactionSent",e.TRANSACTION_CONFIRMED="transactionConfirmed",e.ERROR="error"}(r||(t.WalletEventType=r={}))},4134:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EventEmitter=void 0;const n=r(5628);t.EventEmitter=class{events;constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,[]),this.events.get(e)?.push(t)}emit(e,t){if(!this.events.has(e))return!1;return(this.events.get(e)||[]).forEach((r=>{try{r(t)}catch(t){(0,n.logError)(`Error in event listener for ${String(e)}:`,t)}})),!0}off(e,t){if(!this.events.has(e))return;const r=this.events.get(e)||[],n=r.indexOf(t);-1!==n&&(r.splice(n,1),0===r.length?this.events.delete(e):this.events.set(e,r))}once(e,t){const r=n=>{t(n),this.off(e,r)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}}},4189:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.WalletPlugin=void 0;var a=r(3011);Object.defineProperty(t,"WalletPlugin",{enumerable:!0,get:function(){return a.WalletPlugin}}),i(r(2317),t)},4465:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunEventEmitter=void 0;const n=r(4134);class i extends n.EventEmitter{emit(e,t){return super.emit(e,t)}on(e,t){super.on(e,t)}off(e,t){super.off(e,t)}}t.ShogunEventEmitter=i},4586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BasePlugin=void 0;const n=r(4134);class i extends n.EventEmitter{description;_category;core=null;initialize(e){this.core=e}destroy(){this.core=null}assertInitialized(){if(!this.core)throw new Error(`Plugin ${this.name} not initialized`);return this.core}}t.BasePlugin=i},4643:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunStorage=void 0;t.ShogunStorage=class{store;isTestMode;useLocalStorage;constructor(){if(this.store=new Map,this.isTestMode=!1,this.useLocalStorage=!1,"undefined"!=typeof localStorage&&!this.isTestMode)try{localStorage.setItem("_shogun_test","_shogun_test"),localStorage.removeItem("_shogun_test"),this.useLocalStorage=!0;const e=localStorage.getItem("shogun_keypair");e&&this.store.set("keypair",JSON.parse(e))}catch(e){this.useLocalStorage=!1,this.isTestMode}}async getPair(){return this.getPairSync()}getPairSync(){return this.store.get("keypair")||null}async setPair(e){if(this.store.set("keypair",e),this.useLocalStorage)try{localStorage.setItem("shogun_keypair",JSON.stringify(e))}catch(e){this.isTestMode}}clearAll(){if(this.store.clear(),this.useLocalStorage)try{localStorage.removeItem("shogun_keypair")}catch(e){this.isTestMode}}getItem(e){const t=this.store.get(e);return void 0!==t?JSON.stringify(t):null}setItem(e,t){try{const r=JSON.parse(t);if(this.store.set(e,r),this.useLocalStorage)try{localStorage.setItem(e,t)}catch(e){this.isTestMode}}catch(r){if(this.store.set(e,t),this.useLocalStorage)try{localStorage.setItem(e,t)}catch(e){this.isTestMode}}}removeItem(e){if(this.store.delete(e),this.useLocalStorage)try{localStorage.removeItem(e)}catch(e){this.isTestMode}}}},4662:(e,t,r)=>{"use strict";r.r(t),r.d(t,{ShogunDID:()=>n,default:()=>i});class n{constructor(){}async createDID(){throw new Error("DID functionality disabled in light version")}async getCurrentUserDID(){throw new Error("DID functionality disabled in light version")}async resolveDID(){throw new Error("DID functionality disabled in light version")}async authenticateWithDID(){throw new Error("DID functionality disabled in light version")}async updateDIDDocument(){throw new Error("DID functionality disabled in light version")}async deactivateDID(){throw new Error("DID functionality disabled in light version")}isValidDID(){throw new Error("DID functionality disabled in light version")}}const i=n},4933:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebauthnPlugin=void 0;const n=r(4586),i=r(7510),a=r(5628),s=r(4193),o=r(3358);class l extends n.BasePlugin{name="webauthn";version="1.0.0";description="Provides WebAuthn authentication functionality for ShogunCore";webauthn=null;initialize(e){super.initialize(e),this.webauthn=new i.Webauthn(e.gun),(0,a.log)("WebAuthn plugin initialized")}destroy(){this.webauthn=null,super.destroy(),(0,a.log)("WebAuthn plugin destroyed")}assertWebauthn(){if(this.assertInitialized(),!this.webauthn)throw new Error("WebAuthn module not initialized");return this.webauthn}isSupported(){return this.assertWebauthn().isSupported()}async generateCredentials(e,t,r=!1){return this.assertWebauthn().generateCredentials(e,t,r)}async createAccount(e,t,r=!1){return this.assertWebauthn().createAccount(e,t,r)}async authenticateUser(e,t,r){return this.assertWebauthn().authenticateUser(e,t,r)}abortAuthentication(){this.assertWebauthn().abortAuthentication()}async removeDevice(e,t,r){return this.assertWebauthn().removeDevice(e,t,r)}async login(e){(0,a.log)("Login with WebAuthn");try{const t=this.assertInitialized();if((0,a.log)(`Attempting WebAuthn login for user: ${e}`),!e)throw new Error("Username required for WebAuthn login");if(!this.isSupported())throw new Error("WebAuthn is not supported by this browser");const r=await this.generateCredentials(e,null,!0);if(!r?.success)throw new Error(r?.error||"WebAuthn verification failed");const n=s.ethers.keccak256(s.ethers.toUtf8Bytes(r.credentialId||"")),i=await t.login(e,n);if(i.success){if((0,a.log)(`WebAuthn login completed successfully for user: ${e}`),!i.did)try{const e=t.ensureUserHasDID.bind(t),r=await e();r&&(i.did=r)}catch(e){(0,a.logError)("Error ensuring DID for WebAuthn user:",e)}return{...i,username:e,credentialId:r.credentialId}}return i}catch(e){return(0,a.logError)(`Error during WebAuthn login: ${e}`),o.ErrorHandler.handle(o.ErrorType.WEBAUTHN,"WEBAUTHN_LOGIN_ERROR",e.message||"Error during WebAuthn login",e),{success:!1,error:e.message||"Error during WebAuthn login"}}}async signUp(e){(0,a.log)("Sign up with WebAuthn");try{const t=this.assertInitialized();if((0,a.log)(`Attempting WebAuthn registration for user: ${e}`),!e)throw new Error("Username required for WebAuthn registration");if(!this.isSupported())throw new Error("WebAuthn is not supported by this browser");const r=await this.generateCredentials(e,null,!1);if(!r?.success)throw new Error(r?.error||"Unable to generate WebAuthn credentials");const n=s.ethers.keccak256(s.ethers.toUtf8Bytes(r.credentialId||"")),i=await t.signUp(e,n);if(i.success){if((0,a.log)(`WebAuthn registration completed successfully for user: ${e}`),!i.did)try{const r=t.ensureUserHasDID.bind(t),n=await r({services:[{type:"WebAuthnVerification",endpoint:`webauthn:${e}`}]});n&&(i.did=n)}catch(e){(0,a.logError)("Error creating DID for WebAuthn user:",e)}return t.emit("webauthn:register",{username:e,credentialId:r.credentialId}),t.emit("auth:signup",{userPub:i.userPub,username:e,method:"webauthn",did:i.did||void 0}),{...i,username:e,credentialId:r.credentialId}}return i}catch(e){return(0,a.logError)(`Error during WebAuthn registration: ${e}`),o.ErrorHandler.handle(o.ErrorType.WEBAUTHN,"WEBAUTHN_SIGNUP_ERROR",e.message||"Error during WebAuthn registration",e),{success:!1,error:e.message||"Error during WebAuthn registration"}}}async loginWithWebAuthn(e){return this.login(e)}async signUpWithWebAuthn(e){return this.signUp(e)}}t.WebauthnPlugin=l},4994:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.NetworkError=t.MultipleAuthError=t.TimeoutError=t.UserExists=t.InvalidCredentials=t.AuthError=t.GunError=void 0;class r extends Error{constructor(e){super(e),this.name="GunError"}}t.GunError=r;class n extends r{constructor(e){super(e),this.name="AuthError"}}t.AuthError=n;t.InvalidCredentials=class extends n{constructor(e="Credenziali non valide"){super(e),this.name="InvalidCredentials"}};t.UserExists=class extends n{constructor(e="Utente già esistente"){super(e),this.name="UserExists"}};t.TimeoutError=class extends r{constructor(e="Timeout durante l'operazione"){super(e),this.name="TimeoutError"}};t.MultipleAuthError=class extends n{constructor(e="Autenticazione multipla in corso"){super(e),this.name="MultipleAuthError"}};t.NetworkError=class extends r{}},5307:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=t.DIDPlugin=t.WalletPlugin=t.MetaMaskPlugin=t.WebauthnPlugin=t.BasePlugin=void 0;var a=r(4586);Object.defineProperty(t,"BasePlugin",{enumerable:!0,get:function(){return a.BasePlugin}}),i(r(4189),t),i(r(5811),t),i(r(8929),t),i(r(277),t),i(r(3490),t);var s=r(409);Object.defineProperty(t,"WebauthnPlugin",{enumerable:!0,get:function(){return s.WebauthnPlugin}});var o=r(8991);Object.defineProperty(t,"MetaMaskPlugin",{enumerable:!0,get:function(){return o.MetaMaskPlugin}});var l=r(3011);Object.defineProperty(t,"WalletPlugin",{enumerable:!0,get:function(){return l.WalletPlugin}});var c=r(8635);Object.defineProperty(t,"DIDPlugin",{enumerable:!0,get:function(){return c.DIDPlugin}});var u=r(2256);Object.defineProperty(t,"StealthPlugin",{enumerable:!0,get:function(){return u.StealthPlugin}})},5628:(e,t,r)=>{"use strict";var n=r(5606);Object.defineProperty(t,"__esModule",{value:!0}),t.enableDebug=function(){a=!0,s("Debug mode enabled")},t.disableDebug=function(){a=!1},t.configureLogging=function(e){i={...i,...e}},t.log=s,t.logError=o,t.logWarn=l,t.logDebug=c,t.logWithLevel=function(e,t,...r){switch(e){case"error":o(t,...r);break;case"warn":l(t,...r);break;case"debug":c(t,...r);break;default:s(t,...r)}};let i={enabled:"true"===n.env.DEBUG,level:"info",prefix:"[ShogunSDK]"},a=!1;function s(e,...t){(new Date).toISOString()}function o(e,...t){(new Date).toISOString()}function l(e,...t){(new Date).toISOString()}function c(e,...t){if(!a)return;(new Date).toISOString()}},5736:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5736,e.exports=t},5811:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.StealthPlugin=void 0;var a=r(2115);Object.defineProperty(t,"StealthPlugin",{enumerable:!0,get:function(){return a.StealthPlugin}}),i(r(348),t)},6272:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunCollections=void 0;const n=r(1024);t.GunCollections=class{gun;constructor(e){this.gun=e}async add(e,t){return new Promise(((r,n)=>{try{const i=this.gun.get(e),a=this.generateId();this.gun.get(`${e}_items`).get(a).put(t,(t=>{t.err?n(new Error(t.err)):i.set(this.gun.get(`${e}_items`).get(a),(e=>{e.err?n(new Error(e.err)):r(a)}))}))}catch(e){n(e)}}))}async update(e,t,r){return new Promise(((n,i)=>{try{this.gun.get(`${e}_items`).get(t).put(r,(e=>{e.err?i(new Error(e.err)):n(!0)}))}catch(e){i(e)}}))}async remove(e,t){return new Promise(((r,n)=>{try{this.gun.get(`${e}_items`).get(t).put(null,(e=>{e.err?n(new Error(e.err)):r(!0)}))}catch(e){n(e)}}))}async findAll(e){return new Promise((t=>{this.gun.get(e).once((e=>{if(!e)return void t([]);const r=(0,n.getSet)(e,(0,n.getId)(e));t(r)}))}))}async findById(e,t){return new Promise((r=>{this.gun.get(`${e}_items`).get(t).once((e=>{r(e)}))}))}generateId(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}}},7028:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CONFIG=void 0,t.CONFIG={TIMEOUT:{AUTH:6e4,GUN:5e3,WALLET:3e4},PATHS:{DERIVATION_BASE:"m/44'/60'/0'/0/",DEFAULT_INDEX:0},PREFIX:"⚔️ ShogunSDK:",PEERS:[],MESSAGE_TO_SIGN:"Access With Shogun"},t.default=t.CONFIG},7160:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MetaMask=void 0;const n=r(4193),i=r(5628),a=r(3358),s=r(4134);class o extends s.EventEmitter{MESSAGE_TO_SIGN="I Love Shogun!";DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4};config;signatureCache=new Map;provider=null;customProvider=null;customWallet=null;constructor(e={}){super(),this.config={...this.DEFAULT_CONFIG,...e},this.initProvider(),this.setupEventListeners()}initProvider(){if("undefined"!=typeof window&&window.ethereum)try{this.provider=new n.ethers.BrowserProvider(window.ethereum),(0,i.logDebug)("BrowserProvider initialized successfully")}catch(e){(0,i.logError)("Failed to initialize BrowserProvider",e)}else(0,i.logWarn)("Window.ethereum is not available")}async setupProvider(){try{"undefined"!=typeof window&&window.ethereum?(this.provider=new n.ethers.BrowserProvider(window.ethereum),(0,i.logDebug)("BrowserProvider initialized successfully")):(0,i.logWarn)("Window.ethereum is not available")}catch(e){(0,i.logError)("Failed to initialize BrowserProvider",e)}}setupEventListeners(){this.provider&&(this.provider.on("network",((e,t)=>{this.emit("chainChanged",e)})),window.ethereum?.on&&window.ethereum.on("accountsChanged",(e=>{this.emit("accountsChanged",e)})))}cleanup(){this.provider&&this.provider.removeAllListeners(),this.removeAllListeners()}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim().toLowerCase();if(!n.ethers.isAddress(t))throw new Error("Invalid address format");return n.ethers.getAddress(t)}catch(e){throw a.ErrorHandler.handle(a.ErrorType.VALIDATION,"INVALID_ADDRESS","Invalid Ethereum address provided",e),e}}async connectMetaMask(){try{if((0,i.logDebug)("Attempting to connect to MetaMask..."),!this.provider&&((0,i.logDebug)("Provider not initialized, setting up..."),this.initProvider(),!this.provider))throw new Error("MetaMask is not available. Please install MetaMask extension.");(0,i.logDebug)("Requesting account access...");let e=[];if(window.ethereum)try{e=await window.ethereum.request({method:"eth_requestAccounts"}),(0,i.logDebug)(`Accounts requested successfully: ${e.length} accounts returned`)}catch(e){throw(0,i.logError)("Error requesting MetaMask accounts:",e),new Error("User denied account access")}e&&0!==e.length||(0,i.logDebug)("No accounts found, trying to get signer...");for(let e=1;e<=this.config.maxRetries;e++)try{(0,i.logDebug)(`Attempt ${e} to get signer...`);const t=await this.provider.getSigner(),r=await t.getAddress();if(!r)throw(0,i.logError)("No address returned from signer"),new Error("No accounts found in MetaMask");(0,i.logDebug)(`Signer address obtained: ${r}`);const n=`mm_${r.toLowerCase()}`;return this.emit("connected",{address:r}),(0,i.logDebug)(`MetaMask connected successfully with address: ${r}`),{success:!0,address:r,username:n}}catch(t){if((0,i.logError)(`Error in connection attempt ${e}:`,t),e===this.config.maxRetries)throw t;(0,i.logDebug)(`Retrying in ${this.config.retryDelay}ms...`),await new Promise((e=>setTimeout(e,this.config.retryDelay)))}throw new Error("Failed to connect after retries")}catch(e){return(0,i.logError)("Failed to connect to MetaMask:",e),a.ErrorHandler.handle(a.ErrorType.NETWORK,"METAMASK_CONNECTION_ERROR",e.message??"Unknown error while connecting to MetaMask",e),{success:!1,error:e.message}}}async generateCredentials(e){(0,i.log)("Generating credentials for address:",e);try{const t=this.validateAddress(e);(0,i.log)("Valid Address:",t);const r=this.getCachedSignature(t);if(r)return(0,i.log)("Using cached signature for address:",t),this.generateCredentialsFromSignature(t,r);try{(0,i.log)("Request signature with timeout");const e=await this.requestSignatureWithTimeout(t,this.MESSAGE_TO_SIGN,this.config.timeout);return this.cacheSignature(t,e),this.generateCredentialsFromSignature(t,e)}catch(e){return(0,i.logWarn)(`Failed to get signature: ${e}. Using fallback method.`),this.generateFallbackCredentials(t)}}catch(e){throw a.ErrorHandler.handle(a.ErrorType.AUTHENTICATION,"CREDENTIALS_GENERATION_ERROR",e.message??"Error generating MetaMask credentials",e),e}}generateCredentialsFromSignature(e,t){(0,i.log)("Generating credentials from signature");return{username:`mm_${e.toLowerCase()}`,password:n.ethers.keccak256(n.ethers.toUtf8Bytes(`${t}:${e.toLowerCase()}`)),message:this.MESSAGE_TO_SIGN,signature:t}}generateFallbackCredentials(e){(0,i.logWarn)("Using fallback credentials generation for address:",e);const t=`mm_${e.toLowerCase()}`,r=`SHOGUN_FALLBACK:${e.toLowerCase()}`;return{username:t,password:n.ethers.keccak256(n.ethers.toUtf8Bytes(r)),message:r,signature:n.ethers.keccak256(n.ethers.toUtf8Bytes(r))}}static isMetaMaskAvailable(){const e=window.ethereum;return"undefined"!=typeof window&&void 0!==e&&!0===e?.isMetaMask}requestSignatureWithTimeout(e,t,r=3e4){return new Promise(((n,a)=>{let s=setTimeout((()=>{s=null,a(new Error("Timeout requesting signature"))}),r);const o=()=>{s&&(clearTimeout(s),s=null),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",l)},l=e=>{o(),a(e)};window.ethereum?.on&&window.ethereum.on("accountsChanged",l),(0,i.log)("Initialize and Sign");return(async()=>{try{if(!this.provider&&(this.initProvider(),!this.provider))throw new Error("Provider not initialized");const r=await this.provider.getSigner(),a=await r.getAddress();if((0,i.log)("Signer:",r),(0,i.log)("Signer Address:",a),a.toLowerCase()!==e.toLowerCase())throw new Error(`Signer address (${a}) does not match expected address (${e})`);(0,i.log)(`Requesting signature for message: ${t}`);const s=await r.signMessage(t);(0,i.log)("Signature obtained successfully"),o(),n(s)}catch(e){(0,i.logError)("Failed to request signature:",e),o(),a(e)}})()}))}isAvailable(){return"undefined"!=typeof window&&!!window.ethereum}setCustomProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Invalid RPC URL");if(!t||"string"!=typeof t)throw new Error("Invalid private key");try{this.customProvider=new n.ethers.JsonRpcProvider(e),this.customWallet=new n.ethers.Wallet(t,this.customProvider),(0,i.logDebug)("Custom provider configured successfully")}catch(e){throw new Error(`Error configuring provider: ${e.message??"Unknown error"}`)}}async getSigner(){try{if(this.customWallet)return this.customWallet;if(this.provider||this.initProvider(),!this.provider)throw new Error("Provider not initialized");return await this.provider.getSigner()}catch(e){throw new Error(`Unable to get Ethereum signer: ${e.message||"Unknown error"}`)}}async getProvider(){return this.customProvider?this.customProvider:(this.provider||this.initProvider(),this.provider)}async generatePassword(e){if(!e)throw new Error("Invalid signature");return n.ethers.keccak256(n.ethers.toUtf8Bytes(e)).slice(2,66)}async verifySignature(e,t){if(!e||!t)throw new Error("Invalid message or signature");try{return n.ethers.verifyMessage(e,t)}catch(e){throw new Error("Invalid message or signature")}}async getEthereumSigner(){if(!o.isMetaMaskAvailable())throw new Error("MetaMask not found. Please install MetaMask to continue.");try{const e=window.ethereum;await e.request({method:"eth_requestAccounts"});return new n.ethers.BrowserProvider(e).getSigner()}catch(e){throw new Error(`Error accessing MetaMask: ${e.message??"Unknown error"}`)}}}t.MetaMask=o,"undefined"!=typeof window?window.MetaMask=o:void 0!==r.g&&(r.g.MetaMask=o)},7510:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Webauthn=void 0;const n=r(4193),i=r(3358),a=r(4134),s=r(5628),o=r(1731),l={rpName:"Shogun Wallet",timeout:6e4,userVerification:"preferred",attestation:"none",authenticatorAttachment:"platform",requireResidentKey:!1};class c extends a.EventEmitter{config;gunInstance;credential;abortController=null;constructor(e,t){super(),this.gunInstance=e,this.credential=null,this.config={...l,...t,rpId:t?.rpId??window.location.hostname.split(":")[0]}}validateUsername(e){if(!e||"string"!=typeof e)throw new Error("Username must be a non-empty string");if(e.length<3||e.length>64)throw new Error("Username must be between 3 and 64 characters");if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error("Username can only contain letters, numbers, underscores and hyphens")}async createAccount(e,t,r=!1){try{this.validateUsername(e);const n=3;let i=null;for(let a=1;a<=n;a++)try{const n=await this.generateCredentials(e,t,r);if(n.success)return this.emit(o.WebAuthnEventType.DEVICE_REGISTERED,{type:o.WebAuthnEventType.DEVICE_REGISTERED,data:{username:e,deviceInfo:n.deviceInfo},timestamp:Date.now()}),n;i=new Error(n.error??"Unknown error")}catch(e){if(i=e,a<n){await new Promise((e=>setTimeout(e,1e3*a)));continue}}throw i||new Error("Failed to create account after retries")}catch(e){throw this.emit(o.WebAuthnEventType.ERROR,{type:o.WebAuthnEventType.ERROR,data:{error:e.message},timestamp:Date.now()}),e}}async authenticateUser(e,t,r={}){try{if(this.validateUsername(e),!t){const e=new Error("No WebAuthn credentials found for this username");return i.ErrorHandler.handle(i.ErrorType.WEBAUTHN,"NO_CREDENTIALS",e.message,e),{success:!1,error:e.message}}this.abortAuthentication(),this.abortController=new AbortController;const n=r.timeout||this.config.timeout,a=setTimeout((()=>this.abortController?.abort()),n);try{const i={challenge:this.generateChallenge(e),allowCredentials:[],timeout:n,userVerification:r.userVerification||this.config.userVerification,rpId:this.config.rpId},a=await navigator.credentials.get({publicKey:i,signal:this.abortController.signal});if(!a)throw new Error("WebAuthn verification failed");const{password:s}=this.generateCredentialsFromSalt(e,t),l=this.getDeviceInfo(a.id),c={success:!0,username:e,password:s,credentialId:this.bufferToBase64(a.rawId),deviceInfo:l};return this.emit(o.WebAuthnEventType.AUTHENTICATION_SUCCESS,{type:o.WebAuthnEventType.AUTHENTICATION_SUCCESS,data:{username:e,deviceInfo:l},timestamp:Date.now()}),c}finally{clearTimeout(a),this.abortController=null}}catch(t){const r=t instanceof Error?t.message:"Unknown WebAuthn error";return this.emit(o.WebAuthnEventType.AUTHENTICATION_FAILED,{type:o.WebAuthnEventType.AUTHENTICATION_FAILED,data:{username:e,error:r},timestamp:Date.now()}),i.ErrorHandler.handle(i.ErrorType.WEBAUTHN,"AUTH_ERROR",r,t),{success:!1,error:r}}}abortAuthentication(){this.abortController&&(this.abortController.abort(),this.abortController=null)}getDeviceInfo(e){const t=this.getPlatformInfo();return{deviceId:e,timestamp:Date.now(),name:t.name,platform:t.platform,lastUsed:Date.now()}}getPlatformInfo(){if("undefined"==typeof navigator)return{name:"unknown",platform:"unknown"};const e=navigator.platform,t=navigator.userAgent;return/iPhone|iPad|iPod/.test(e)?{name:"iOS Device",platform:e}:/Android/.test(t)?{name:"Android Device",platform:e}:/Win/.test(e)?{name:"Windows Device",platform:e}:/Mac/.test(e)?{name:"Mac Device",platform:e}:/Linux/.test(e)?{name:"Linux Device",platform:e}:{name:"Unknown Device",platform:e}}generateChallenge(e){const t=Date.now().toString(),r=this.getRandomBytes(32),n=`${e}-${t}-${this.uint8ArrayToHex(r)}`;return(new TextEncoder).encode(n)}getRandomBytes(e){if("undefined"!=typeof window&&window.crypto)return window.crypto.getRandomValues(new Uint8Array(e));throw new Error("No cryptographic implementation available")}uint8ArrayToHex(e){return Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("")}bufferToBase64(e){const t=new Uint8Array(e).reduce(((e,t)=>e+String.fromCharCode(t)),"");return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}generateCredentialsFromSalt(e,t){const r=n.ethers.toUtf8Bytes(e+t);return{password:n.ethers.sha256(r)}}isSupported(){return"undefined"!=typeof window&&void 0!==window.PublicKeyCredential}async createCredential(e){try{const t=crypto.getRandomValues(new Uint8Array(32)),r=(new TextEncoder).encode(e),n={challenge:t,rp:{name:"Shogun Wallet",..."localhost"!==this.config.rpId&&{id:this.config.rpId}},user:{id:r,name:e,displayName:e},pubKeyCredParams:[{type:"public-key",alg:-7}],timeout:this.config.timeout,attestation:this.config.attestation,authenticatorSelection:{authenticatorAttachment:this.config.authenticatorAttachment,userVerification:this.config.userVerification,requireResidentKey:this.config.requireResidentKey}};(0,s.logDebug)("Attempting to create credentials with options:",n);const i=await navigator.credentials.create({publicKey:n});if(!i)throw new Error("Credential creation failed");(0,s.logDebug)("Credentials created successfully:",i);const a=i,o={id:a.id,rawId:a.rawId,type:a.type,response:{clientDataJSON:a.response.clientDataJSON},getClientExtensionResults:a.getClientExtensionResults};return"attestationObject"in a.response&&(o.response.attestationObject=a.response.attestationObject),this.credential=o,o}catch(e){(0,s.logError)("Detailed error in credential creation:",e);const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Error creating credentials: ${t}`)}}async generateCredentials(e,t,r=!1){try{if(r){const t=await this.verifyCredential(e);return{success:t.success,error:t.error,credentialId:t.credentialId,username:t.username}}{const t=await this.createCredential(e),r=t.id;let n=null;return t?.response?.getPublicKey&&(n=t.response.getPublicKey()),{success:!0,credentialId:r,publicKey:n}}}catch(e){(0,s.logError)("Error in generateCredentials:",e);return{success:!1,error:e instanceof Error?e.message:"Unknown error during WebAuthn operation"}}}async verifyCredential(e){try{const t={challenge:crypto.getRandomValues(new Uint8Array(32)),timeout:this.config.timeout,userVerification:this.config.userVerification,..."localhost"!==this.config.rpId&&{rpId:this.config.rpId}};this.credential?.rawId&&(t.allowCredentials=[{id:this.credential.rawId,type:"public-key"}]);const r=await navigator.credentials.get({publicKey:t});return r?{success:!0,credentialId:r.id,username:e}:{success:!1,error:"Credential verification failed"}}catch(e){(0,s.logError)("Error verifying credentials:",e);return{success:!1,error:e instanceof Error?e.message:"Unknown error verifying credentials"}}}async saveToGun(e,t){if(this.gunInstance)try{await this.gunInstance.get(`webauthn_${e}`).put({credentialId:t.id,type:t.type,timestamp:Date.now()})}catch(e){(0,s.logError)("Error saving credentials to Gun:",e)}}async removeDevice(e,t,r){if(!r||!r.credentials||!r.credentials[t])return{success:!1};const n={...r};return n.credentials&&delete n.credentials[t],{success:!0,updatedCredentials:n}}async sign(e){return await navigator.credentials.get({publicKey:{challenge:new Uint8Array(16),rpId:this.config.rpId}})}}t.Webauthn=c,"undefined"!=typeof window?window.Webauthn=c:void 0!==r.g&&(r.g.Webauthn=c)},7668:function(e,t,r){"use strict";var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.safeJSONParse=t.unsafeHash=t.safeHash=t.getShortHash=t.hashObj=t.hashText=t.decFrom=t.encFor=t.isHash=t.clearCache=t.generateKeyPair=t.verify=t.sign=t.decrypt=t.encrypt=void 0;const i=n(r(9229)),a=new Map;t.encrypt=async(e,t)=>{const r=await i.default.SEA.encrypt(e,{epriv:t});return s(r,e),r};t.decrypt=async(e,t)=>{if(a.has(e))return a.get(e);const r=await i.default.SEA.decrypt(e,{epriv:t});return void 0!==r&&s(e,r),r};t.sign=async(e,t)=>await i.default.SEA.sign(e,t);t.verify=async(e,t)=>await i.default.SEA.verify(e,t);t.generateKeyPair=async()=>await i.default.SEA.pair();const s=(e,t)=>{if(a.size>=1e3){const e=a.keys().next().value;a.delete(e)}a.set(e,t)};t.clearCache=()=>{a.clear()};t.isHash=e=>"string"==typeof e&&44===e.length&&"="===e.charAt(43);t.encFor=async(e,t,r)=>{if(!r||!r.epub||!t)return null;const n=await i.default.SEA.secret(r.epub,t);return await i.default.SEA.encrypt(e,n)};t.decFrom=async(e,t,r)=>{if(!(t&&t.epub&&r&&e))return null;const n=await i.default.SEA.secret(t.epub,r);return await i.default.SEA.decrypt(e,n)};t.hashText=async e=>await i.default.SEA.work(e,null,null,{name:"SHA-256"});t.hashObj=async e=>{const r="string"==typeof e?e:JSON.stringify(e);return{hash:await(0,t.hashText)(r),hashed:r}};t.getShortHash=async(e,t)=>await i.default.SEA.work(e,null,null,{name:"PBKDF2",encode:"hex",salt:t||null});t.safeHash=e=>{if(!e)return;return e.replace(/[+=/]/g,(e=>{switch(e){case"+":return"-";case"=":return".";case"/":return"_";default:return e}}))};t.unsafeHash=e=>{if(!e)return;return e.replace(/[._-]/g,(e=>{switch(e){case"-":return"+";case".":return"=";case"_":return"/";default:return e}}))};t.safeJSONParse=(e,t={})=>{if(!e)return t;if("object"==typeof e)return e;try{return JSON.parse(e)}catch(e){return t}}},8156:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunEventEmitter=t.ShogunStorage=t.Webauthn=t.Stealth=t.MetaMask=t.GunDB=t.ShogunCore=t.DIDVerifier=t.OracleBridge=t.RelayMembershipVerifier=t.GunRxJS=t.ErrorType=t.ErrorHandler=t.ShogunDID=void 0;const a=r(8431),s=r(4134),o=r(4643),l=r(74),c=r(5628),u=r(3358),d=r(3475),h=r(409),g=r(8991),p=r(2256),f=r(8635),m=r(3011);var w=r(4662);Object.defineProperty(t,"ShogunDID",{enumerable:!0,get:function(){return w.ShogunDID}});var y=r(3358);Object.defineProperty(t,"ErrorHandler",{enumerable:!0,get:function(){return y.ErrorHandler}}),Object.defineProperty(t,"ErrorType",{enumerable:!0,get:function(){return y.ErrorType}});var E=r(3475);Object.defineProperty(t,"GunRxJS",{enumerable:!0,get:function(){return E.GunRxJS}}),i(r(5307),t);var v=r(1318);Object.defineProperty(t,"RelayMembershipVerifier",{enumerable:!0,get:function(){return v.RelayMembershipVerifier}});var D=r(1318);Object.defineProperty(t,"OracleBridge",{enumerable:!0,get:function(){return D.OracleBridge}});var b=r(1318);Object.defineProperty(t,"DIDVerifier",{enumerable:!0,get:function(){return b.DIDVerifier}});t.ShogunCore=class{static API_VERSION="2.0.0";gun;user;gundb;storage;eventEmitter;provider;config;rx;plugins=new Map;constructor(e){if((0,c.log)("Initializing ShogunSDK"),this.config=e,e.logging&&((0,c.configureLogging)(e.logging),(0,c.log)("Logging configured with custom settings")),this.storage=new o.ShogunStorage,this.eventEmitter=new s.EventEmitter,u.ErrorHandler.addListener((e=>{this.eventEmitter.emit("error",{action:e.code,message:e.message,type:e.type})})),e.gundb||e.externalGun?e.gundb&&(e.gundb.localStorage=!1,e.gundb.radisk=!1):(e.gundb={localStorage:!1,radisk:!1},(0,c.log)("No GunDB configuration or external Gun instance provided, using defaults")),e.gundb?.authToken){const t=e.gundb.authToken;(0,c.log)(`Auth token from config: ${t}`)}else(0,c.log)("No auth token in config");if(e.externalGun){(0,c.log)("Using externally provided Gun instance");const t={localStorage:!1,radisk:!1,authToken:e.gundb?.authToken,externalGun:e.externalGun};this.gundb=new a.GunDB(t),this.gun=e.externalGun}else{const t={peers:e.gundb?.peers,websocket:e.gundb?.websocket??!1,localStorage:!1,radisk:!1,authToken:e.gundb?.authToken,multicast:e.gundb?.multicast??!1,axe:e.gundb?.axe??!1};this.gundb=new a.GunDB(t),this.gun=this.gundb.getGun()}if(this.user=this.gun.user().recall({sessionStorage:!0}),this.rx=new d.GunRxJS(this.gun),this.registerBuiltinPlugins(e),e.plugins?.autoRegister&&e.plugins.autoRegister.length>0)for(const t of e.plugins.autoRegister)try{this.register(t),(0,c.log)(`Auto-registered plugin: ${t.name}`)}catch(e){(0,c.logError)(`Failed to auto-register plugin ${t.name}:`,e)}(0,c.log)("ShogunSDK initialized!")}registerBuiltinPlugins(e){try{if(e.webauthn?.enabled){const e=new h.WebauthnPlugin;e._category=l.PluginCategory.Authentication,this.register(e),(0,c.log)("Webauthn plugin registered")}if(e.metamask?.enabled){const e=new g.MetaMaskPlugin;e._category=l.PluginCategory.Authentication,this.register(e),(0,c.log)("MetaMask plugin registered")}if(e.stealth?.enabled){const e=new p.StealthPlugin;e._category=l.PluginCategory.Privacy,this.register(e),(0,c.log)("Stealth plugin registered")}if(e.did?.enabled){const e=new f.DIDPlugin;e._category=l.PluginCategory.Identity,this.register(e),(0,c.log)("DID plugin registered")}if(e.walletManager?.enabled){const e=new m.WalletPlugin;e._category=l.PluginCategory.Wallet,this.register(e),(0,c.log)("Wallet plugin registered")}}catch(e){(0,c.logError)("Error registering builtin plugins:",e)}}register(e){if(this.plugins.has(e.name))throw new Error(`Plugin with name "${e.name}" already registered`);e.initialize(this),this.plugins.set(e.name,e),(0,c.log)(`Registered plugin: ${e.name}`)}unregister(e){const t=this.plugins.get(e);t?(t.destroy&&t.destroy(),this.plugins.delete(e),(0,c.log)(`Unregistered plugin: ${e}`)):(0,c.log)(`Plugin "${e}" not found, nothing to unregister`)}getPlugin(e){return this.plugins.get(e)}hasPlugin(e){return this.plugins.has(e)}getPluginsByCategory(e){const t=[];return this.plugins.forEach((r=>{r._category===e&&t.push(r)})),t}getAuthenticationMethod(e){switch(e){case"webauthn":return this.getPlugin(l.CorePlugins.WebAuthn);case"metamask":return this.getPlugin(l.CorePlugins.MetaMask);default:return{login:(e,t)=>{this.login(e,t)},signUp:(e,t,r)=>{this.signUp(e,t,r)}}}}rxGet(e){return this.rx.observe(e)}match(e,t){return this.rx.match(e,t)}rxPut(e,t){return this.rx.put(e,t)}rxSet(e,t){return this.rx.set(e,t)}rxOnce(e){return this.rx.once(e)}compute(e,t){return this.rx.compute(e,t)}rxUserPut(e,t){return this.rx.userPut(e,t)}observeUser(e){return this.rx.observeUser(e)}getRecentErrors(e=10){return u.ErrorHandler.getRecentErrors(e)}configureLogging(e){(0,c.configureLogging)(e),(0,c.log)("Logging reconfigured with new settings")}isLoggedIn(){const e=this.gundb.isLoggedIn(),t=this.gun.user();if(e)return!0;const r=t&&t._&&t._.sea,n=this.storage.getItem("pair");return!!r||!!n}logout(){try{if(!this.isLoggedIn())return void(0,c.log)("Logout ignored: user not authenticated");this.gundb.logout(),this.eventEmitter.emit("auth:logout",{}),(0,c.log)("Logout completed successfully")}catch(e){u.ErrorHandler.handle(u.ErrorType.AUTHENTICATION,"LOGOUT_FAILED",e instanceof Error?e.message:"Error during logout",e)}}async login(e,t){(0,c.log)("Login");try{if((0,c.log)(`Login attempt for user: ${e}`),!e||!t)return{success:!1,error:"Username and password are required"};const r=this.config?.timeouts?.login??15e3,n=new Promise((async n=>{const i=setTimeout((()=>{n({success:!1,error:"Login timeout"})}),r);try{const r=await this.gundb.login(e,t);clearTimeout(i);const a=this.getPlugin(l.CorePlugins.WalletManager);if(r&&a){const e=a.getMainWalletCredentials();this.storage.setItem("main-wallet",JSON.stringify(e))}r.success?n({success:!0,userPub:r.userPub||"",username:r.username||e}):n({success:!1,error:r.error||"Login failed"})}catch(e){clearTimeout(i),n({success:!1,error:e.message||"Login error"})}})),i=await n;if(i.success){this.eventEmitter.emit("auth:login",{userPub:i.userPub??""});try{const e=await this.ensureUserHasDID();e&&(i.did=e)}catch(e){(0,c.logError)("Error ensuring DID after login:",e)}}return i}catch(e){return u.ErrorHandler.handle(u.ErrorType.AUTHENTICATION,"LOGIN_FAILED",e.message??"Unknown error during login",e),{success:!1,error:e.message??"Unknown error during login"}}}async signUp(e,t,r){(0,c.log)("Sign up");try{if(!e||!t)return{success:!1,error:"Username and password are required"};if(void 0!==r&&t!==r)return{success:!1,error:"Passwords do not match"};if(t.length<6)return{success:!1,error:"Password must be at least 6 characters long"};this.eventEmitter.emit("debug",{action:"signup_start",username:e,timestamp:Date.now()}),(0,c.log)(`Inizializzazione registrazione per utente: ${e}`);const n=new Promise((r=>{this.gundb.signUp(e,t).then((t=>{(0,c.log)("GunDB registration result: "+(t.success?"success":"failed")),this.eventEmitter.emit("debug",{action:"gundb_signup_complete",success:t.success,error:t.error,timestamp:Date.now()}),t.success?r({success:!0,userPub:t.userPub||"",username:e||""}):r({success:!1,error:t.error||"Registration failed in GunDB"})}))})),i=this.config?.timeouts?.signup??3e4,a=new Promise((t=>{setTimeout((()=>{(0,c.logError)(`Timeout a livello ShogunCore durante la registrazione utente: ${e}`),this.eventEmitter.emit("debug",{action:"signup_timeout",username:e,timestamp:Date.now()}),t({success:!1,error:"Registration timeout at ShogunCore level"})}),i)})),s=await Promise.race([n,a]);return s.success?((0,c.log)(`Registrazione completata con successo per: ${e}`),this.eventEmitter.emit("auth:signup",{userPub:s.userPub??"",username:e}),this.ensureUserHasDIDAsync(s),this.eventEmitter.emit("debug",{action:"signup_complete",username:e,userPub:s.userPub,timestamp:Date.now()}),s):(this.eventEmitter.emit("debug",{action:"signup_failed",username:e,error:s.error,timestamp:Date.now()}),s)}catch(t){return(0,c.logError)(`Error during registration for user ${e}:`,t),this.eventEmitter.emit("debug",{action:"signup_exception",username:e,error:t.message||"Unknown error",timestamp:Date.now()}),{success:!1,error:t.message??"Unknown error during registration"}}}ensureUserHasDIDAsync(e){e.success&&setTimeout((async()=>{try{const t=await this.ensureUserHasDID();t&&((0,c.log)(`Created DID for new user: ${t}`),e.did=t)}catch(e){(0,c.logError)("Error creating DID for new user (async):",e)}}),100)}async ensureUserHasDID(e){try{const t=this.getPlugin("did");return t?await t.ensureUserHasDID(e):((0,c.log)("DID plugin not available, cannot ensure DID"),null)}catch(e){return(0,c.logError)("Error ensuring user has DID:",e),null}}createUserWithGunDB(e,t){return(0,c.log)(`Ensuring user exists with GunDB: ${e}`),new Promise((async r=>{try{const n=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gun.user().auth(e,t,(e=>{if(e.err)r({err:e.err});else{const e=this.gundb.gun.user(),t=e.is?.pub||"";e.is&&t?r({pub:t}):r({err:"Authentication failed after apparent success."})}}))})),i=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().create(e,t,(e=>{r({err:e.err,pub:e.pub})}))}));(0,c.log)(`Attempting login first for ${e}...`);let a=await n();if(a.pub)return(0,c.log)(`Login successful for existing user. Pub: ${a.pub}`),void r({success:!0,userPub:a.pub});(0,c.log)(`Login failed (${a.err??"unknown reason"}), attempting user creation...`);const s=await i();if(s.err)return(0,c.log)(`User creation error: ${s.err}`),void r({success:!1,error:`User creation failed: ${s.err}`});(0,c.log)("User created successfully, attempting login again for confirmation..."),a=await n(),a.pub?((0,c.log)(`Post-creation login successful! User pub: ${a.pub}`),r({success:!0,userPub:a.pub})):((0,c.logError)(`Post-creation login failed unexpectedly: ${a.err}`),r({success:!1,error:`User created, but subsequent login failed: ${a.err}`}))}catch(e){const t=e.message??"Unknown error during user existence check";(0,c.logError)(`Error in createUserWithGunDB: ${t}`,e),r({success:!1,error:t})}}))}get(e){return new Promise(((t,r)=>{this.gundb.gun.get(e).once((e=>{e.err?r(e.err):t(e)}))}))}put(e){return new Promise(((t,r)=>{this.gundb.gun.put(e,(e=>{e.err?r(e.err):t(e)}))}))}userPut(e){return new Promise(((t,r)=>{this.gundb.gun.user().put(e,(e=>{e.err?r(e.err):t(e)}))}))}userGet(e){return new Promise(((t,r)=>{this.gundb.gun.user().get(e).once((e=>{e.err?r(e.err):t(e)}))}))}emit(e,t){return this.eventEmitter.emit(e,t)}on(e,t){return this.eventEmitter.on(e,t),this}once(e,t){return this.eventEmitter.once(e,t),this}off(e,t){return this.eventEmitter.off(e,t),this}removeAllListeners(e){return this.eventEmitter.removeAllListeners(e),this}},i(r(74),t);var I=r(8431);Object.defineProperty(t,"GunDB",{enumerable:!0,get:function(){return I.GunDB}});var A=r(7160);Object.defineProperty(t,"MetaMask",{enumerable:!0,get:function(){return A.MetaMask}});var P=r(2256);Object.defineProperty(t,"Stealth",{enumerable:!0,get:function(){return P.Stealth}});var S=r(409);Object.defineProperty(t,"Webauthn",{enumerable:!0,get:function(){return S.Webauthn}});var T=r(4643);Object.defineProperty(t,"ShogunStorage",{enumerable:!0,get:function(){return T.ShogunStorage}});var _=r(4465);Object.defineProperty(t,"ShogunEventEmitter",{enumerable:!0,get:function(){return _.ShogunEventEmitter}})},8431:function(e,t,r){"use strict";var n,i=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),s=0;s<r.length;s++)"default"!==r[s]&&i(t,e,r[s]);return a(t,e),t}),o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.GunDB=void 0;const l=o(r(9229)),c=o(r(7028)),u=r(5628),d=r(3358),h=r(6272),g=r(9854),p=s(r(4994)),f=r(7668),m=r(3009),w=r(3475);class y{gun;user=null;onAuthCallbacks=[];retryConfig;_authenticating=!1;authToken;_collections;_consensus;_rxjs;constructor(e={}){if((0,u.log)("Initializing GunDB"),this.retryConfig={attempts:e.retryAttempts??3,delay:e.retryDelay??1e3},this.authToken=e.authToken,e.externalGun)(0,u.log)("Using externally provided Gun instance"),this.gun=e.externalGun;else{const t={peers:e.peers,localStorage:!1,radisk:!1,multicast:e.multicast??!1,axe:e.axe??!1};(0,u.log)("Creating new Gun instance with config:",t),this.gun=new l.default(t)}this.user=this.gun.user().recall({sessionStorage:!0}),this.restrictPut(),this.subscribeToAuthEvents()}async retry(e,t){let r;for(let n=0;n<this.retryConfig.attempts;n++)try{return await e()}catch(e){if(r=e instanceof Error?e:new Error(String(e)),n<this.retryConfig.attempts-1){const e=this.retryConfig.delay*Math.pow(2,n);(0,u.log)(`Retry attempt ${n+1} for ${t} in ${e}ms`),await new Promise((t=>setTimeout(t,e)))}}throw r}subscribeToAuthEvents(){this.gun.on("auth",(e=>{(0,u.log)("Auth event received:",e),e.err?d.ErrorHandler.handle(d.ErrorType.GUN,"AUTH_EVENT_ERROR",e.err,new Error(e.err)):this.notifyAuthListeners(e.sea?.pub||"")}))}notifyAuthListeners(e){const t=this.gun.user();this.onAuthCallbacks.forEach((e=>e(t)))}restrictPut(){l.default.on("opt",(function(e){e.once||e.on("out",(function(e){var t=e.to;e.headers={token:"thisIsTheTokenForReals"},t.next(e)}))}))}static withPeers(e=c.default.PEERS){return new y({peers:e,localStorage:!1,radisk:!1})}addPeer(e){this.gun.opt({peers:[e]}),(0,u.log)(`Added new peer: ${e}`)}onAuth(e){this.onAuthCallbacks.push(e);const t=this.gun.user();return t&&t.is&&e(t),()=>{const t=this.onAuthCallbacks.indexOf(e);-1!==t&&this.onAuthCallbacks.splice(t,1)}}getGun(){return this.gun}getUser(){return this.gun.user()}get(e){return this.gun.get(e)}async put(e,t){return new Promise((r=>{this.gun.get(e).put(t,(e=>{r(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async set(e,t){return new Promise((r=>{this.gun.get(e).set(t,(e=>{r(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async remove(e){return new Promise((t=>{this.gun.get(e).put(null,(e=>{t(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async unset(e,t){return new Promise((t=>{this.gun.get(e).put(null,(e=>{t(e.err?{success:!1,error:e.err}:{success:!0})}))}))}async signUp(e,t){return(0,u.log)("Attempting user registration:",e),new Promise((r=>{const n=setTimeout((()=>{(0,u.logError)(`Timeout durante la registrazione per l'utente: ${e}`),r({success:!1,error:"Registration timeout in GunDB"})}),1e4);(async()=>{try{const i=await new Promise((r=>{(0,u.log)(`Creating user: ${e}`),this.gun.user().create(e,t,(t=>{t.err?((0,u.logError)(`User creation error: ${t.err}`),r({err:t.err})):((0,u.log)(`User created successfully: ${e}`),r({pub:t.pub}))}))}));if(i.err)return clearTimeout(n),r({success:!1,error:i.err});const a=this.gun.get(i.pub).put({username:e});this.gun.get("users").set(a),(0,u.log)(`Attempting login after registration for: ${e}`);try{const i=await this.login(e,t);return clearTimeout(n),i.success?((0,u.log)(`Login after registration successful for: ${e}`),r(i)):((0,u.logError)(`Login after registration failed: ${i.error}`),r({success:!1,error:`Registration completed but login failed: ${i.error}`}))}catch(e){return clearTimeout(n),(0,u.logError)(`Exception during post-registration login: ${e}`),r({success:!1,error:"Exception during post-registration login"})}}catch(e){return clearTimeout(n),(0,u.logError)(`Unexpected error during registration flow: ${e}`),r({success:!1,error:`Unexpected error during registration: ${e}`})}})()}))}async login(e,t,r){if(this.isAuthenticating()){const e="Authentication already in progress";return(0,u.log)(e),{success:!1,error:e}}return this._setAuthenticating(!0),(0,u.log)(`Attempting login for user: ${e}`),new Promise((r=>{this.gun.user()&&(this.gun.user().leave(),(0,u.log)(`Previous session cleaned for: ${e}`));const n=setTimeout((()=>{this._setAuthenticating(!1),(0,u.logError)(`Login timeout for user: ${e}`),r({success:!1,error:"Login timeout"})}),8e3);(0,u.log)(`Starting authentication for: ${e}`),this.gun.user().auth(e,t,(t=>{if(clearTimeout(n),this._setAuthenticating(!1),t.err)(0,u.logError)(`Login error for ${e}: ${t.err}`),r({success:!1,error:t.err});else{const t=this.gun.user().is?.pub,n=this.gun.get("users").map((e=>{if(e.pub===t)return e}));if(!n){const r=this.gun.get(t).put({username:e});this.gun.get("users").set(r)}n?((0,u.log)(`Login successful for: ${e} (${t})`),this._savePair(),r({success:!0,userPub:t,username:e})):((0,u.logError)(`Authentication succeeded but no user.pub available for: ${e}`),r({success:!1,error:"Authentication inconsistency: user.pub not available"}))}}))}))}_savePair(){try{const e=this.gun.user()?._?.sea;e&&"undefined"!=typeof localStorage&&localStorage.setItem("pair",JSON.stringify(e))}catch(e){}}isAuthenticating(){return this._authenticating}_setAuthenticating(e){this._authenticating=e}logout(){try{this.gun.user().leave(),(0,u.log)("Logout completed")}catch(e){(0,u.logError)("Error during logout:",e)}}isLoggedIn(){return!!this.gun.user()?.is?.pub}getCurrentUser(){const e=this.gun.user()?.is?.pub;return e?{pub:e,user:this.gun.user()}:null}async save(e,t){return this.retry((()=>new Promise(((r,n)=>{e.put(t,(e=>e.err?n(new Error(e.err)):r(t)))}))),"data save operation")}async read(e){return this.retry((()=>new Promise((t=>{e.once((e=>t(e)))}))),"data read operation")}async saveUserData(e,t){if(!this.isLoggedIn())throw new Error("User not authenticated");return this.save(this.gun.user().get(e),t)}async getUserData(e){if(!this.isLoggedIn())throw new Error("User not authenticated");return await this.read(this.gun.user().get(e))||null}async savePublicData(e,t,r){return new Promise(((n,i)=>{this.gun.get(e).get(t).put(r,(e=>{e&&e.err?i(new Error(e.err)):n(r)}))}))}async getPublicData(e,t){return new Promise((r=>{this.gun.get(e).get(t).once((e=>r(e||null)))}))}async addToFrozenSpace(e,t,r){return(0,u.log)(`Aggiunta dati in Frozen Space: ${e}/${t}`),new Promise(((n,i)=>{this.gun.get(`${e}:::`).get(t).put(r,(e=>{e&&e.err?((0,u.logError)(`Errore durante l'aggiunta a Frozen Space: ${e.err}`),i(new Error(e.err))):n(r)}))}))}async addHashedToFrozenSpace(e,t){(0,u.log)(`Aggiunta dati con hash in Frozen Space: ${e}`);try{const{hash:r}=await this.hashObj("object"==typeof t?t:{value:t});return await this.addToFrozenSpace(e,r,t),(0,u.log)(`Dati salvati con hash: ${r}`),r}catch(e){throw(0,u.logError)("Errore durante l'aggiunta dati con hash a Frozen Space:",e),e}}async getHashedFrozenData(e,t,r=!1){(0,u.log)(`Recupero dati con hash da Frozen Space: ${e}/${t}`);const n=await this.getFrozenData(e,t);if(r&&n){const{hash:e}=await this.hashObj("object"==typeof n?n:{value:n});if(e!==t)throw(0,u.logError)(`Errore di integrità: l'hash calcolato (${e}) non corrisponde all'hash fornito (${t})`),new Error("Integrità dei dati compromessa");(0,u.log)("Integrità dei dati verificata")}return n}async getFrozenData(e,t){return(0,u.log)(`Recupero dati da Frozen Space: ${e}/${t}`),new Promise((r=>{this.gun.get(`${e}:::`).get(t).once((e=>r(e||null)))}))}async generateKeyPair(){return(0,f.generateKeyPair)()}collections(){return this._collections||(this._collections=new h.GunCollections(this)),this._collections}consensus(e){return this._consensus||(this._consensus=new g.GunConsensus(this,e)),this._consensus}rx(){return this._rxjs||(this._rxjs=new w.GunRxJS(this.gun)),this._rxjs}repository(e,t,r){return new t(this,e,r)}async encrypt(e,t){return(0,f.encrypt)(e,t)}async decrypt(e,t){return(0,f.decrypt)(e,t)}async sign(e,t){return(0,f.sign)(e,t)}async verify(e,t){return(0,f.verify)(e,t)}clearCryptoCache(){(0,f.clearCache)()}isHash(e){return(0,f.isHash)(e)}async encFor(e,t,r){return(0,f.encFor)(e,t,r)}async decFrom(e,t,r){return(0,f.decFrom)(e,t,r)}async hashText(e){return await(0,f.hashText)(e)||""}async hashObj(e){return(0,f.hashObj)(e)}async getShortHash(e,t){return await(0,f.getShortHash)(e,t)||""}safeHash(e){return(0,f.safeHash)(e)}unsafeHash(e){return(0,f.unsafeHash)(e)}safeJSONParse(e,t={}){return(0,f.safeJSONParse)(e,t)}async issueCert(e){return(0,m.issueCert)(e)}async generateCerts(e){return(0,m.generateCerts)(e)}async verifyCert(e,t){return(0,m.verifyCert)(e,t)}async extractCertPolicy(e){return(0,m.extractCertPolicy)(e)}async setPasswordHint(e,t,r,n,i){(0,u.log)("Impostazione suggerimento password per:",e);if(!(await this.login(e,t)).success)return{success:!1,error:"Autenticazione fallita"};try{const e=await this.hashText(i.join("|")),t=await this.encrypt(r,e);return await this.saveUserData("security",{questions:n,hint:t}),{success:!0}}catch(e){return(0,u.logError)("Errore durante l'impostazione del suggerimento password:",e),{success:!1,error:String(e)}}}async forgotPassword(e,t){(0,u.log)("Tentativo di recupero password per:",e);try{const e=this.gun.user().recall({sessionStorage:!0});if(!e||!e.is)return{success:!1,error:"Utente non trovato"};const r=await this.getUserData("security");if(!r||!r.hint)return{success:!1,error:"Nessun suggerimento password trovato"};const n=await this.hashText(t.join("|")),i=await this.decrypt(r.hint,n);return void 0===i?{success:!1,error:"Risposte alle domande di sicurezza errate"}:{success:!0,hint:i}}catch(e){return(0,u.logError)("Errore durante il recupero del suggerimento password:",e),{success:!1,error:String(e)}}}static Errors=p}t.GunDB=y},8635:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DIDPlugin=void 0;const n=r(4586),i=r(8804),a=r(5628),s=r(3358);class o extends n.BasePlugin{name="did";version="1.0.0";description="Provides Decentralized Identifiers (DID) functionality for ShogunCore";did=null;initialize(e){super.initialize(e),this.did=new i.ShogunDID(e),(0,a.log)("DID plugin initialized")}destroy(){this.did=null,super.destroy(),(0,a.log)("DID plugin destroyed")}assertDID(){if(this.assertInitialized(),!this.did)throw new Error("DID module not initialized");return this.did}async getCurrentUserDID(){return this.assertDID().getCurrentUserDID()}async resolveDID(e){return this.assertDID().resolveDID(e)}async authenticateWithDID(e,t){return this.assertDID().authenticateWithDID(e,t)}async createDID(e){return this.assertDID().createDID(e)}async updateDIDDocument(e,t){return this.assertDID().updateDIDDocument(e,t)}async deactivateDID(e){return this.assertDID().deactivateDID(e)}async registerDIDOnChain(e,t){return this.assertDID().registerDIDOnChain(e,t)}async verifyDIDOnChain(e){return this.assertDID().verifyDIDOnChain(e)}async ensureUserHasDID(e){try{const t=this.core;if(!t)throw new Error("Core not available");return t.isLoggedIn()?await Promise.race([this._ensureUserHasDIDWithTimeout(e),new Promise((e=>{setTimeout((()=>{(0,a.logError)("Timeout during DID creation/verification"),e(null)}),5e3)}))]):((0,a.logError)("Cannot ensure DID: user not authenticated"),null)}catch(e){return s.ErrorHandler.handle(s.ErrorType.DID,"ENSURE_DID_FAILED",`Error ensuring user has DID: ${e instanceof Error?e.message:String(e)}`,e),null}}async _ensureUserHasDIDWithTimeout(e){const t=this.assertInitialized();let r=await this.getCurrentUserDID();if(r){if((0,a.log)(`User already has DID: ${r}`),e&&Object.keys(e).length>0)try{await this.updateDIDDocument(r,{service:e.services?.map(((e,t)=>({id:`${r}#service-${t+1}`,type:e.type,serviceEndpoint:e.endpoint})))})&&(0,a.log)(`Updated DID document for: ${r}`)}catch(e){(0,a.logError)("Error updating DID document:",e)}return r}(0,a.log)("Creating new DID for authenticated user");const n=t.gundb.gun.user().is?.pub??"",i={network:"main",controller:n,...e};return r=await this.createDID(i),t.emit("did:created",{did:r,userPub:n}),(0,a.log)(`Created new DID for user: ${r}`),r||null}}t.DIDPlugin=o},8804:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunDID=void 0;const n=r(4193),i=r(5628),a=r(3358),s=r(4134);class o extends s.EventEmitter{core;methodName="shogun";didCache=new Map;DEFAULT_CACHE_DURATION=18e5;DEFAULT_TIMEOUT=1e4;DEFAULT_MAX_RETRIES=3;DEFAULT_RETRY_DELAY=1e3;options;registryConfig={address:"0x1234...",network:"mainnet",timeout:this.DEFAULT_TIMEOUT,maxRetries:this.DEFAULT_MAX_RETRIES,retryDelay:this.DEFAULT_RETRY_DELAY};constructor(e,t,r){super(),this.core=e,this.registryConfig={...this.registryConfig,...t},this.options=r||{useSecureRandomPassword:!0},(0,i.log)("ShogunDID initialized")}async createDID(e={}){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to create a DID");const t=this.getUserPublicKey();if(!t)throw new Error("Cannot retrieve user's public key");let r=n.ethers.keccak256(n.ethers.toUtf8Bytes(t)).slice(2,42);e.network&&(r=`${e.network}:${r}`);const a=`did:${this.methodName}:${r}`;return await this.storeDID(a,e),this.emit("didCreated",{did:a}),(0,i.log)(`Created DID: ${a}`),a}catch(e){throw(0,i.logError)("Error creating DID:",e),a.ErrorHandler.handle(a.ErrorType.DID,"CREATE_DID_ERROR",e instanceof Error?e.message:"Error creating DID",e),e}}async storeDID(e,t){try{if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=t.document||this.createDidDocument(e,t);return new Promise(((t,n)=>{this.core.gun.get("dids").get(e).put({document:JSON.stringify(r),created:(new Date).toISOString(),updated:(new Date).toISOString(),deactivated:!1},(r=>{r.err?n(new Error(`Failed to store DID: ${r.err}`)):this.core.gun.user().get("did").put(e,(e=>{e.err&&(0,i.logError)(`Warning: DID created but not associated with user: ${e.err}`),t()}))})),setTimeout((()=>n(new Error("Timeout storing DID"))),1e4)}))}catch(e){throw(0,i.logError)("Error storing DID:",e),e}}createDidDocument(e,t){const r=t.controller??this.getUserPublicKey()??e,i={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:r,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${this.getUserPublicKey()||n.ethers.keccak256(n.ethers.toUtf8Bytes(e))}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(i.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),i}getUserPublicKey(){try{if(!this.core.isLoggedIn())return null;const e=this.core.gun.user();return(e&&e._&&e._.sea&&e._.sea.pub)??null}catch(e){return(0,i.logError)("Error getting user public key:",e),null}}async resolveDID(e,t={}){try{const r=t.cacheDuration??this.DEFAULT_CACHE_DURATION,n=t.timeout??this.DEFAULT_TIMEOUT,i=this.didCache.get(e);if(i&&Date.now()-i.timestamp<r)return{didResolutionMetadata:{contentType:"application/did+json"},didDocument:this.getDocumentFromCache(i),didDocumentMetadata:{}};if(!this.isValidDID(e))return this.createErrorResolution("invalidDid","Invalid DID format");const[a,s,o]=e.split(":");return s!==this.methodName?this.createErrorResolution("unsupportedDidMethod",`Unsupported DID method: ${s}`):new Promise(((t,r)=>{const i=setTimeout((()=>{t(this.createErrorResolution("timeout","DID resolution timeout"))}),n);this.core.gun.get("dids").get(e).once((r=>{if(clearTimeout(i),r)try{const n=this.parseOrCreateDIDDocument(e,r);this.didCache.set(e,{data:n,document:n,timestamp:Date.now(),network:o.split(":")[0]||"main"}),t({didResolutionMetadata:{contentType:"application/did+json"},didDocument:n,didDocumentMetadata:{created:r.created,updated:r.updated,deactivated:r.deactivated??!1}})}catch(e){t(this.createErrorResolution("invalidDidDocument","Error parsing DID Document"))}else t(this.createErrorResolution("notFound","DID Document not found"))}))}))}catch(e){return(0,i.logError)("Error resolving DID:",e),this.createErrorResolution("internalError",e instanceof Error?e.message:"Unknown error")}}async registerDIDOnChain(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to register DID on chain");let r=t;if(!r)throw new Error("No signer provided and main wallet not available");const a=["function registerDID(string did, string controller) public returns (bool)"],s=new n.ethers.Contract(this.registryConfig.address,a,r);for(let t=1;t<=this.registryConfig.maxRetries;t++)try{const t=await s.registerDID(e,this.getUserPublicKey()),r=await t.wait();return this.emit("didRegistered",{did:e,txHash:r.hash}),(0,i.log)(`DID registered on blockchain: ${e}, tx: ${r.hash}`),{success:!0,txHash:r.hash}}catch(e){if(t===this.registryConfig.maxRetries)throw e;await new Promise((e=>setTimeout(e,this.registryConfig.retryDelay)))}throw new Error("Failed to register DID after retries")}catch(e){return(0,i.logError)("Error registering DID on blockchain:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getCurrentUserDID(){try{if(!this.core.isLoggedIn())return null;return this.getUserPublicKey()?new Promise((e=>{this.core.gun.user().get("did").once((t=>{e(t&&"string"==typeof t?t:null)})),setTimeout((()=>e(null)),5e3)})):null}catch(e){return(0,i.logError)("Error getting current user DID:",e),null}}async authenticateWithDID(e,t){try{if((0,i.log)(`Authenticating with DID: ${e}`),!this.isValidDID(e))return{success:!1,error:"Invalid DID format"};const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)return{success:!1,error:`DID resolution failed: ${r.didResolutionMetadata.error}`};const n=this.extractAuthenticationMethod(r.didDocument);return n?n.type.includes("EcdsaSecp256k1")?this.authenticateWithEthereum(n,t):n.type.includes("WebAuthn")?this.authenticateWithWebAuthn(n,t):this.authenticateWithGunDB(n.controller.split(":").pop()??"",t):{success:!1,error:"No valid authentication method found in DID Document"}}catch(e){return(0,i.logError)("Error authenticating with DID:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error during authentication"}}}async updateDIDDocument(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to update a DID document");if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)throw new Error(`Cannot update DID document: ${r.didResolutionMetadata.error??"Document not found"}`);const n=r.didDocument,a={...n,...t};if(t.service&&n.service){const e=[...n.service];for(const r of t.service){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}a.service=e}if(t.verificationMethod&&n.verificationMethod){const e=[...n.verificationMethod];for(const r of t.verificationMethod){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}a.verificationMethod=e}await this.storeDID(e,{document:a});const[s,,o]=e.split(":");return this.didCache.set(e,{data:a,document:a,timestamp:Date.now(),network:o.split(":")[0]||"main"}),this.emit("didUpdated",{did:e,document:a}),(0,i.log)(`Updated DID Document: ${e}`),!0}catch(e){return(0,i.logError)("Error updating DID document:",e),a.ErrorHandler.handle(a.ErrorType.DID,"UPDATE_DID_ERROR",e instanceof Error?e.message:"Error updating DID",e),!1}}async deactivateDID(e){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to deactivate a DID");const t=await this.getCurrentUserDID();if(e!==t)throw new Error("Cannot deactivate a DID you don't control");return new Promise((t=>{this.core.gun.get("dids").get(e).put({deactivated:!0,updated:(new Date).toISOString()},(r=>{r.err?((0,i.logError)(`Error deactivating DID: ${r.err}`),t(!1)):((0,i.log)(`Successfully deactivated DID: ${e}`),t(!0))})),setTimeout((()=>t(!1)),1e4)}))}catch(e){return(0,i.logError)("Error deactivating DID:",e),!1}}isValidDID(e){return/^did:[a-z0-9]+:[a-zA-Z0-9.:%]+$/.test(e)}generateDIDDocument(e,t={}){const r=this.getUserPublicKey(),n={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:t.controller??e,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${r}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(n.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),n}createErrorResolution(e,t){return{didResolutionMetadata:{error:e,contentType:"application/did+json"},didDocument:null,didDocumentMetadata:{}}}parseOrCreateDIDDocument(e,t){if(t.document)try{return JSON.parse(t.document)}catch(e){(0,i.logError)("Error parsing stored DID Document, creating a basic one",e)}return{"@context":"https://www.w3.org/ns/did/v1",id:e,authentication:[]}}extractAuthenticationMethod(e){const t=e.authentication||[];for(const r of t){if("string"!=typeof r)return r;{const t=r,n=e.verificationMethod?.find((e=>e.id===t));if(n)return{id:n.id,type:n.type,controller:n.controller}}}return null}async authenticateWithEthereum(e,t){const r=e.id.split("#")[0].split(":").pop()||"";if("loginWithMetaMask"in this.core)return this.core.loginWithMetaMask(r);if(!this.core.getAuthenticationMethod)return{success:!1,error:"Authentication method provider not available"};const n=this.core.getAuthenticationMethod("metamask");return n&&"object"==typeof n&&"login"in n?n.login(r):{success:!1,error:"MetaMask authentication not available"}}async authenticateWithWebAuthn(e,t){const r=e.controller.split(":").pop()||"";if("loginWithWebAuthn"in this.core)return this.core.loginWithWebAuthn(r);if(!this.core.getAuthenticationMethod)return{success:!1,error:"Authentication method provider not available"};const n=this.core.getAuthenticationMethod("webauthn");return n&&"object"==typeof n&&"login"in n?n.login(r):{success:!1,error:"WebAuthn authentication not available"}}async authenticateWithGunDB(e,t){try{(0,i.log)("Authenticating with GunDB using password method",e);let r=t??"";this.options&&this.options.useSecureRandomPassword&&!r&&(r=function(e=32){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>e.toString(16).padStart(2,"0"))).join("")}());const n=await async function(e,t){const r=(new TextEncoder).encode(`${e}:${t}`),n=await crypto.subtle.digest("SHA-256",r);return Array.from(new Uint8Array(n)).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e,r);if(!this.core.getAuthenticationMethod)throw new Error("Authentication method provider not available");const a=this.core.getAuthenticationMethod("password");if(!a)throw new Error("Password authentication method not available");return await a.authenticate(e,n)}catch(e){throw(0,i.log)("Error authenticating with GunDB:",e),e}}async verifyDIDOnChain(e,t){try{const r=["function isDIDRegistered(string did) public view returns (bool)","function getDIDController(string did) public view returns (string)"],i=this.options.didRegistryAddress,a=new n.ethers.Contract(i,r,t);if(!await a.isDIDRegistered(e))return{isRegistered:!1};return{isRegistered:!0,controller:await a.getDIDController(e)}}catch(e){return(0,i.logError)("Error verifying DID on blockchain:",e),{isRegistered:!1,error:e instanceof Error?e.message:"Unknown error"}}}clearCache(){this.didCache.clear(),this.emit("cacheCleared")}removeFromCache(e){this.didCache.delete(e),this.emit("didRemovedFromCache",{did:e})}getDocumentFromCache(e){return e.data?e.data:e.document?e.document:null}}t.ShogunDID=o},8929:function(e,t,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),i=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.DIDPlugin=void 0;var a=r(8635);Object.defineProperty(t,"DIDPlugin",{enumerable:!0,get:function(){return a.DIDPlugin}}),i(r(8804),t)},8991:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MetaMaskPlugin=void 0;const n=r(4586),i=r(7160),a=r(5628),s=r(4193),o=r(3358);class l extends n.BasePlugin{name="metamask";version="1.0.0";description="Provides MetaMask wallet connection and authentication for ShogunCore";metamask=null;initialize(e){super.initialize(e),this.metamask=new i.MetaMask,(0,a.log)("MetaMask plugin initialized")}destroy(){this.metamask&&this.metamask.cleanup(),this.metamask=null,super.destroy(),(0,a.log)("MetaMask plugin destroyed")}assertMetaMask(){if(this.assertInitialized(),!this.metamask)throw new Error("MetaMask module not initialized");return this.metamask}isAvailable(){return this.assertMetaMask().isAvailable()}async connectMetaMask(){return this.assertMetaMask().connectMetaMask()}async generateCredentials(e){return(0,a.log)("Calling credential generation"),this.assertMetaMask().generateCredentials(e)}cleanup(){this.assertMetaMask().cleanup()}setCustomProvider(e,t){this.assertMetaMask().setCustomProvider(e,t)}async getSigner(){return this.assertMetaMask().getSigner()}async getProvider(){return this.assertMetaMask().getProvider()}async generatePassword(e){return this.assertMetaMask().generatePassword(e)}async verifySignature(e,t){return this.assertMetaMask().verifySignature(e,t)}async login(e){(0,a.log)("Login with MetaMask");try{const t=this.assertInitialized();if((0,a.log)(`MetaMask login attempt for address: ${e}`),!e)throw(0,o.createError)(o.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask login");if(!this.isAvailable())throw(0,o.createError)(o.ErrorType.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,a.log)("Generating credentials for MetaMask login...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,a.log)(`Credentials generated successfully. Username: ${r.username}`),(0,a.log)("Verifying MetaMask signature...");const n=s.ethers.verifyMessage(r.message,r.signature);if(n.toLowerCase()!==e.toLowerCase())throw(0,a.logError)(`Signature verification failed. Expected: ${e}, Got: ${n}`),(0,o.createError)(o.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,a.log)("MetaMask signature verified successfully."),(0,a.log)("Attempting login or user creation with verified credentials...");const i=t.createUserWithGunDB.bind(t),l=await i(r.username,r.password);if(!l.success||!l.userPub)throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"LOGIN_CREATE_FAILED",l.error??"Login or user creation failed after signature verification");(0,a.log)(`Login/Creation successful: ${l.userPub}`);let c=null;try{(0,a.log)("Ensuring user has a DID...");const r=t.ensureUserHasDID.bind(t);c=await r({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),c?(0,a.log)(`DID assigned/verified: ${c}`):(0,a.logWarn)("Could not ensure DID for user after MetaMask login.")}catch(e){o.ErrorHandler.handle(o.ErrorType.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user",e)}return t.emit("auth:login",{userPub:l.userPub,username:r.username,method:"metamask",did:c||void 0}),{success:!0,userPub:l.userPub,username:r.username,did:c||void 0}}catch(e){const t=e?.type||o.ErrorType.AUTHENTICATION,r=e?.code||"METAMASK_LOGIN_ERROR",n=e?.message||"Unknown error during MetaMask login";return{success:!1,error:o.ErrorHandler.handle(t,r,n,e).message}}}async signUp(e){(0,a.log)("Sign up with MetaMask");try{const t=this.assertInitialized();if((0,a.log)(`MetaMask registration attempt for address: ${e}`),!e)throw(0,o.createError)(o.ErrorType.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask registration");if(!this.isAvailable())throw(0,o.createError)(o.ErrorType.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,a.log)("Generating credentials for MetaMask registration...");const r=await this.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,a.log)(`Credentials generated successfully. Username: ${r.username}`),(0,a.log)("Verifying MetaMask signature...");const n=s.ethers.verifyMessage(r.message,r.signature);if(n.toLowerCase()!==e.toLowerCase())throw(0,a.logError)(`Signature verification failed. Expected: ${e}, Got: ${n}`),(0,o.createError)(o.ErrorType.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,a.log)("MetaMask signature verified successfully."),(0,a.log)("Attempting user creation (or login if exists) with verified credentials...");const i=t.createUserWithGunDB.bind(t),l=await i(r.username,r.password);if(!l.success||!l.userPub)throw(0,o.createError)(o.ErrorType.AUTHENTICATION,"USER_CREATE_LOGIN_FAILED",l.error??"User creation or login failed after signature verification");(0,a.log)(`User creation/login successful: ${l.userPub}`);let c=null;try{(0,a.log)("Creating/Ensuring DID with MetaMask verification service...");const r=t.ensureUserHasDID.bind(t);c=await r({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),c?(0,a.log)(`DID created/verified: ${c}`):(0,a.logWarn)("Could not ensure DID for user after MetaMask signup.")}catch(e){o.ErrorHandler.handle(o.ErrorType.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user during signup",e)}return t.emit("auth:signup",{userPub:l.userPub,username:r.username,method:"metamask",did:c??void 0}),{success:!0,userPub:l.userPub,username:r.username,did:c??void 0}}catch(e){const t=e?.type??o.ErrorType.AUTHENTICATION,r=e?.code??"METAMASK_SIGNUP_ERROR",n=e?.message??"Unknown error during MetaMask registration";return{success:!1,error:o.ErrorHandler.handle(t,r,n,e).message}}}async loginWithMetaMask(e){return this.login(e)}async signUpWithMetaMask(e){return this.signUp(e)}}t.MetaMaskPlugin=l},9148:function(e,t,r){"use strict";var n,i=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(t,r);i&&!("get"in i?!t.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,i)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),s=this&&this.__importStar||(n=function(e){return n=Object.getOwnPropertyNames||function(e){var t=[];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[t.length]=r);return t},n(e)},function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r=n(e),s=0;s<r.length;s++)"default"!==r[s]&&i(t,e,r[s]);return a(t,e),t}),o=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||i(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.ShogunCore=t.modules=void 0,t.initShogunBrowser=function(e){const t={...e};t.gundb??={localStorage:!1,radisk:!1},e.gundb?.peers||(0,c.log)("WARNING: Using default GunDB peers. For production, always configure custom peers.");return u=new l.ShogunCore(t),d=u?.gun||null,u};const l=r(8156);Object.defineProperty(t,"ShogunCore",{enumerable:!0,get:function(){return l.ShogunCore}});const c=r(5628);let u=null,d=null;t.modules={loadWebAuthn:()=>Promise.resolve().then((()=>s(r(409)))),loadStealth:()=>Promise.resolve().then((()=>s(r(2256)))),loadDID:()=>Promise.resolve().then((()=>s(r(4662)))),loadWallet:()=>Promise.resolve().then((()=>s(r(3011)))),loadMetaMask:()=>Promise.resolve().then((()=>s(r(8991))))},o(r(74),t),"undefined"!=typeof window&&(window.shogun=u,window.shogunGun=d)},9662:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DIDVerifier=void 0;const n=r(4193),i=r(3358),a=r(5628),s=["function registerDID(string memory did, string memory controller) public returns (bool success)","function getController(string memory did) public view returns (string memory controller)"];t.DIDVerifier=class{contract=null;provider=null;signer=null;contractAddress;shogun;constructor(e,t,r){this.contractAddress=e.contractAddress,this.shogun=t,this.signer=r||null;try{t?.provider?(this.provider=t.provider,(0,a.log)("Using provider from ShogunCore instance")):e.providerUrl?(this.provider=new n.ethers.JsonRpcProvider(e.providerUrl),(0,a.log)(`Created provider with URL: ${e.providerUrl}`)):(0,a.logError)("No provider available. Either pass a ShogunCore instance or providerUrl"),this.signer&&this.provider?(this.contract=new n.ethers.Contract(this.contractAddress,s,this.signer),(0,a.log)(`DIDVerifier initialized with signer at ${this.contractAddress}`)):this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.provider),(0,a.log)(`DIDVerifier initialized in read-only mode at ${this.contractAddress}`))}catch(e){i.ErrorHandler.handle(i.ErrorType.CONTRACT,"DID_VERIFIER_INIT_FAILED","Failed to initialize DIDVerifier",e)}}async verifyDID(e){try{if(!this.contract)throw new Error("Contract not initialized");if(!e||!e.trim())throw new Error("Invalid DID format: DID cannot be empty");const t=await this.contract.getController(e);return t&&""!==t.trim()?t:null}catch(t){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"DID_VERIFICATION_FAILED",`Failed to verify DID: ${e}`,t),null}}async isDIDControlledBy(e,t){try{return await this.verifyDID(e)===t}catch(r){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"DID_CONTROLLER_CHECK_FAILED",`Failed to check if DID ${e} is controlled by ${t}`,r),!1}}async authenticateWithDID(e,t,r){try{const i=await this.verifyDID(e);if(!i)return(0,a.log)(`DID not found: ${e}`),!1;const s=n.ethers.verifyMessage(t,r);return n.ethers.isAddress(i)&&i.toLowerCase()===s.toLowerCase()?((0,a.log)(`Successfully authenticated DID: ${e}`),!0):((0,a.log)(`Authentication failed for DID: ${e}. Controller mismatch.`),!1)}catch(t){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"DID_AUTHENTICATION_FAILED",`Failed to authenticate with DID: ${e}`,t),!1}}setProviderUrl(e){try{return this.provider=new n.ethers.JsonRpcProvider(e),!!this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.provider),(0,a.log)(`Updated provider URL to ${e}`),!0)}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"PROVIDER_UPDATE_FAILED","Failed to update provider URL",e),!1}}setContractAddress(e){try{if(!n.ethers.isAddress(e))throw new Error("Invalid contract address format");return this.contractAddress=e,!!this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.provider),(0,a.log)(`Updated contract address to ${e}`),!0)}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"CONTRACT_ADDRESS_UPDATE_FAILED","Failed to update contract address",e),!1}}async registerDID(e,t){try{if(!this.contract)throw new Error("Contract not initialized");if(!this.signer)throw new Error("Signer required for registerDID");const r=await this.contract.getFunction("registerDID")(e,t);return 1===(await r.wait()).status}catch(t){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"DID_REGISTRATION_FAILED",`Failed to register DID: ${e}`,t),!1}}setSigner(e){try{return this.signer=e,!!this.provider&&(this.contract=new n.ethers.Contract(this.contractAddress,s,this.signer),(0,a.log)("Updated signer for DIDVerifier"),!0)}catch(e){return i.ErrorHandler.handle(i.ErrorType.CONTRACT,"SIGNER_UPDATE_FAILED","Failed to update signer",e),!1}}}},9854:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GunConsensus=void 0;const n=r(7668);t.GunConsensus=class{gun;config;constructor(e,t={}){this.gun=e,this.config={threshold:t.threshold??.51,timeWindow:t.timeWindow??6e4,minVotes:t.minVotes??3}}async proposeChange(e,t,r={}){if(!this.gun.isLoggedIn())throw new Error("You must be authenticated to propose changes");const i=this.gun.getCurrentUser()?.pub;if(!i)throw new Error("Public key not available");const a=this.generateId(),s=Date.now(),o={id:a,topic:e,data:t,metadata:r,proposer:i,timestamp:s,expiresAt:s+this.config.timeWindow,status:"pending"},l=this.gun.getCurrentUser()?.user._.sea;if(!l)throw new Error("Key pair not available");const c=await(0,n.sign)(o,l);return new Promise(((e,t)=>{this.gun.get("consensus").get("proposals").get(a).put(c,(r=>{r.err?t(new Error(r.err)):e(a)}))}))}async vote(e,t,r=""){if(!this.gun.isLoggedIn())throw new Error("You must be authenticated to vote");const i=this.gun.getCurrentUser()?.pub;if(!i)throw new Error("Public key not available");const a=await this.getProposal(e);if(!a)throw new Error("Proposal not found");if(a.expiresAt<Date.now())throw new Error("Proposal expired");if(await this.getUserVote(e,i))throw new Error("You have already voted on this proposal");const s={voter:i,approve:t,comment:r,timestamp:Date.now()},o=this.gun.getCurrentUser()?.user._.sea;if(!o)throw new Error("Key pair not available");const l=await(0,n.sign)(s,o);return new Promise(((t,r)=>{this.gun.get("consensus").get("proposals").get(e).get("votes").get(i).put(l,(n=>{n.err?r(new Error(n.err)):this.updateProposalStatus(e).then((()=>t(!0))).catch(r)}))}))}async getProposal(e){return new Promise((t=>{this.gun.get("consensus").get("proposals").get(e).once((e=>{if(e)try{const r=("string"==typeof e?JSON.parse(e):e).proposer;if(!r)return void t(null);(0,n.verify)(e,r).then((e=>{t(e||null)})).catch((e=>{t(null)}))}catch(e){t(null)}else t(null)}))}))}async getUserVote(e,t){return new Promise((r=>{this.gun.get("consensus").get("proposals").get(e).get("votes").get(t).once((e=>{r(e||null)}))}))}async updateProposalStatus(e){const t=await this.countVotes(e);if(t.totalVotes>=this.config.minVotes){const r=t.approvalCount/t.totalVotes;r>=this.config.threshold?await this.finalizeProposal(e,"approved"):r+(1-t.totalVotes)<this.config.threshold&&await this.finalizeProposal(e,"rejected")}}async countVotes(e){return new Promise((t=>{let r=0,i=0,a=0;this.gun.get("consensus").get("proposals").get(e).get("votes").map().once((async(e,t)=>{if(e&&"_"!==t)try{const t=("string"==typeof e?JSON.parse(e):e).voter;if(!t)return;const s=await(0,n.verify)(e,t);s&&(a++,s.approve?r++:i++)}catch(e){}})),setTimeout((()=>{t({approved:r>=this.config.threshold*a,approvalCount:r,rejectionCount:i,totalVotes:a})}),100)}))}async finalizeProposal(e,t){return new Promise(((r,n)=>{this.gun.get("consensus").get("proposals").get(e).get("status").put(t,(e=>{e.err?n(new Error(e.err)):r()}))}))}generateId(){return Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15)}}}},r={};function n(e){var i=r[e];if(void 0!==i)return i.exports;var a=r[e]={id:e,loaded:!1,exports:{}};return t[e].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=t,e=[],n.O=(t,r,i,a)=>{if(!r){var s=1/0;for(u=0;u<e.length;u++){for(var[r,i,a]=e[u],o=!0,l=0;l<r.length;l++)(!1&a||s>=a)&&Object.keys(n.O).every((e=>n.O[e](r[l])))?r.splice(l--,1):(o=!1,a<s&&(s=a));if(o){e.splice(u--,1);var c=i();void 0!==c&&(t=c)}}return t}a=a||0;for(var u=e.length;u>0&&e[u-1][2]>a;u--)e[u]=e[u-1];e[u]=[r,i,a]},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e={792:0};n.O.j=t=>0===e[t];var t=(t,r)=>{var i,a,[s,o,l]=r,c=0;if(s.some((t=>0!==e[t]))){for(i in o)n.o(o,i)&&(n.m[i]=o[i]);if(l)var u=l(n)}for(t&&t(r);c<s.length;c++)a=s[c],n.o(e,a)&&e[a]&&e[a][0](),e[a]=0;return n.O(u)},r=this.webpackChunkShogunCore=this.webpackChunkShogunCore||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var i=n.O(void 0,[96],(()=>n(9148)));return i=(i=n.O(i)).default})()));