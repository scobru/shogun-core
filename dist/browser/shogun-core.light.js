!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ShogunCore=t():e.ShogunCore=t()}(this,(()=>(()=>{var e,t,r,i={228:(e,t,r)=>{"use strict";r.d(t,{C:()=>p});var i=r(6525),s=r(1442),n=r(31),a=r(2011),o=r(7303),u=r(8051),c=r(4532),d=r(7649),h=r(5628),l=r(7028),g=r(3358),m=r(7007);class p extends m.EventEmitter{constructor(e={}){super(),this.MESSAGE_TO_SIGN="I Love Shogun!",this.DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4},this.signatureCache=new Map,this.provider=null,this.customProvider=null,this.customWallet=null,this.config={...this.DEFAULT_CONFIG,...e},this.AUTH_DATA_TABLE=l.A.GUN_TABLES.AUTHENTICATIONS||"Authentications",this.setupProvider(),this.setupEventListeners()}async setupProvider(){try{"undefined"!=typeof window&&window.ethereum?(this.provider=new i.k(window.ethereum),(0,h.MD)("BrowserProvider initialized successfully")):(0,h.JE)("Window.ethereum is not available")}catch(e){(0,h.vV)("Failed to initialize BrowserProvider",e)}}setupEventListeners(){this.provider&&(this.provider.on("network",((e,t)=>{this.emit("chainChanged",e)})),window.ethereum?.on&&window.ethereum.on("accountsChanged",(e=>{this.emit("accountsChanged",e)})))}cleanup(){this.provider&&this.provider.removeAllListeners(),this.removeAllListeners()}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim().toLowerCase();if(!s.PW(t))throw new Error("Invalid address format");return n.b(t)}catch(e){throw g.zc.handle(g.By.VALIDATION,"INVALID_ADDRESS","Invalid Ethereum address provided",e),e}}async connectMetaMask(){try{if((0,h.MD)("Attempting to connect to MetaMask..."),!this.provider&&((0,h.MD)("Provider not initialized, setting up..."),await this.setupProvider(),!this.provider))throw new Error("MetaMask is not available. Please install MetaMask extension.");(0,h.MD)("Requesting account access...");let e=[];if(window.ethereum)try{e=await window.ethereum.request({method:"eth_requestAccounts"}),(0,h.MD)(`Accounts requested successfully: ${e.length} accounts returned`)}catch(e){throw(0,h.vV)("Error requesting MetaMask accounts:",e),new Error("User denied account access")}e&&0!==e.length||(0,h.MD)("No accounts found, trying to get signer...");for(let e=1;e<=this.config.maxRetries;e++)try{(0,h.MD)(`Attempt ${e} to get signer...`);const t=await this.provider.getSigner(),r=await t.getAddress();if(!r)throw(0,h.vV)("No address returned from signer"),new Error("No accounts found in MetaMask");(0,h.MD)(`Signer address obtained: ${r}`);const i=`mm_${r.toLowerCase()}`;return this.emit("connected",{address:r}),(0,h.MD)(`MetaMask connected successfully with address: ${r}`),{success:!0,address:r,username:i}}catch(t){if((0,h.vV)(`Error in connection attempt ${e}:`,t),e===this.config.maxRetries)throw t;(0,h.MD)(`Retrying in ${this.config.retryDelay}ms...`),await new Promise((e=>setTimeout(e,this.config.retryDelay)))}throw new Error("Failed to connect after retries")}catch(e){return(0,h.vV)("Failed to connect to MetaMask:",e),g.zc.handle(g.By.NETWORK,"METAMASK_CONNECTION_ERROR",e.message||"Unknown error while connecting to MetaMask",e),{success:!1,error:e.message}}}async generateCredentials(e){(0,h.MD)("Generating credentials for address:",e);try{const t=this.validateAddress(e),r=this.getCachedSignature(t);if(r)return(0,h.MD)("Using cached signature for address:",t),this.generateCredentialsFromSignature(t,r);try{const e=await this.requestSignatureWithTimeout(t,this.MESSAGE_TO_SIGN,this.config.timeout);return this.cacheSignature(t,e),this.generateCredentialsFromSignature(t,e)}catch(e){return(0,h.JE)(`Failed to get signature: ${e}. Using fallback method.`),this.generateFallbackCredentials(t)}}catch(e){throw g.zc.handle(g.By.AUTHENTICATION,"CREDENTIALS_GENERATION_ERROR",e.message||"Error generating MetaMask credentials",e),e}}generateCredentialsFromSignature(e,t){return{username:`mm_${e.toLowerCase()}`,password:a.S(o.YW(`${t}:${e.toLowerCase()}`)),message:this.MESSAGE_TO_SIGN,signature:t}}generateFallbackCredentials(e){(0,h.JE)("Using fallback credentials generation for address:",e);const t=`mm_${e.toLowerCase()}`,r=`SHOGUN_FALLBACK:${e.toLowerCase()}`;return{username:t,password:a.S(o.YW(r)),message:r,signature:a.S(o.YW(r))}}static isMetaMaskAvailable(){const e=window.ethereum;return"undefined"!=typeof window&&void 0!==e&&!0===e?.isMetaMask}async requestSignatureWithTimeout(e,t,r=3e4){return new Promise((async(i,s)=>{let n=setTimeout((()=>{n=null,s(new Error("Timeout requesting signature"))}),r);try{if(!this.provider&&(await this.setupProvider(),!this.provider))throw new Error("Provider not initialized");let r,a;try{r=await this.provider.getSigner()}catch(e){throw(0,h.vV)("Failed to get signer:",e),new Error(`Failed to get signer: ${e.message}`)}try{a=await r.getAddress()}catch(e){throw(0,h.vV)("Failed to get signer address:",e),new Error(`Failed to get signer address: ${e.message}`)}if(a.toLowerCase()!==e.toLowerCase())throw new Error(`Signer address (${a}) does not match expected address (${e})`);(0,h.MD)(`Requesting signature for message: ${t}`);const o=e=>{n&&(clearTimeout(n),n=null),s(e)};window.ethereum?.on&&window.ethereum.on("accountsChanged",o);try{const e=await r.signMessage(t);(0,h.MD)("Signature obtained successfully"),n&&(clearTimeout(n),n=null),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",o),i(e)}catch(e){throw(0,h.vV)("Error during message signing:",e),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",o),e}}catch(e){(0,h.vV)("Failed to request signature:",e),n&&(clearTimeout(n),n=null),s(e)}}))}isAvailable(){return"undefined"!=typeof window&&!!window.ethereum}setCustomProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Invalid RPC URL");if(!t||"string"!=typeof t)throw new Error("Invalid private key");try{this.customProvider=new u.FR(e),this.customWallet=new c.u(t,this.customProvider),(0,h.MD)("Custom provider configured successfully")}catch(e){throw new Error(`Error configuring provider: ${e.message||"Unknown error"}`)}}async getSigner(){try{if(this.customWallet)return this.customWallet;if(this.provider||await this.setupProvider(),!this.provider)throw new Error("Provider not initialized");return await this.provider.getSigner()}catch(e){throw new Error(`Unable to get Ethereum signer: ${e.message||"Unknown error"}`)}}async generatePassword(e){if(!e)throw new Error("Invalid signature");return a.S(o.YW(e)).slice(2,66)}async verifySignature(e,t){if(!e||!t)throw new Error("Invalid message or signature");try{return d.l(e,t)}catch(e){throw new Error("Invalid message or signature")}}async getEthereumSigner(){if(!p.isMetaMaskAvailable())throw new Error("MetaMask not found. Please install MetaMask to continue.");try{const e=window.ethereum;await e.request({method:"eth_requestAccounts"});return new i.k(e).getSigner()}catch(e){throw new Error(`Error accessing MetaMask: ${e.message||"Unknown error"}`)}}}"undefined"!=typeof window?window.MetaMask=p:void 0!==r.g&&(r.g.MetaMask=p)},409:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Webauthn:()=>i,default:()=>s});class i{constructor(){}isSupported(){return!1}validateUsername(){throw new Error("WebAuthn functionality disabled in light version")}async createAccount(){throw new Error("WebAuthn functionality disabled in light version")}async authenticateUser(){throw new Error("WebAuthn functionality disabled in light version")}async sign(){throw new Error("WebAuthn functionality disabled in light version")}}const s=i},1751:(e,t,r)=>{"use strict";var i=r(9229),s=r.n(i),n=(r(8030),r(7028)),a=r(5628),o=r(3358);class u{constructor(e={}){this.user=null,this.certificato=null,this.onAuthCallbacks=[],this._authenticating=!1,(0,a.Rm)("Initializing GunDB"),this.retryConfig={attempts:e.retryAttempts??3,delay:e.retryDelay??1e3};const t={peers:e.peers,localStorage:e.localStorage??!1,radisk:e.radisk??!1,multicast:e.multicast??!1,axe:e.axe??!1};if(e.authToken){const t=e.authToken.substring(0,3)+"..."+(e.authToken.length>6?e.authToken.substring(e.authToken.length-3):"");(0,a.Rm)(`Auth token received (${t})`)}else(0,a.Rm)("No auth token received");this.gun=new(s())(t),this.user=this.gun.user().recall({sessionStorage:!0});e.authToken&&(s().on("opt",(function(e){e.once||e.on("out",(function(t){var r=e.to;t.headers={token:"thisIsTheTokenForReals"},r.next(t)}))})),(0,a.Rm)("Auth token handler configured for outgoing messages")),this.subscribeToAuthEvents()}async retry(e,t){let r;for(let i=0;i<this.retryConfig.attempts;i++)try{return await e()}catch(e){if(r=e instanceof Error?e:new Error(String(e)),i<this.retryConfig.attempts-1){const e=this.retryConfig.delay*Math.pow(2,i);(0,a.Rm)(`Retry attempt ${i+1} for ${t} in ${e}ms`),await new Promise((t=>setTimeout(t,e)))}}throw r}subscribeToAuthEvents(){this.gun.on("auth",(e=>{(0,a.Rm)("Auth event received:",e),e.err?o.zc.handle(o.By.GUN,"AUTH_EVENT_ERROR",e.err,new Error(e.err)):this.notifyAuthListeners(e.sea?.pub||"")}))}notifyAuthListeners(e){const t=this.gun.user();this.onAuthCallbacks.forEach((e=>{e(t)}))}static withPeers(e=n.A.PEERS){return new u({peers:e})}onAuth(e){this.onAuthCallbacks.push(e);const t=this.gun.user();return t&&t.is&&e(t),()=>{const t=this.onAuthCallbacks.indexOf(e);-1!==t&&this.onAuthCallbacks.splice(t,1)}}getGun(){return this.gun}getUser(){return this.gun.user()}setCertificate(e){this.certificato=e;this.gun.user().get("trust").get("certificate").put(e)}getCertificate(){return this.certificato}async signUp(e,t){try{return(0,a.Rm)("Attempting user registration:",e),new Promise((r=>{this.gun.user().create(e,t,(async i=>{if(i.err)(0,a.vV)(`Registration error: ${i.err}`),r({success:!1,error:i.err});else{const i=await this.login(e,t);i.success?(0,a.Rm)("Registration and login completed successfully"):(0,a.vV)("Registration completed but login failed"),r(i)}}))}))}catch(e){return(0,a.vV)("Error during registration:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}login(e,t,r){return(0,a.Rm)(`Attempting login for user: ${e}`),new Promise(((i,s)=>{if(!e||!t){const e="Username and password are required";return(0,a.Rm)(e),r&&r({err:e}),void s(new Error(e))}try{this.gun.user().leave(),(0,a.Rm)("Current user reset before login attempt")}catch(e){}(0,a.Rm)(`Performing auth with Gun for user: ${e}`),this.gun.user().auth(e,t,(t=>{if(t.err)(0,a.Rm)(`Login error: ${t.err}`),r&&r({err:t.err}),s(new Error(t.err));else{(0,a.Rm)("Authentication completed successfully");try{this._savePair(),(0,a.Rm)("User auth pair saved")}catch(e){(0,a.Rm)(`Warning: Error saving auth pair: ${e}`)}r&&r(t),i({success:!0,userPub:this.gun.user().is?.pub,username:e})}}))}))}_savePair(){try{const e=this.gun.user(),t=e._&&e._.sea;t&&"undefined"!=typeof localStorage&&localStorage.setItem("pair",JSON.stringify(t))}catch(e){}}isAuthenticating(){return!0===this._authenticating}_setAuthenticating(e){this._authenticating=e}logout(){try{(0,a.Rm)("Attempting logout"),this.gun.user().leave(),(0,a.Rm)("Logout completed")}catch(e){(0,a.vV)("Error during logout:",e)}}isLoggedIn(){const e=this.gun.user();return!!(e&&e.is&&e.is.pub)}getCurrentUser(){const e=this.gun.user()?.is?.pub;return e?{pub:e,user:this.gun.user()}:null}async saveWithRetry(e,t,r){return this.retry((()=>new Promise(((i,s)=>{e.put(t,(e=>{e.err?s(new Error(e.err)):i(t)}),r)}))),"data save operation")}async readWithRetry(e){return this.retry((()=>new Promise((t=>{e.once((e=>t(e)))}))),"data read operation")}async saveUserData(e,t){try{if(!this.gun.user()?.is?.pub)throw new Error("User not authenticated");const r=this.certificato?{opt:{cert:this.certificato}}:void 0;return await this.saveWithRetry(this.gun.user().get(e),t,r)}catch(t){throw o.zc.handle(o.By.GUN,"SAVE_USER_DATA_ERROR",`Error saving data to path ${e}`,t),t}}async getUserData(e){try{if(!this.gun.user()?.is?.pub)throw new Error("User not authenticated");const t=await this.readWithRetry(this.gun.user().get(e));return t?((0,a.Rm)(`Data retrieved from ${e}`),t):((0,a.Rm)(`No data found at ${e}`),null)}catch(t){throw o.zc.handle(o.By.GUN,"GET_USER_DATA_ERROR",`Error retrieving data from path ${e}`,t),t}}async savePublicData(e,t,r){return new Promise(((i,s)=>{const n=this.certificato?{opt:{cert:this.certificato}}:void 0;this.gun.get(e).get(t).put(r,(n=>{n&&n.err?((0,a.vV)(`Error saving public data: ${n.err}`),s(new Error(n.err))):((0,a.Rm)(`Public data saved to ${e}/${t}`),i(r))}),n)}))}async getPublicData(e,t){return new Promise((r=>{this.gun.get(e).get(t).once((i=>{i?((0,a.Rm)(`Public data retrieved from ${e}/${t}`),r(i)):((0,a.Rm)(`No public data found at ${e}/${t}`),r(null))}))}))}async generateKeyPair(){return s().SEA.pair()}}"undefined"!=typeof window?window.GunDB=u:void 0!==r.g&&(r.g.GunDB=u);var c,d,h=r(7007);class l{constructor(){if(this.store=new Map,"undefined"!=typeof localStorage)try{const e=localStorage.getItem("shogun_keypair");e&&this.store.set("keypair",JSON.parse(e))}catch(e){}}async getPair(){return this.getPairSync()}getPairSync(){return this.store.get("keypair")||null}async setPair(e){if(this.store.set("keypair",e),"undefined"!=typeof localStorage)try{localStorage.setItem("shogun_keypair",JSON.stringify(e))}catch(e){}}clearAll(){if(this.store.clear(),"undefined"!=typeof localStorage)try{localStorage.removeItem("shogun_keypair")}catch(e){}}getItem(e){const t=this.store.get(e);return void 0!==t?JSON.stringify(t):null}setItem(e,t){try{const r=JSON.parse(t);if(this.store.set(e,r),"undefined"!=typeof localStorage)try{localStorage.setItem(e,t)}catch(e){}}catch(r){if(this.store.set(e,t),"undefined"!=typeof localStorage)try{localStorage.setItem(e,t)}catch(e){}}}removeItem(e){if(this.store.delete(e),"undefined"!=typeof localStorage)try{localStorage.removeItem(e)}catch(e){}}}!function(e){e.Authentication="authentication",e.Wallet="wallet",e.Privacy="privacy",e.Identity="identity",e.Utility="utility"}(c||(c={})),function(e){e.WebAuthn="webauthn",e.MetaMask="metamask",e.Stealth="stealth",e.DID="did",e.WalletManager="wallet"}(d||(d={}));var g=r(8051),m=r(7776),p=r(2011),f=r(7303),w=r(7649),y=r(5330),E=r(5010);class D{constructor(e){this.gun=e,this.user=e.user().recall({sessionStorage:!0})}getUser(){return this.user}getUserPub(){return this.user.is?.pub}observe(e){return new y.c((t=>{const r="string"==typeof e?this.gun.get(e):e,i=r.on(((e,r)=>{if(null!=e)if("object"==typeof e&&null!==e){const r=this.removeGunMeta(e);t.next(r)}else t.next(e);else t.next(null)}));return()=>{i&&"function"==typeof i&&i(),r.off()}})).pipe((0,E.F)(((e,t)=>JSON.stringify(e)===JSON.stringify(t))))}match(e,t){return new y.c((r=>{const i="string"==typeof e?this.gun.get(e):e,s={},n=i.map().on(((e,i)=>{if("_"===i||!e)return;if(t&&!t(e))return void(s[i]&&(delete s[i],r.next(Object.values(s))));const n="object"==typeof e?this.removeGunMeta(e):e;s[i]=n,r.next(Object.values(s))}));return()=>{n&&"function"==typeof n&&n(),i.off()}}))}put(e,t){const r="string"==typeof e?this.gun.get(e):e;return new y.c((e=>{r.put(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}set(e,t){const r="string"==typeof e?this.gun.get(e):e;return new y.c((e=>{r.set(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}once(e){const t="string"==typeof e?this.gun.get(e):e;return new y.c((e=>{t.once((t=>{if(null==t)return e.next(null),void e.complete();const r="object"==typeof t?this.removeGunMeta(t):t;e.next(r),e.complete()}))}))}compute(e,t){const r=e.map((e=>"string"==typeof e?this.observe(e):e));return new y.c((i=>{let s=new Array(e.length).fill(void 0),n=new Array(e.length).fill(!1);const a=r.map(((e,r)=>e.subscribe({next:e=>{if(s[r]=e,s.every((e=>void 0!==e)))try{const e=t(...s);i.next(e)}catch(e){i.error(e)}},error:e=>i.error(e),complete:()=>{n[r]=!0,n.every((e=>e))&&i.complete()}})));return()=>{a.forEach((e=>e.unsubscribe()))}}))}userPut(e,t){return new y.c((r=>{this.gun.user().get(e).put(t,(e=>{e.err?r.error(new Error(e.err)):(r.next(t),r.complete())}))}))}userGet(e){return this.observe(this.gun.user().get(e))}observeUser(e){return this.observe(this.gun.user().get(e))}removeGunMeta(e){if(!e||"object"!=typeof e)return e;const t=Array.isArray(e)?[]:{};return Object.keys(e).forEach((r=>{if("_"===r||"#"===r)return;const i=e[r];t[r]=i&&"object"==typeof i?this.removeGunMeta(i):i})),t}}var v,I=r(4532),b=r(4586);r(4050),r(7514),r(7761),r(9770),r(1442);!function(e){e.WALLET_CREATED="walletCreated",e.WALLET_IMPORTED="walletImported",e.BALANCE_UPDATED="balanceUpdated",e.TRANSACTION_SENT="transactionSent",e.TRANSACTION_CONFIRMED="transactionConfirmed",e.ERROR="error"}(v||(v={}));h.EventEmitter;b.j;class A{constructor(e){this.lastEphemeralKeyPair=null,this.lastMethodUsed="unknown",this.STEALTH_HISTORY_KEY="stealthHistory",this.logs=[],this.STEALTH_DATA_TABLE="Stealth",this.storage=e||new l}log(e,t,r){const i={timestamp:(new Date).toISOString(),level:e,message:t,data:r};this.logs.push(i)}async cleanupSensitiveData(){try{this.lastEphemeralKeyPair=null,this.lastMethodUsed="unknown",this.logs=[],this.log("info","Sensitive data cleanup completed")}catch(e){throw this.log("error","Error during cleanup",e),e}}validateStealthData(e){try{if(!e||"object"!=typeof e)return this.log("error","Invalid stealth data: data is not an object"),!1;const t=["recipientPublicKey","ephemeralKeyPair","timestamp"];for(const r of t)if(!(r in e))return this.log("error",`Invalid stealth data: missing ${r}`),!1;if("string"!=typeof e.recipientPublicKey||!e.recipientPublicKey.trim())return this.log("error","Invalid recipientPublicKey"),!1;if("number"!=typeof e.timestamp||e.timestamp<=0)return this.log("error","Invalid timestamp"),!1;const r=["pub","priv","epub","epriv"];for(const t of r)if(!(t in e.ephemeralKeyPair)||"string"!=typeof e.ephemeralKeyPair[t])return this.log("error",`Invalid ephemeralKeyPair: missing or invalid ${t}`),!1;return e.method&&!["standard","legacy"].includes(e.method)?(this.log("error","Invalid method value"),!1):e.sharedSecret&&"string"!=typeof e.sharedSecret?(this.log("error","Invalid sharedSecret type"),!1):(this.log("debug","Stealth data validation passed"),!0)}catch(e){return this.log("error","Error during stealth data validation",e),!1}}formatPublicKey(e){if(!e)return null;const t=e.trim();return t&&/^[~]?[\w+/=\-_.]+$/.test(t)?t.startsWith("~")?t.slice(1):t:null}async createAccount(){try{const e=await Gun.SEA.pair();if(!(e&&e.pub&&e.priv&&e.epub&&e.epriv))throw new Error("Failed to generate stealth key pair");return{pub:e.pub,priv:e.priv,epub:e.epub,epriv:e.epriv}}catch(e){throw e}}async generateEphemeralKeyPair(){try{const e=await Gun.SEA.pair();if(!e||!e.epriv||!e.epub)throw new Error("Failed to generate ephemeral key pair");return{privateKey:e.epriv,publicKey:e.epub}}catch(e){throw this.log("error","Error generating ephemeral key pair",e),e}}async generateStealthAddress(e,t){if(!e){const e=new Error("Invalid keys: missing or invalid parameters");throw o.zc.handle(o.By.STEALTH,"INVALID_KEYS","Invalid or missing recipient public key",e),e}return new Promise(((r,i)=>{let s;const n=()=>{this.lastEphemeralKeyPair=s;const t={recipientPublicKey:e,ephemeralKeyPair:s,timestamp:Date.now()},n={epub:s.epub,epriv:s.epriv};Gun.SEA.secret(e,n,(async n=>{try{const i=p.S(f.YW(n)),a=new I.u(i);this.lastMethodUsed="standard",t.method="standard",t.sharedSecret=n,this.saveStealthHistory(a.address,t),r({stealthAddress:a.address,ephemeralPublicKey:s.epub,recipientPublicKey:e})}catch(e){const t=new Error(`Error creating stealth address: ${e instanceof Error?e.message:"unknown error"}`);o.zc.handle(o.By.STEALTH,"ADDRESS_GENERATION_FAILED",`Error creating stealth address: ${e instanceof Error?e.message:"unknown error"}`,e),i(t)}}))};t?this.generateEphemeralKeyPair().then((e=>{try{s={epriv:t,epub:e.publicKey,priv:t,pub:e.publicKey},n()}catch(e){return o.zc.handle(o.By.STEALTH,"EPHEMERAL_KEY_GENERATION_FAILED","Failed to use provided ephemeral key",e),void i(e)}})):this.generateEphemeralKeyPair().then((e=>{try{const t={epriv:e.privateKey,epub:e.publicKey,priv:e.privateKey,pub:e.publicKey};s=t,n()}catch(e){return o.zc.handle(o.By.STEALTH,"EPHEMERAL_KEY_GENERATION_FAILED","Failed to generate valid ephemeral keys",e),void i(e)}}))}))}async openStealthAddress(e,t,r){try{const t=this.storage.getItem(this.STEALTH_HISTORY_KEY)||"{}",r=JSON.parse(t)[e];if(r){if(r.sharedSecret){const e=p.S(f.YW(r.sharedSecret));return new I.u(e)}if(r.method&&r.ephemeralKeyPair){if("standard"===r.method){const t={epub:r.ephemeralKeyPair.epub,epriv:r.ephemeralKeyPair.epriv};return new Promise(((i,s)=>{Gun.SEA.secret(r.recipientPublicKey,t,(async t=>{if(t)try{const r=p.S(f.YW(t)),s=new I.u(r);if(s.address.toLowerCase()===e.toLowerCase())return i(s);throw new Error("Address does not match")}catch(e){throw new Error("Derivation error")}else s(new Error("Unable to regenerate shared secret"))}))}))}throw new Error("Method not supported")}throw new Error("Insufficient data")}throw new Error("No data found")}catch(i){return this.openStealthAddressStandard(e,t,r)}}async openStealthAddressStandard(e,t,r){if(!e||!t)throw new Error("Missing parameters: stealthAddress or ephemeralPublicKey");return new Promise(((i,s)=>{const n=[()=>new Promise((i=>{Gun.SEA.secret(t,r,(async t=>{try{if(!t)return i(null);const r=this.deriveWalletFromSecret(t);return r.address.toLowerCase()===e.toLowerCase()?i(r):i(null)}catch(e){return i(null)}}))}))];this.deriveWalletFromSecret=e=>{const t=p.S(f.YW(e));return new I.u(t)};const a=async(e=0)=>{if(e>=n.length)return s(new Error("All stealth address derivation methods failed"));const t=await n[e]();if(t)return i(t);a(e+1)};a()}))}async getPublicKey(e){return this.formatPublicKey(e)}prepareStealthKeysForSaving(e){if(!(e?.pub&&e?.priv&&e?.epub&&e?.epriv))throw new Error("Invalid stealth keys: missing or incomplete parameters");return e}deriveWalletFromSecret(e){const t=p.S(f.YW(e));return new I.u(t)}saveStealthHistory(e,t){try{if(!this.validateStealthData(t))throw new Error("Invalid stealth data");const r=this.storage.getItem(this.STEALTH_HISTORY_KEY)||"{}",i=JSON.parse(r);i[e]=t,this.storage.setItem(this.STEALTH_HISTORY_KEY,JSON.stringify(i)),this.log("info",`Stealth data saved for address ${e}`)}catch(e){throw this.log("error","Error saving stealth data:",e),e}}async scanStealthAddresses(e,t){try{const r=[];for(const i of e)try{await this.isStealthAddressMine(i,t)&&r.push(i)}catch(e){this.log("error",`Error checking stealth address: ${e instanceof Error?e.message:"unknown error"}`)}return r}catch(e){throw this.log("error","Error scanning stealth addresses",e),e}}async isStealthAddressMine(e,t){try{if(!e||!t)throw new Error("Invalid parameters for stealth address check");if(!this.validateStealthData(e))throw new Error("Invalid stealth data format");const r=await this.getStealthPrivateKey(e,t);if(!r)return!1;try{new I.u(r);return!0}catch(e){return!1}}catch(e){throw this.log("error","Error checking stealth address ownership",e),e}}async getStealthPrivateKey(e,t){try{if(!e||!t)throw new Error("Invalid parameters for private key derivation");if(!this.validateStealthData(e))throw new Error("Invalid stealth data format");return e.sharedSecret?p.S(f.YW(e.sharedSecret)):new Promise(((r,i)=>{const s={priv:t,epub:e.ephemeralKeyPair.epub};Gun.SEA.secret(e.ephemeralKeyPair.epub,s,(e=>{if(e)try{const t=p.S(f.YW(e));r(t)}catch(e){i(new Error(`Error deriving private key: ${e instanceof Error?e.message:"unknown error"}`))}else i(new Error("Failed to generate shared secret"))}))}))}catch(e){throw this.log("error","Error getting stealth private key",e),e}}}"undefined"!=typeof window?window.Stealth=A:void 0!==r.g&&(r.g.Stealth=A);b.j;r(2499),r(8991),r(228);class S{constructor(e){if(this.plugins=new Map,(0,a.Rm)("Initializing ShogunSDK"),this.config=e,e.logging&&((0,a.yM)(e.logging),(0,a.Rm)("Logging configured with custom settings")),this.storage=new l,this.eventEmitter=new h.EventEmitter,o.zc.addListener((e=>{this.eventEmitter.emit("error",{action:e.code,message:e.message,type:e.type})})),e.gundb||(e.gundb={},(0,a.Rm)("No GunDB configuration provided, using defaults")),e.gundb.authToken){const t=e.gundb.authToken;(0,a.Rm)(`Auth token from config: ${t}`)}else(0,a.Rm)("No auth token in config");const t={peers:e.gundb?.peers,websocket:e.gundb?.websocket??!1,localStorage:e.gundb?.localStorage??!1,radisk:e.gundb?.radisk??!1,authToken:e.gundb?.authToken,multicast:e.gundb?.multicast??!1,axe:e.gundb?.axe??!1};if(this.gundb=new u(t),this.gun=this.gundb.getGun(),this.user=this.gun.user().recall({sessionStorage:!0}),this.rx=new D(this.gun),e.providerUrl?(this.provider=new g.FR(e.providerUrl),(0,a.Rm)(`Using configured provider URL: ${e.providerUrl}`)):(this.provider=m.x("mainnet"),(0,a.Rm)("WARNING: Using default Ethereum provider. For production use, configure a specific provider URL.")),this.registerBuiltinPlugins(e),e.plugins?.autoRegister&&e.plugins.autoRegister.length>0)for(const t of e.plugins.autoRegister)try{this.register(t),(0,a.Rm)(`Auto-registered plugin: ${t.name}`)}catch(e){(0,a.vV)(`Failed to auto-register plugin ${t.name}:`,e)}(0,a.Rm)("ShogunSDK initialized!")}registerBuiltinPlugins(e){try{const{WebauthnPlugin:t}=r(409),{MetaMaskPlugin:i}=r(8991),{StealthPlugin:s}=r(2256),{DIDPlugin:n}=r(2499);if(e.webauthn?.enabled){const e=new t;e._category=c.Authentication,this.register(e),this.webauthn=this.getPlugin(d.WebAuthn),(0,a.Rm)("Webauthn plugin registered")}if(e.metamask?.enabled){const e=new i;e._category=c.Authentication,this.register(e),this.metamask=this.getPlugin(d.MetaMask),(0,a.Rm)("MetaMask plugin registered")}if(e.stealth?.enabled){const e=new s;e._category=c.Privacy,this.register(e),this.stealth=this.getPlugin(d.Stealth),(0,a.Rm)("Stealth plugin registered")}if(e.did?.enabled){const e=new n;e._category=c.Identity,this.register(e),this.did=this.getPlugin(d.DID),(0,a.Rm)("DID plugin registered")}}catch(e){(0,a.vV)("Error registering builtin plugins:",e)}}register(e){if(this.plugins.has(e.name))throw new Error(`Plugin with name "${e.name}" already registered`);e.initialize(this),this.plugins.set(e.name,e),(0,a.Rm)(`Registered plugin: ${e.name}`)}unregister(e){const t=this.plugins.get(e);t?(t.destroy&&t.destroy(),this.plugins.delete(e),(0,a.Rm)(`Unregistered plugin: ${e}`)):(0,a.Rm)(`Plugin "${e}" not found, nothing to unregister`)}getPlugin(e){return this.plugins.get(e)}hasPlugin(e){return this.plugins.has(e)}getPluginsByCategory(e){const t=[];return this.plugins.forEach((r=>{r._category===e&&t.push(r)})),t}observe(e){return this.rx.observe(e)}match(e,t){return this.rx.match(e,t)}rxPut(e,t){return this.rx.put(e,t)}rxSet(e,t){return this.rx.set(e,t)}once(e){return this.rx.once(e)}compute(e,t){return this.rx.compute(e,t)}rxUserPut(e,t){return this.rx.userPut(e,t)}observeUser(e){return this.rx.observeUser(e)}getRecentErrors(e=10){return o.zc.getRecentErrors(e)}configureLogging(e){(0,a.yM)(e),(0,a.Rm)("Logging reconfigured with new settings")}isLoggedIn(){const e=this.gundb.isLoggedIn(),t=this.gun.user();if(e)return!0;const r=t&&t._&&t._.sea,i=this.storage.getItem("pair");return!!r||!!i}logout(){try{if(!this.isLoggedIn())return void(0,a.Rm)("Logout ignored: user not authenticated");this.gundb.logout(),this.eventEmitter.emit("auth:logout",{}),(0,a.Rm)("Logout completed successfully")}catch(e){o.zc.handle(o.By.AUTHENTICATION,"LOGOUT_FAILED",e instanceof Error?e.message:"Error during logout",e)}}async login(e,t){(0,a.Rm)("Login");try{if((0,a.Rm)(`Login attempt for user: ${e}`),!e||!t)return{success:!1,error:"Username and password are required"};const r=new Promise((r=>{this.gundb.gun.user().auth(e,t,(t=>{if(t.err)(0,a.Rm)(`Login error: ${t.err}`),r({success:!1,error:t.err});else{const t=this.gundb.gun.user();if(t.is){(0,a.Rm)("Login completed successfully");const i=t.is?.pub||"";r({success:!0,userPub:i,username:e})}else r({success:!1,error:"Login failed: user not authenticated"})}}))})),i=this.config?.timeouts?.login||15e3,s=new Promise((e=>{setTimeout((()=>{e({success:!1,error:"Login timeout"})}),i)})),n=await Promise.race([r,s]);if(n.success){this.eventEmitter.emit("auth:login",{userPub:n.userPub||""});try{const e=await this.ensureUserHasDID();e&&(n.did=e)}catch(e){(0,a.vV)("Error ensuring DID after login:",e)}}return n}catch(e){return o.zc.handle(o.By.AUTHENTICATION,"LOGIN_FAILED",e.message||"Unknown error during login",e),{success:!1,error:e.message||"Unknown error during login"}}}async signUp(e,t,r){(0,a.Rm)("Sign up");try{if(!e||!t)return{success:!1,error:"Username and password are required"};if(void 0!==r&&t!==r)return{success:!1,error:"Passwords do not match"};if(t.length<6)return{success:!1,error:"Password must be at least 6 characters long"};const i=new Promise((r=>{this.gundb.gun.user().create(e,t,(i=>{i.err?r({success:!1,error:i.err}):this.gundb.gun.user().auth(e,t,(t=>{if(t.err)r({success:!1,error:"Registration completed but login failed"});else{const t=this.gundb.gun.user();t.is?r({success:!0,userPub:t.is?.pub||"",username:e||""}):r({success:!1,error:"Registration completed but user not authenticated"})}}))}))})),s=this.config?.timeouts?.signup||2e4,n=new Promise((e=>{setTimeout((()=>{e({success:!1,error:"Registration timeout"})}),s)})),o=await Promise.race([i,n]);if(o.success){this.eventEmitter.emit("auth:signup",{userPub:o.userPub||"",username:e});try{const e=await this.ensureUserHasDID();e&&((0,a.Rm)(`Created DID for new user: ${e}`),o.did=e)}catch(e){(0,a.vV)("Error creating DID for new user:",e)}}return o}catch(t){return(0,a.vV)(`Error during registration for user ${e}:`,t),{success:!1,error:t.message||"Unknown error during registration"}}}isWebAuthnSupported(){const e=this.getPlugin("webauthn");return e?e.isSupported():this.webauthn?.isSupported()||!1}async loginWithWebAuthn(e){(0,a.Rm)("Login with WebAuthn");try{if((0,a.Rm)(`Attempting WebAuthn login for user: ${e}`),!e)throw new Error("Username required for WebAuthn login");if(!this.isWebAuthnSupported())throw new Error("WebAuthn is not supported by this browser");const t=this.getPlugin("webauthn")||this.webauthn,r=await(t?.generateCredentials(e,null,!0));if(!r?.success)throw new Error(r?.error||"WebAuthn verification failed");const i=p.S(f.YW(r.credentialId||"")),s=await this.login(e,i);if(s.success){if((0,a.Rm)(`WebAuthn login completed successfully for user: ${e}`),!s.did)try{const e=await this.ensureUserHasDID();e&&(s.did=e)}catch(e){(0,a.vV)("Error ensuring DID for WebAuthn user:",e)}return{...s,username:e,password:i,credentialId:r.credentialId}}return s}catch(e){return(0,a.vV)(`Error during WebAuthn login: ${e}`),{success:!1,error:e.message||"Error during WebAuthn login"}}}async signUpWithWebAuthn(e){(0,a.Rm)("Sign up with WebAuthn");try{if((0,a.Rm)(`Attempting WebAuthn registration for user: ${e}`),!e)throw new Error("Username required for WebAuthn registration");if(!this.isWebAuthnSupported())throw new Error("WebAuthn is not supported by this browser");const t=this.getPlugin("webauthn")||this.webauthn,r=await(t?.generateCredentials(e,null,!1));if(!r?.success)throw new Error(r?.error||"Unable to generate WebAuthn credentials");const i=p.S(f.YW(r.credentialId||"")),s=await this.signUp(e,i);if(s.success){if((0,a.Rm)(`WebAuthn registration completed successfully for user: ${e}`),!s.did)try{const t=await this.ensureUserHasDID({services:[{type:"WebAuthnVerification",endpoint:`webauthn:${e}`}]});t&&(s.did=t)}catch(e){(0,a.vV)("Error creating DID for WebAuthn user:",e)}return{...s,username:e,password:i,credentialId:r.credentialId}}return s}catch(e){return(0,a.vV)(`Error during WebAuthn registration: ${e}`),{success:!1,error:e.message||"Error during WebAuthn registration"}}}async loginWithMetaMask(e){(0,a.Rm)("Login with MetaMask");try{if((0,a.Rm)(`MetaMask login attempt for address: ${e}`),!e)throw(0,o.$5)(o.By.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask login");const t=this.getPlugin("metamask")||this.metamask;if(!t?.isAvailable())throw(0,o.$5)(o.By.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,a.Rm)("Generating credentials for MetaMask login...");const r=await t.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.$5)(o.By.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,a.Rm)(`Credentials generated successfully. Username: ${r.username}`),(0,a.Rm)("Verifying MetaMask signature...");const i=w.l(r.message,r.signature);if(i.toLowerCase()!==e.toLowerCase())throw(0,a.vV)(`Signature verification failed. Expected: ${e}, Got: ${i}`),(0,o.$5)(o.By.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,a.Rm)("MetaMask signature verified successfully."),(0,a.Rm)("Attempting login or user creation with verified credentials...");const s=await this.createUserWithGunDB(r.username,r.password);if(!s.success||!s.userPub)throw(0,o.$5)(o.By.AUTHENTICATION,"LOGIN_CREATE_FAILED",s.error||"Login or user creation failed after signature verification");(0,a.Rm)(`Login/Creation successful: ${s.userPub}`);let n=null;try{(0,a.Rm)("Ensuring user has a DID..."),n=await this.ensureUserHasDID({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),n?(0,a.Rm)(`DID assigned/verified: ${n}`):(0,a.JE)("Could not ensure DID for user after MetaMask login.")}catch(e){o.zc.handle(o.By.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user",e)}return this.eventEmitter.emit("auth:login",{userPub:s.userPub,username:r.username,method:"metamask",did:n||void 0}),{success:!0,userPub:s.userPub,username:r.username,password:r.password,did:n||void 0}}catch(e){const t=e?.type||o.By.AUTHENTICATION,r=e?.code||"METAMASK_LOGIN_ERROR",i=e?.message||"Unknown error during MetaMask login";return{success:!1,error:o.zc.handle(t,r,i,e).message}}}async signUpWithMetaMask(e){(0,a.Rm)("Sign up with MetaMask");try{if((0,a.Rm)(`MetaMask registration attempt for address: ${e}`),!e)throw(0,o.$5)(o.By.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask registration");const t=this.getPlugin("metamask")||this.metamask;if(!t?.isAvailable())throw(0,o.$5)(o.By.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");(0,a.Rm)("Generating credentials for MetaMask registration...");const r=await t.generateCredentials(e);if(!(r?.username&&r?.password&&r.signature&&r.message))throw(0,o.$5)(o.By.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");(0,a.Rm)(`Credentials generated successfully. Username: ${r.username}`),(0,a.Rm)("Verifying MetaMask signature...");const i=w.l(r.message,r.signature);if(i.toLowerCase()!==e.toLowerCase())throw(0,a.vV)(`Signature verification failed. Expected: ${e}, Got: ${i}`),(0,o.$5)(o.By.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");(0,a.Rm)("MetaMask signature verified successfully."),(0,a.Rm)("Attempting user creation (or login if exists) with verified credentials...");const s=await this.createUserWithGunDB(r.username,r.password);if(!s.success||!s.userPub)throw(0,o.$5)(o.By.AUTHENTICATION,"USER_CREATE_LOGIN_FAILED",s.error||"User creation or login failed after signature verification");(0,a.Rm)(`User creation/login successful: ${s.userPub}`);let n=null;try{(0,a.Rm)("Creating/Ensuring DID with MetaMask verification service..."),n=await this.ensureUserHasDID({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),n?(0,a.Rm)(`DID created/verified: ${n}`):(0,a.JE)("Could not ensure DID for user after MetaMask signup.")}catch(e){o.zc.handle(o.By.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user during signup",e)}return this.eventEmitter.emit("auth:signup",{userPub:s.userPub,username:r.username,method:"metamask",did:n||void 0}),{success:!0,userPub:s.userPub,username:r.username,password:r.password,did:n||void 0}}catch(e){const t=e?.type||o.By.AUTHENTICATION,r=e?.code||"METAMASK_SIGNUP_ERROR",i=e?.message||"Unknown error during MetaMask registration";return{success:!1,error:o.zc.handle(t,r,i,e).message}}}async ensureUserHasDID(e){try{const t=this.getPlugin("did");if(t&&t.ensureUserHasDID)return t.ensureUserHasDID(e);if(!this.isLoggedIn())return(0,a.vV)("Cannot ensure DID: user not authenticated"),null;let r=await(this.did?.getCurrentUserDID());if(r){if((0,a.Rm)(`User already has DID: ${r}`),e&&Object.keys(e).length>0)try{await(this.did?.updateDIDDocument(r,{service:e.services?.map(((e,t)=>({id:`${r}#service-${t+1}`,type:e.type,serviceEndpoint:e.endpoint})))}))&&(0,a.Rm)(`Updated DID document for: ${r}`)}catch(e){(0,a.vV)("Error updating DID document:",e)}return r}(0,a.Rm)("Creating new DID for authenticated user");const i=this.gundb.gun.user().is?.pub||"",s={network:"main",controller:i,...e};return r=await(this.did?.createDID(s)),this.eventEmitter.emit("did:created",{did:r,userPub:i}),(0,a.Rm)(`Created new DID for user: ${r}`),r||null}catch(e){return(0,a.vV)("Error ensuring user has DID:",e),null}}createUserWithGunDB(e,t){return(0,a.Rm)(`Ensuring user exists with GunDB: ${e}`),new Promise((async r=>{try{const i=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().auth(e,t,(e=>{if(e.err)r({err:e.err});else{const e=this.gundb.gun.user(),t=e.is?.pub||"";e.is&&t?r({pub:t}):r({err:"Authentication failed after apparent success."})}}))})),s=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().create(e,t,(e=>{r({err:e.err,pub:e.pub})}))}));(0,a.Rm)(`Attempting login first for ${e}...`);let n=await i();if(n.pub)return(0,a.Rm)(`Login successful for existing user. Pub: ${n.pub}`),void r({success:!0,userPub:n.pub});(0,a.Rm)(`Login failed (${n.err||"unknown reason"}), attempting user creation...`);const o=await s();if(o.err)return(0,a.Rm)(`User creation error: ${o.err}`),void r({success:!1,error:`User creation failed: ${o.err}`});(0,a.Rm)("User created successfully, attempting login again for confirmation..."),n=await i(),n.pub?((0,a.Rm)(`Post-creation login successful! User pub: ${n.pub}`),r({success:!0,userPub:n.pub})):((0,a.vV)(`Post-creation login failed unexpectedly: ${n.err}`),r({success:!1,error:`User created, but subsequent login failed: ${n.err}`}))}catch(e){const t=e.message||"Unknown error during user existence check";(0,a.vV)(`Error in createUserWithGunDB: ${t}`,e),r({success:!1,error:t})}}))}get(e){return new Promise(((t,r)=>{this.gundb.gun.get(e).once((e=>{e.err?r(e.err):t(e)}))}))}put(e){return new Promise(((t,r)=>{this.gundb.gun.put(e,(e=>{e.err?r(e.err):t(e)}))}))}userPut(e){return new Promise(((t,r)=>{this.gundb.gun.user().put(e,(e=>{e.err?r(e.err):t(e)}))}))}userGet(e){return new Promise(((t,r)=>{this.gundb.gun.user().get(e).once((e=>{e.err?r(e.err):t(e)}))}))}setRpcUrl(e){try{return e?(this.provider=new g.FR(e),(0,a.Rm)(`RPC URL updated to: ${e}`),!0):((0,a.Rm)("Invalid RPC URL provided"),!1)}catch(e){return(0,a.vV)("Failed to set RPC URL",e),!1}}getRpcUrl(){return this.provider instanceof g.FR&&this.provider.connection?.url||null}getMainWallet(){const e=this.getPlugin(d.WalletManager);return e&&"function"==typeof e.getMainWallet?e.getMainWallet():null}emit(e,...t){return this.eventEmitter.emit(e,...t)}}let R;const M={loadWebAuthn:()=>Promise.resolve().then(r.bind(r,409)),loadStealth:()=>Promise.resolve().then(r.bind(r,2256)),loadDID:()=>r.e(662).then(r.bind(r,4662))};"undefined"!=typeof window&&(window.ShogunCore=R,window.initShogunBrowser=function(e){const t={...e};return t.gundb||(t.gundb={}),e.gundb?.peers||(0,a.Rm)("WARNING: Using default GunDB peers. For production, always configure custom peers."),e.providerUrl||(0,a.Rm)("WARNING: No Ethereum provider URL specified. Using default public endpoint with rate limits."),R=new S(t),R},window.ShogunModules=M)},2256:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Stealth:()=>i,default:()=>s});class i{constructor(){}formatPublicKey(){throw new Error("Stealth functionality disabled in light version")}async createAccount(){throw new Error("Stealth functionality disabled in light version")}async generateStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async openStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async getPublicKey(){throw new Error("Stealth functionality disabled in light version")}prepareStealthKeysForSaving(){throw new Error("Stealth functionality disabled in light version")}deriveWalletFromSecret(){throw new Error("Stealth functionality disabled in light version")}}const s=i},2499:(e,t,r)=>{"use strict";r.r(t),r.d(t,{DIDPlugin:()=>h});var i=r(4586),s=r(2011),n=r(7303),a=r(2724),o=r(5628),u=r(3358),c=r(7007);class d extends c.EventEmitter{constructor(e,t){super(),this.methodName="shogun",this.didCache=new Map,this.DEFAULT_CACHE_DURATION=18e5,this.DEFAULT_TIMEOUT=1e4,this.DEFAULT_MAX_RETRIES=3,this.DEFAULT_RETRY_DELAY=1e3,this.registryConfig={address:"0x1234...",network:"mainnet",timeout:this.DEFAULT_TIMEOUT,maxRetries:this.DEFAULT_MAX_RETRIES,retryDelay:this.DEFAULT_RETRY_DELAY},this.core=e,this.registryConfig={...this.registryConfig,...t},(0,o.Rm)("ShogunDID initialized")}async createDID(e={}){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to create a DID");const t=this.getUserPublicKey();if(!t)throw new Error("Cannot retrieve user's public key");let r=s.S(n.YW(t)).slice(2,42);e.network&&(r=`${e.network}:${r}`);const i=`did:${this.methodName}:${r}`;return await this.storeDID(i,e),this.emit("didCreated",{did:i}),(0,o.Rm)(`Created DID: ${i}`),i}catch(e){throw(0,o.vV)("Error creating DID:",e),u.zc.handle(u.By.DID,"CREATE_DID_ERROR",e instanceof Error?e.message:"Error creating DID",e),e}}async storeDID(e,t){try{if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=t.document||this.createDidDocument(e,t);return new Promise(((t,i)=>{this.core.gun.get("dids").get(e).put({document:JSON.stringify(r),created:(new Date).toISOString(),updated:(new Date).toISOString(),deactivated:!1},(r=>{r.err?i(new Error(`Failed to store DID: ${r.err}`)):this.core.gun.user().get("did").put(e,(e=>{e.err&&(0,o.vV)(`Warning: DID created but not associated with user: ${e.err}`),t()}))})),setTimeout((()=>i(new Error("Timeout storing DID"))),1e4)}))}catch(e){throw(0,o.vV)("Error storing DID:",e),e}}createDidDocument(e,t){(new Date).toISOString();const r=t.controller||this.getUserPublicKey()||e,i={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:r,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${this.getUserPublicKey()||s.S(n.YW(e))}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(i.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),i}getUserPublicKey(){try{if(!this.core.isLoggedIn())return null;const e=this.core.gun.user();return e&&e._&&e._.sea&&e._.sea.pub||null}catch(e){return(0,o.vV)("Error getting user public key:",e),null}}async resolveDID(e,t={}){try{const r=t.cacheDuration||this.DEFAULT_CACHE_DURATION,i=t.timeout||this.DEFAULT_TIMEOUT,s=this.didCache.get(e);if(s&&Date.now()-s.timestamp<r)return{didResolutionMetadata:{contentType:"application/did+json"},didDocument:this.getDocumentFromCache(s),didDocumentMetadata:{}};if(!this.isValidDID(e))return this.createErrorResolution("invalidDid","Invalid DID format");const[n,a,o]=e.split(":");return a!==this.methodName?this.createErrorResolution("unsupportedDidMethod",`Unsupported DID method: ${a}`):new Promise(((t,r)=>{const s=setTimeout((()=>{t(this.createErrorResolution("timeout","DID resolution timeout"))}),i);this.core.gun.get("dids").get(e).once((r=>{if(clearTimeout(s),r)try{const i=this.parseOrCreateDIDDocument(e,r);this.didCache.set(e,{data:i,document:i,timestamp:Date.now(),network:o.split(":")[0]||"main"}),t({didResolutionMetadata:{contentType:"application/did+json"},didDocument:i,didDocumentMetadata:{created:r.created,updated:r.updated,deactivated:r.deactivated||!1}})}catch(e){t(this.createErrorResolution("invalidDidDocument","Error parsing DID Document"))}else t(this.createErrorResolution("notFound","DID Document not found"))}))}))}catch(e){return(0,o.vV)("Error resolving DID:",e),this.createErrorResolution("internalError",e instanceof Error?e.message:"Unknown error")}}async registerDIDOnChain(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to register DID on chain");let r=t||this.core.getMainWallet();if(!r)throw new Error("No signer provided and main wallet not available");const i=["function registerDID(string did, string controller) public returns (bool)"],s=new a.NZ(this.registryConfig.address,i,r);for(let t=1;t<=this.registryConfig.maxRetries;t++)try{const t=await s.registerDID(e,this.getUserPublicKey()),r=await t.wait();return this.emit("didRegistered",{did:e,txHash:r.hash}),(0,o.Rm)(`DID registered on blockchain: ${e}, tx: ${r.hash}`),{success:!0,txHash:r.hash}}catch(e){if(t===this.registryConfig.maxRetries)throw e;await new Promise((e=>setTimeout(e,this.registryConfig.retryDelay)))}throw new Error("Failed to register DID after retries")}catch(e){return(0,o.vV)("Error registering DID on blockchain:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getCurrentUserDID(){try{if(!this.core.isLoggedIn())return null;return this.getUserPublicKey()?new Promise((e=>{this.core.gun.user().get("did").once((t=>{e(t&&"string"==typeof t?t:null)})),setTimeout((()=>e(null)),5e3)})):null}catch(e){return(0,o.vV)("Error getting current user DID:",e),null}}async authenticateWithDID(e,t){try{if((0,o.Rm)(`Authenticating with DID: ${e}`),!this.isValidDID(e))return{success:!1,error:"Invalid DID format"};const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)return{success:!1,error:`DID resolution failed: ${r.didResolutionMetadata.error}`};const i=this.extractAuthenticationMethod(r.didDocument);return i?i.type.includes("EcdsaSecp256k1")?this.authenticateWithEthereum(i,t):i.type.includes("WebAuthn")?this.authenticateWithWebAuthn(i,t):this.authenticateWithGunDB(i,t):{success:!1,error:"No valid authentication method found in DID Document"}}catch(e){return(0,o.vV)("Error authenticating with DID:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error during authentication"}}}async updateDIDDocument(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to update a DID document");if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)throw new Error(`Cannot update DID document: ${r.didResolutionMetadata.error||"Document not found"}`);const i=r.didDocument,s={...i,...t};if(t.service&&i.service){const e=[...i.service];for(const r of t.service){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}s.service=e}if(t.verificationMethod&&i.verificationMethod){const e=[...i.verificationMethod];for(const r of t.verificationMethod){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}s.verificationMethod=e}await this.storeDID(e,{document:s});const[n,a,u]=e.split(":");return this.didCache.set(e,{data:s,document:s,timestamp:Date.now(),network:u.split(":")[0]||"main"}),this.emit("didUpdated",{did:e,document:s}),(0,o.Rm)(`Updated DID Document: ${e}`),!0}catch(e){return(0,o.vV)("Error updating DID document:",e),u.zc.handle(u.By.DID,"UPDATE_DID_ERROR",e instanceof Error?e.message:"Error updating DID",e),!1}}async deactivateDID(e){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to deactivate a DID");const t=await this.getCurrentUserDID();if(e!==t)throw new Error("Cannot deactivate a DID you don't control");return new Promise((t=>{this.core.gun.get("dids").get(e).put({deactivated:!0,updated:(new Date).toISOString()},(r=>{r.err?((0,o.vV)(`Error deactivating DID: ${r.err}`),t(!1)):((0,o.Rm)(`Successfully deactivated DID: ${e}`),t(!0))})),setTimeout((()=>t(!1)),1e4)}))}catch(e){return(0,o.vV)("Error deactivating DID:",e),!1}}isValidDID(e){return/^did:[a-z0-9]+:[a-zA-Z0-9.:%]+$/.test(e)}generateDIDDocument(e,t={}){const r=this.getUserPublicKey(),i={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:t.controller||e,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${r}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(i.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),i}createErrorResolution(e,t){return{didResolutionMetadata:{error:e,contentType:"application/did+json"},didDocument:null,didDocumentMetadata:{}}}parseOrCreateDIDDocument(e,t){if(t.document)try{return JSON.parse(t.document)}catch(e){(0,o.vV)("Error parsing stored DID Document, creating a basic one",e)}return{"@context":"https://www.w3.org/ns/did/v1",id:e,authentication:[]}}extractAuthenticationMethod(e){const t=e.authentication||[];for(const r of t){if("string"!=typeof r)return r;{const t=r,i=e.verificationMethod?.find((e=>e.id===t));if(i)return{id:i.id,type:i.type,controller:i.controller}}}return null}async authenticateWithEthereum(e,t){const r=e.id.split("#")[0].split(":").pop()||"";return this.core.loginWithMetaMask(r)}async authenticateWithWebAuthn(e,t){const r=e.controller.split(":").pop()||"";return this.core.loginWithWebAuthn(r)}async authenticateWithGunDB(e,t){try{const r=e.controller.split(":").pop()||"",i=await this.resolveDID(e.id.split("#")[0]);if(i.didResolutionMetadata.error||!i.didDocument)return{success:!1,error:"Impossibile recuperare il documento DID per l'autenticazione"};const a=i.didDocument.service?.find((e=>"GunDBAuthentication"===e.type));if(!a)return{success:!1,error:"Nessun servizio di autenticazione GunDB trovato nel documento DID"};const o=a.serviceEndpoint,u="string"==typeof o?{username:r}:{...o,username:r};if(!u.hasOwnProperty("password")){const i=s.S(n.YW(`${e.id}:${t||""}`));return this.core.login(r,i)}return this.core.login(r,u.password)}catch(e){return(0,o.vV)("Errore durante l'autenticazione con GunDB:",e),{success:!1,error:e instanceof Error?e.message:"Errore sconosciuto durante l'autenticazione GunDB"}}}async verifyDIDOnChain(e){try{const t=["function isDIDRegistered(string did) public view returns (bool)","function getDIDController(string did) public view returns (string)"],r="0x1234...",i=this.core.getMainWallet()?.provider;if(!i)throw new Error("Provider non disponibile per verificare il DID on-chain");const s=new a.NZ(r,t,i);if(!await s.isDIDRegistered(e))return{isRegistered:!1};return{isRegistered:!0,controller:await s.getDIDController(e)}}catch(e){return(0,o.vV)("Error verifying DID on blockchain:",e),{isRegistered:!1,error:e instanceof Error?e.message:"Unknown error"}}}clearCache(){this.didCache.clear(),this.emit("cacheCleared")}removeFromCache(e){this.didCache.delete(e),this.emit("didRemovedFromCache",{did:e})}getDocumentFromCache(e){return e.data?e.data:e.document?e.document:null}}class h extends i.j{constructor(){super(...arguments),this.name="did",this.version="1.0.0",this.description="Provides Decentralized Identifiers (DID) functionality for ShogunCore",this.did=null}initialize(e){super.initialize(e),this.did=new d(e),(0,o.Rm)("DID plugin initialized")}destroy(){this.did=null,super.destroy(),(0,o.Rm)("DID plugin destroyed")}assertDID(){if(this.assertInitialized(),!this.did)throw new Error("DID module not initialized");return this.did}async getCurrentUserDID(){return this.assertDID().getCurrentUserDID()}async resolveDID(e){return this.assertDID().resolveDID(e)}async authenticateWithDID(e,t){return this.assertDID().authenticateWithDID(e,t)}async createDID(e){return this.assertDID().createDID(e)}async updateDIDDocument(e,t){return this.assertDID().updateDIDDocument(e,t)}async deactivateDID(e){return this.assertDID().deactivateDID(e)}async registerDIDOnChain(e,t){return this.assertDID().registerDIDOnChain(e,t)}async ensureUserHasDID(e){try{const t=this.core;if(!t)throw new Error("Core not available");if(!t.isLoggedIn())return(0,o.vV)("Cannot ensure DID: user not authenticated"),null;let r=await this.getCurrentUserDID();if(r){if((0,o.Rm)(`User already has DID: ${r}`),e&&Object.keys(e).length>0)try{await this.updateDIDDocument(r,{service:e.services?.map(((e,t)=>({id:`${r}#service-${t+1}`,type:e.type,serviceEndpoint:e.endpoint})))})&&(0,o.Rm)(`Updated DID document for: ${r}`)}catch(e){(0,o.vV)("Error updating DID document:",e)}return r}(0,o.Rm)("Creating new DID for authenticated user");const i=t.gundb.gun.user().is?.pub||"",s={network:"main",controller:i,...e};return r=await this.createDID(s),t.emit("did:created",{did:r,userPub:i}),(0,o.Rm)(`Created new DID for user: ${r}`),r||null}catch(e){return u.zc.handle(u.By.DID,"ENSURE_DID_FAILED",`Error ensuring user has DID: ${e instanceof Error?e.message:String(e)}`,e),null}}}},3358:(e,t,r)=>{"use strict";r.d(t,{$5:()=>n,By:()=>i,zc:()=>a});var i,s=r(5628);function n(e,t,r,i){return{type:e,code:t,message:r,originalError:i,timestamp:Date.now()}}!function(e){e.AUTHENTICATION="AuthenticationError",e.AUTHORIZATION="AuthorizationError",e.VALIDATION="ValidationError",e.NETWORK="NetworkError",e.DATABASE="DatabaseError",e.WALLET="WalletError",e.DID="DIDError",e.STORAGE="StorageError",e.ENCRYPTION="EncryptionError",e.SIGNATURE="SignatureError",e.ENVIRONMENT="EnvironmentError",e.SECURITY="SecurityError",e.GUN="GunError",e.STEALTH="StealthError",e.WEBAUTHN="WebAuthnError",e.UNKNOWN="UnknownError",e.CONNECTOR="CONNECTOR",e.GENERAL="GENERAL"}(i||(i={}));class a{static handleError(e){(0,s.vV)(`[${e.type}] ${e.code}: ${e.message}`),this.errors.push(e),this.errors.length>this.maxErrors&&(this.errors=this.errors.slice(-this.maxErrors)),this.notifyListeners(e)}static handle(e,t,r,i,a="error"){const o=i?`${r} - ${this.formatError(i)}`:r;switch(a){case"debug":(0,s.Rm)(`[${e}.${t}] (DEBUG) ${o}`);break;case"warn":(0,s.Rm)(`[${e}.${t}] (WARN) ${o}`);break;case"info":(0,s.Rm)(`[${e}.${t}] (INFO) ${o}`);break;default:(0,s.Rm)(`[${e}.${t}] (ERROR) ${o}`),i&&i instanceof Error&&(0,s.Rm)(i.stack||"No stack trace available")}const u=n(e,t,o,i);return this.handleError(u),u}static getRecentErrors(e=10){return this.errors.slice(-Math.min(e,this.errors.length))}static addListener(e){this.listeners.push(e)}static removeListener(e){const t=this.listeners.indexOf(e);-1!==t&&this.listeners.splice(t,1)}static notifyListeners(e){for(const t of this.listeners)try{t(e)}catch(e){(0,s.vV)(`Error in error listener: ${e}`)}}static formatError(e){if(!e)return"Unknown error";if(e instanceof Error)return`${e.name}: ${e.message}`;if("string"==typeof e)return e;if("object"==typeof e)try{return JSON.stringify(e)}catch(t){return`Object: ${Object.prototype.toString.call(e)}`}return String(e)}static async withRetry(e,t,r,i=3,n=1e3){let a;for(let t=1;t<=i;t++)try{return await e()}catch(e){a=e;const r=n*t;t<i&&((0,s.Rm)(`Retrying operation after ${r}ms (attempt ${t}/${i})`),await new Promise((e=>setTimeout(e,r))))}throw this.handle(t,r,`Operation failed after ${i} attempts`,a)}}a.errors=[],a.maxErrors=100,a.listeners=[]},4586:(e,t,r)=>{"use strict";r.d(t,{j:()=>i});class i{constructor(){this.core=null}initialize(e){this.core=e}destroy(){this.core=null}assertInitialized(){if(!this.core)throw new Error(`Plugin ${this.name} not initialized`)}}},5628:(e,t,r)=>{"use strict";r.d(t,{JE:()=>u,MD:()=>c,Rm:()=>a,vV:()=>o,yM:()=>n});let i={enabled:"true"===r(5606).env.DEBUG,level:"info",prefix:"[ShogunSDK]"},s=!1;function n(e){i={...i,...e}}function a(e,...t){(new Date).toISOString()}function o(e,...t){(new Date).toISOString()}function u(e,...t){(new Date).toISOString()}function c(e,...t){if(!s)return;(new Date).toISOString()}},5736:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5736,e.exports=t},7028:(e,t,r)=>{"use strict";r.d(t,{A:()=>i});const i={TIMEOUT:{AUTH:6e4,GUN:5e3,WALLET:3e4},PATHS:{DERIVATION_BASE:"m/44'/60'/0'/0/",DEFAULT_INDEX:0},STORAGE_KEYS:{ENTROPY:"hedgehog-entropy-key",GUN_PAIR:"gun-current-pair",WALLET_PATHS:"walletPaths_",SESSION:"gun-current-session"},GUN_TABLES:{USERS:"users",WALLET_PATHS:"walletPathsV2",AUTHENTICATIONS:"authenticationsV2",WEBAUTHN:"webauthn",STEALTH:"stealth"},AUTH:{MIN_PASSWORD_LENGTH:8,MAX_USERNAME_LENGTH:64,MIN_USERNAME_LENGTH:3},PREFIX:"⚔️ ShogunSDK:",PEERS:[],MESSAGE_TO_SIGN:"Access With Shogun"}},8991:(e,t,r)=>{"use strict";r.r(t),r.d(t,{MetaMaskPlugin:()=>a});var i=r(4586),s=r(228),n=r(5628);class a extends i.j{constructor(){super(...arguments),this.name="metamask",this.version="1.0.0",this.description="Provides MetaMask wallet connection and authentication for ShogunCore",this.metamask=null}initialize(e){super.initialize(e),this.metamask=new s.C,(0,n.Rm)("MetaMask plugin initialized")}destroy(){this.metamask&&this.metamask.cleanup(),this.metamask=null,super.destroy(),(0,n.Rm)("MetaMask plugin destroyed")}assertMetaMask(){if(this.assertInitialized(),!this.metamask)throw new Error("MetaMask module not initialized");return this.metamask}isAvailable(){return this.assertMetaMask().isAvailable()}async connectMetaMask(){return this.assertMetaMask().connectMetaMask()}async generateCredentials(e){return this.assertMetaMask().generateCredentials(e)}cleanup(){this.assertMetaMask().cleanup()}setCustomProvider(e,t){this.assertMetaMask().setCustomProvider(e,t)}async getSigner(){return this.assertMetaMask().getSigner()}async generatePassword(e){return this.assertMetaMask().generatePassword(e)}async verifySignature(e,t){return this.assertMetaMask().verifySignature(e,t)}}}},s={};function n(e){var t=s[e];if(void 0!==t)return t.exports;var r=s[e]={id:e,loaded:!1,exports:{}};return i[e](r,r.exports,n),r.loaded=!0,r.exports}n.m=i,e=[],n.O=(t,r,i,s)=>{if(!r){var a=1/0;for(d=0;d<e.length;d++){for(var[r,i,s]=e[d],o=!0,u=0;u<r.length;u++)(!1&s||a>=s)&&Object.keys(n.O).every((e=>n.O[e](r[u])))?r.splice(u--,1):(o=!1,s<a&&(a=s));if(o){e.splice(d--,1);var c=i();void 0!==c&&(t=c)}}return t}s=s||0;for(var d=e.length;d>0&&e[d-1][2]>s;d--)e[d]=e[d-1];e[d]=[r,i,s]},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,r)=>(n.f[r](e,t),t)),[])),n.u=e=>e+".shogun-core.light.js",n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),t={},r="ShogunCore:",n.l=(e,i,s,a)=>{if(t[e])t[e].push(i);else{var o,u;if(void 0!==s)for(var c=document.getElementsByTagName("script"),d=0;d<c.length;d++){var h=c[d];if(h.getAttribute("src")==e||h.getAttribute("data-webpack")==r+s){o=h;break}}o||(u=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,n.nc&&o.setAttribute("nonce",n.nc),o.setAttribute("data-webpack",r+s),o.src=e),t[e]=[i];var l=(r,i)=>{o.onerror=o.onload=null,clearTimeout(g);var s=t[e];if(delete t[e],o.parentNode&&o.parentNode.removeChild(o),s&&s.forEach((e=>e(i))),r)return r(i)},g=setTimeout(l.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=l.bind(null,o.onerror),o.onload=l.bind(null,o.onload),u&&document.head.appendChild(o)}},n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;n.g.importScripts&&(e=n.g.location+"");var t=n.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var i=r.length-1;i>-1&&(!e||!/^http(s?):/.test(e));)e=r[i--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),n.p=e})(),(()=>{var e={792:0};n.f.j=(t,r)=>{var i=n.o(e,t)?e[t]:void 0;if(0!==i)if(i)r.push(i[2]);else{var s=new Promise(((r,s)=>i=e[t]=[r,s]));r.push(i[2]=s);var a=n.p+n.u(t),o=new Error;n.l(a,(r=>{if(n.o(e,t)&&(0!==(i=e[t])&&(e[t]=void 0),i)){var s=r&&("load"===r.type?"missing":r.type),a=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+s+": "+a+")",o.name="ChunkLoadError",o.type=s,o.request=a,i[1](o)}}),"chunk-"+t,t)}},n.O.j=t=>0===e[t];var t=(t,r)=>{var i,s,[a,o,u]=r,c=0;if(a.some((t=>0!==e[t]))){for(i in o)n.o(o,i)&&(n.m[i]=o[i]);if(u)var d=u(n)}for(t&&t(r);c<a.length;c++)s=a[c],n.o(e,s)&&e[s]&&e[s][0](),e[s]=0;return n.O(d)},r=this.webpackChunkShogunCore=this.webpackChunkShogunCore||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var a=n.O(void 0,[96],(()=>n(1751)));return a=(a=n.O(a)).default})()));