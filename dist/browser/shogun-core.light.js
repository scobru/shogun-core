!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ShogunCore=t():e.ShogunCore=t()}(this,(()=>(()=>{var e,t={1058:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Stealth:()=>a,default:()=>n});class a{constructor(){}formatPublicKey(){throw new Error("Stealth functionality disabled in light version")}async createAccount(){throw new Error("Stealth functionality disabled in light version")}async generateStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async openStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async getPublicKey(){throw new Error("Stealth functionality disabled in light version")}prepareStealthKeysForSaving(){throw new Error("Stealth functionality disabled in light version")}deriveWalletFromSecret(){throw new Error("Stealth functionality disabled in light version")}}const n=a},1447:(e,t,r)=>{"use strict";var a=r(9229),n=r.n(a),s=r(8030),i=r.n(s);const o={TIMEOUT:{AUTH:6e4,GUN:5e3,WALLET:3e4},PATHS:{DERIVATION_BASE:"m/44'/60'/0'/0/",DEFAULT_INDEX:0},STORAGE_KEYS:{ENTROPY:"hedgehog-entropy-key",GUN_PAIR:"gun-current-pair",WALLET_PATHS:"walletPaths_",SESSION:"gun-current-session"},GUN_TABLES:{USERS:"users",WALLET_PATHS:"walletPathsV2",AUTHENTICATIONS:"authenticationsV2",WEBAUTHN:"webauthn",STEALTH:"stealth"},AUTH:{MIN_PASSWORD_LENGTH:8,MAX_USERNAME_LENGTH:64,MIN_USERNAME_LENGTH:3},PREFIX:"⚔️ ShogunSDK:",PEERS:[],MESSAGE_TO_SIGN:"Access With Shogun"};let c={enabled:"true"===r(5606).env.DEBUG,level:"info",prefix:"[ShogunSDK]"},l=!1;function u(e){c={...c,...e}}function h(e,...t){(new Date).toISOString()}function d(e,...t){(new Date).toISOString()}function g(e,...t){(new Date).toISOString()}function w(e,...t){if(!l)return;(new Date).toISOString()}var m;function p(e,t,r,a){return{type:e,code:t,message:r,originalError:a,timestamp:Date.now()}}!function(e){e.AUTHENTICATION="AuthenticationError",e.AUTHORIZATION="AuthorizationError",e.VALIDATION="ValidationError",e.NETWORK="NetworkError",e.DATABASE="DatabaseError",e.WALLET="WalletError",e.DID="DIDError",e.STORAGE="StorageError",e.ENCRYPTION="EncryptionError",e.SIGNATURE="SignatureError",e.ENVIRONMENT="EnvironmentError",e.SECURITY="SecurityError",e.GUN="GunError",e.STEALTH="StealthError",e.WEBAUTHN="WebAuthnError",e.UNKNOWN="UnknownError",e.CONNECTOR="CONNECTOR",e.GENERAL="GENERAL"}(m||(m={}));class f{static handleError(e){d((e.type,e.code,e.message)),this.errors.push(e),this.errors.length>this.maxErrors&&(this.errors=this.errors.slice(-this.maxErrors)),this.notifyListeners(e)}static handle(e,t,r,a,n="error"){const s=a?`${r} - ${this.formatError(a)}`:r;switch(n){case"debug":h(`[${e}.${t}] (DEBUG) ${s}`);break;case"warn":h(`[${e}.${t}] (WARN) ${s}`);break;case"info":h(`[${e}.${t}] (INFO) ${s}`);break;default:h(`[${e}.${t}] (ERROR) ${s}`),a&&a instanceof Error&&h(a.stack||"No stack trace available")}const i=p(e,t,s,a);return this.handleError(i),i}static getRecentErrors(e=10){return this.errors.slice(-Math.min(e,this.errors.length))}static addListener(e){this.listeners.push(e)}static removeListener(e){const t=this.listeners.indexOf(e);-1!==t&&this.listeners.splice(t,1)}static notifyListeners(e){for(const t of this.listeners)try{t(e)}catch(e){d()}}static formatError(e){if(!e)return"Unknown error";if(e instanceof Error)return`${e.name}: ${e.message}`;if("string"==typeof e)return e;if("object"==typeof e)try{return JSON.stringify(e)}catch(t){return`Object: ${Object.prototype.toString.call(e)}`}return String(e)}static async withRetry(e,t,r,a=3,n=1e3){let s;for(let t=1;t<=a;t++)try{return await e()}catch(e){s=e;const r=n*t;t<a&&(h(`Retrying operation after ${r}ms (attempt ${t}/${a})`),await new Promise((e=>setTimeout(e,r))))}throw this.handle(t,r,`Operation failed after ${a} attempts`,s)}}f.errors=[],f.maxErrors=100,f.listeners=[];class y{constructor(e={}){this.certificato=null,this.onAuthCallbacks=[],this._authenticating=!1,h("Initializing GunDB"),this.retryConfig={attempts:e.retryAttempts??3,delay:e.retryDelay??1e3};const t={peers:e.peers,localStorage:e.localStorage??!1,radisk:e.radisk??!1,multicast:e.multicast??!1,axe:e.axe??!1};if(e.authToken){h(`Auth token received (${e.authToken.substring(0,3)+"..."+(e.authToken.length>6?e.authToken.substring(e.authToken.length-3):"")})`)}else h("No auth token received");this.gun=new(n())(t);e.authToken&&(n().on("opt",(function(e){e.once||e.on("out",(function(t){var r=e.to;t.headers={token:"thisIsTheTokenForReals"},r.next(t)}))})),h("Auth token handler configured for outgoing messages")),this.subscribeToAuthEvents()}async retry(e,t){let r;for(let a=0;a<this.retryConfig.attempts;a++)try{return await e()}catch(e){if(r=e instanceof Error?e:new Error(String(e)),a<this.retryConfig.attempts-1){const e=this.retryConfig.delay*Math.pow(2,a);h(`Retry attempt ${a+1} for ${t} in ${e}ms`),await new Promise((t=>setTimeout(t,e)))}}throw r}subscribeToAuthEvents(){this.gun.on("auth",(e=>{h("Auth event received:"),e.err?f.handle(m.GUN,"AUTH_EVENT_ERROR",e.err,new Error(e.err)):this.notifyAuthListeners(e.sea?.pub||"")}))}notifyAuthListeners(e){const t=this.gun.user();this.onAuthCallbacks.forEach((e=>{e(t)}))}static withPeers(e=o.PEERS){return new y({peers:e})}onAuth(e){this.onAuthCallbacks.push(e);const t=this.gun.user();return t&&t.is&&e(t),()=>{const t=this.onAuthCallbacks.indexOf(e);-1!==t&&this.onAuthCallbacks.splice(t,1)}}getGun(){return this.gun}getUser(){return this.gun.user()}setCertificate(e){this.certificato=e;this.gun.user().get("trust").get("certificate").put(e)}getCertificate(){return this.certificato}async signUp(e,t){try{return h("Attempting user registration:"),new Promise((r=>{this.gun.user().create(e,t,(async a=>{if(a.err)d(a.err),r({success:!1,error:a.err});else{const a=await this.login(e,t);a.success?h("Registration and login completed successfully"):d(),r(a)}}))}))}catch(e){return d(0),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}login(e,t,r){return h(`Attempting login for user: ${e}`),new Promise(((a,n)=>{if(!e||!t){const e="Username and password are required";return h(e),r&&r({err:e}),void n(new Error(e))}try{this.gun.user().leave(),h("Current user reset before login attempt")}catch(e){}h(`Performing auth with Gun for user: ${e}`),this.gun.user().auth(e,t,(t=>{if(t.err)h(`Login error: ${t.err}`),r&&r({err:t.err}),n(new Error(t.err));else{h("Authentication completed successfully");try{this._savePair(),h("User auth pair saved")}catch(e){h(`Warning: Error saving auth pair: ${e}`)}r&&r(t),a({success:!0,userPub:this.gun.user().is?.pub,username:e})}}))}))}_savePair(){try{const e=this.gun.user(),t=e._&&e._.sea;t&&"undefined"!=typeof localStorage&&localStorage.setItem("pair",JSON.stringify(t))}catch(e){}}isAuthenticating(){return!0===this._authenticating}_setAuthenticating(e){this._authenticating=e}logout(){try{h("Attempting logout"),this.gun.user().leave(),h("Logout completed")}catch(e){d(0)}}isLoggedIn(){const e=this.gun.user();return!!(e&&e.is&&e.is.pub)}getCurrentUser(){const e=this.gun.user()?.is?.pub;return e?{pub:e,user:this.gun.user()}:null}async saveWithRetry(e,t,r){return this.retry((()=>new Promise(((a,n)=>{e.put(t,(e=>{e.err?n(new Error(e.err)):a(t)}),r)}))),"data save operation")}async readWithRetry(e){return this.retry((()=>new Promise((t=>{e.once((e=>t(e)))}))),"data read operation")}async saveUserData(e,t){try{if(!this.gun.user()?.is?.pub)throw new Error("User not authenticated");const r=this.certificato?{opt:{cert:this.certificato}}:void 0;return await this.saveWithRetry(this.gun.user().get(e),t,r)}catch(t){throw f.handle(m.GUN,"SAVE_USER_DATA_ERROR",`Error saving data to path ${e}`,t),t}}async getUserData(e){try{if(!this.gun.user()?.is?.pub)throw new Error("User not authenticated");const t=await this.readWithRetry(this.gun.user().get(e));return t?(h(`Data retrieved from ${e}`),t):(h(`No data found at ${e}`),null)}catch(t){throw f.handle(m.GUN,"GET_USER_DATA_ERROR",`Error retrieving data from path ${e}`,t),t}}async savePublicData(e,t,r){return new Promise(((a,n)=>{const s=this.certificato?{opt:{cert:this.certificato}}:void 0;this.gun.get(e).get(t).put(r,(s=>{s&&s.err?(d(s.err),n(new Error(s.err))):(h(`Public data saved to ${e}/${t}`),a(r))}),s)}))}async getPublicData(e,t){return new Promise((r=>{this.gun.get(e).get(t).once((a=>{a?(h(`Public data retrieved from ${e}/${t}`),r(a)):(h(`No public data found at ${e}/${t}`),r(null))}))}))}async generateKeyPair(){return n().SEA.pair()}}"undefined"!=typeof window?window.GunDB=y:void 0!==r.g&&(r.g.GunDB=y);var E=r(3439),v=r(6525),S=r(1442),A=r(31),b=r(2011),I=r(7303),D=r(8051),T=r(4532),M=r(7649),N=r(7007);class P extends N.EventEmitter{constructor(e={}){super(),this.MESSAGE_TO_SIGN="I Love Shogun!",this.DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4},this.signatureCache=new Map,this.provider=null,this.customProvider=null,this.customWallet=null,this.config={...this.DEFAULT_CONFIG,...e},this.AUTH_DATA_TABLE=o.GUN_TABLES.AUTHENTICATIONS||"Authentications",this.setupProvider(),this.setupEventListeners()}async setupProvider(){try{"undefined"!=typeof window&&window.ethereum?(this.provider=new v.k(window.ethereum),w()):g()}catch(e){d(0)}}setupEventListeners(){this.provider&&(this.provider.on("network",((e,t)=>{this.emit("chainChanged",e)})),window.ethereum?.on&&window.ethereum.on("accountsChanged",(e=>{this.emit("accountsChanged",e)})))}cleanup(){this.provider&&this.provider.removeAllListeners(),this.removeAllListeners()}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim().toLowerCase();if(!S.PW(t))throw new Error("Invalid address format");return A.b(t)}catch(e){throw f.handle(m.VALIDATION,"INVALID_ADDRESS","Invalid Ethereum address provided",e),e}}async connectMetaMask(){try{if(w(),!this.provider&&(w(),await this.setupProvider(),!this.provider))throw new Error("MetaMask is not available. Please install MetaMask extension.");w();let e=[];if(window.ethereum)try{e=await window.ethereum.request({method:"eth_requestAccounts"}),w(e.length)}catch(e){throw d(0),new Error("User denied account access")}e&&0!==e.length||w();for(let e=1;e<=this.config.maxRetries;e++)try{w();const e=await this.provider.getSigner(),t=await e.getAddress();if(!t)throw d(),new Error("No accounts found in MetaMask");w();const r=`mm_${t.toLowerCase()}`;return this.emit("connected",{address:t}),w(),{success:!0,address:t,username:r}}catch(t){if(d(0),e===this.config.maxRetries)throw t;w(this.config.retryDelay),await new Promise((e=>setTimeout(e,this.config.retryDelay)))}throw new Error("Failed to connect after retries")}catch(e){return d(0),f.handle(m.NETWORK,"METAMASK_CONNECTION_ERROR",e.message||"Unknown error while connecting to MetaMask",e),{success:!1,error:e.message}}}async generateCredentials(e){w(0);try{const t=this.validateAddress(e),r=this.getCachedSignature(t);if(r)return w(0),this.generateCredentialsFromSignature(t,r);try{const e=await this.requestSignatureWithTimeout(t,this.MESSAGE_TO_SIGN,this.config.timeout);return this.cacheSignature(t,e),this.generateCredentialsFromSignature(t,e)}catch(e){return g(),this.generateFallbackCredentials(t)}}catch(e){throw f.handle(m.AUTHENTICATION,"CREDENTIALS_GENERATION_ERROR",e.message||"Error generating MetaMask credentials",e),e}}generateCredentialsFromSignature(e,t){return{username:`mm_${e.toLowerCase()}`,password:b.S(I.YW(`${t}:${e.toLowerCase()}`)),message:this.MESSAGE_TO_SIGN,signature:t}}generateFallbackCredentials(e){g(0);const t=`mm_${e.toLowerCase()}`,r=`SHOGUN_FALLBACK:${e.toLowerCase()}`;return{username:t,password:b.S(I.YW(r)),message:r,signature:b.S(I.YW(r))}}static isMetaMaskAvailable(){const e=window.ethereum;return"undefined"!=typeof window&&void 0!==e&&!0===e?.isMetaMask}async requestSignatureWithTimeout(e,t,r=3e4){return new Promise((async(a,n)=>{let s=setTimeout((()=>{s=null,n(new Error("Timeout requesting signature"))}),r);try{if(!this.provider&&(await this.setupProvider(),!this.provider))throw new Error("Provider not initialized");let r,i;try{r=await this.provider.getSigner()}catch(e){throw d(0),new Error(`Failed to get signer: ${e.message}`)}try{i=await r.getAddress()}catch(e){throw d(0),new Error(`Failed to get signer address: ${e.message}`)}if(i.toLowerCase()!==e.toLowerCase())throw new Error(`Signer address (${i}) does not match expected address (${e})`);w();const o=e=>{s&&(clearTimeout(s),s=null),n(e)};window.ethereum?.on&&window.ethereum.on("accountsChanged",o);try{const e=await r.signMessage(t);w(),s&&(clearTimeout(s),s=null),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",o),a(e)}catch(e){throw d(0),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",o),e}}catch(e){d(0),s&&(clearTimeout(s),s=null),n(e)}}))}isAvailable(){return"undefined"!=typeof window&&!!window.ethereum}setCustomProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Invalid RPC URL");if(!t||"string"!=typeof t)throw new Error("Invalid private key");try{this.customProvider=new D.FR(e),this.customWallet=new T.u(t,this.customProvider),w()}catch(e){throw new Error(`Error configuring provider: ${e.message||"Unknown error"}`)}}async getSigner(){try{if(this.customWallet)return this.customWallet;if(this.provider||await this.setupProvider(),!this.provider)throw new Error("Provider not initialized");return await this.provider.getSigner()}catch(e){throw new Error(`Unable to get Ethereum signer: ${e.message||"Unknown error"}`)}}async generatePassword(e){if(!e)throw new Error("Invalid signature");return b.S(I.YW(e)).slice(2,66)}async verifySignature(e,t){if(!e||!t)throw new Error("Invalid message or signature");try{return M.l(e,t)}catch(e){throw new Error("Invalid message or signature")}}async getEthereumSigner(){if(!P.isMetaMaskAvailable())throw new Error("MetaMask not found. Please install MetaMask to continue.");try{const e=window.ethereum;await e.request({method:"eth_requestAccounts"});return new v.k(e).getSigner()}catch(e){throw new Error(`Error accessing MetaMask: ${e.message||"Unknown error"}`)}}}"undefined"!=typeof window?window.MetaMask=P:void 0!==r.g&&(r.g.MetaMask=P);var U=r(1058);class R{constructor(){if(this.store=new Map,"undefined"!=typeof localStorage)try{const e=localStorage.getItem("shogun_keypair");e&&this.store.set("keypair",JSON.parse(e))}catch(e){}}async getPair(){return this.getPairSync()}getPairSync(){return this.store.get("keypair")||null}async setPair(e){if(this.store.set("keypair",e),"undefined"!=typeof localStorage)try{localStorage.setItem("shogun_keypair",JSON.stringify(e))}catch(e){}}clearAll(){if(this.store.clear(),"undefined"!=typeof localStorage)try{localStorage.removeItem("shogun_keypair")}catch(e){}}getItem(e){const t=this.store.get(e);return void 0!==t?JSON.stringify(t):null}setItem(e,t){try{const r=JSON.parse(t);if(this.store.set(e,r),"undefined"!=typeof localStorage)try{localStorage.setItem(e,t)}catch(e){}}catch(r){if(this.store.set(e,t),"undefined"!=typeof localStorage)try{localStorage.setItem(e,t)}catch(e){}}}removeItem(e){if(this.store.delete(e),"undefined"!=typeof localStorage)try{localStorage.removeItem(e)}catch(e){}}}var W,O=r(4050),_=r(7514),L=r(7761),C=r(9770);!function(e){e.WALLET_CREATED="walletCreated",e.WALLET_IMPORTED="walletImported",e.BALANCE_UPDATED="balanceUpdated",e.TRANSACTION_SENT="transactionSent",e.TRANSACTION_CONFIRMED="transactionConfirmed",e.ERROR="error"}(W||(W={}));class $ extends N.EventEmitter{constructor(e,t,r,a){super(),this.walletPaths={},this.mainWallet=null,this.balanceCache=new Map,this.pendingTransactions=new Map,this.gundb=e,this.gun=t,this.storage=r,this.config={balanceCacheTTL:3e4,rpcUrl:"",defaultGasLimit:21e3,maxRetries:3,retryDelay:1e3,...a},this.initializeWalletPaths(),this.setupTransactionMonitoring()}setupTransactionMonitoring(){setInterval((()=>{null!==this.getProvider()&&this.checkPendingTransactions()}),15e3)}async checkPendingTransactions(){const e=this.getProvider();for(const[t,r]of this.pendingTransactions)try{const a=await e.getTransactionReceipt(t);a&&(1===a.status?this.emit(W.TRANSACTION_CONFIRMED,{type:W.TRANSACTION_CONFIRMED,data:{txHash:t,receipt:a},timestamp:Date.now()}):this.emit(W.ERROR,{type:W.ERROR,data:{txHash:t,error:"Transaction failed"},timestamp:Date.now()}),this.pendingTransactions.delete(t),this.invalidateBalanceCache(r.from),r.to&&this.invalidateBalanceCache(r.to))}catch(e){d(0)}}setRpcUrl(e){this.config.rpcUrl=e,h(`RPC Provider configured: ${e}`)}getProvider(){if(!this.config.rpcUrl)throw new Error("RPC URL not configured");return new D.FR(this.config.rpcUrl)}async initializeWalletPaths(){try{this.walletPaths={},await this.loadWalletPathsFromGun(),await this.loadWalletPathsFromLocalStorage();const e=Object.keys(this.walletPaths).length;h(0===e?"No wallet paths found, new wallets will be created when needed":`Initialized ${e} wallet paths`)}catch(e){throw new Error(`Failed to initialize wallet paths: ${e instanceof Error?e.message:String(e)}`)}}async loadWalletPathsFromGun(){const e=this.gun.user();return e?.is?(h(`Loading wallet paths from GUN for user: ${e.is.alias}`),new Promise((t=>{e.get("wallet_paths").once((e=>{if(!e)return h("No wallet paths found in GUN"),void t();h(`Found wallet paths in GUN: ${Object.keys(e).length-1} wallets`),Object.entries(e).forEach((([e,t])=>{if("_"!==e&&t){const r=t;r?.path&&(this.walletPaths[e]={path:r.path,created:r.created||Date.now()},h(`Loaded path for wallet: ${e} -> ${r.path}`))}})),t()}))}))):(h("User not authenticated on Gun, cannot load wallet paths from Gun"),Promise.resolve())}async loadWalletPathsFromLocalStorage(){const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=this.storage.getItem(e);if(t)try{h("Found wallet paths in localStorage");const e=JSON.parse(t);Object.entries(e).forEach((([e,t])=>{this.walletPaths[e]||(this.walletPaths[e]=t,h(`Loaded path from localStorage for wallet: ${e}`))}))}catch(e){}}getStorageUserIdentifier(){const e=this.gun.user(),t=e?.is?.pub;return t?t.substring(0,12):"guest"}saveWalletPathsToLocalStorage(){try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=JSON.stringify(this.walletPaths);this.storage.setItem(e,t),h(`Saved ${Object.keys(this.walletPaths).length} wallet paths to localStorage`)}catch(e){}}derivePrivateKeyFromMnemonic(e,t){try{h(`Deriving wallet from path: ${t}`);const r=O.QX.fromMnemonic(_.v.fromPhrase(e),t);if(!r||!r.privateKey)throw new Error(`Unable to derive wallet for path ${t}`);return r}catch(e){throw new Error(`Unable to derive wallet for path ${t}`)}}generateNewMnemonic(){return _.v.fromEntropy(L.p(16)).phrase}getStandardBIP44Addresses(e,t=5){try{h("Standard BIP-44 derivation from mnemonic");const r=[];for(let a=0;a<t;a++){const t=`m/44'/60'/0'/0/${a}`,n=O.QX.fromMnemonic(_.v.fromPhrase(e),t);r.push(n.address),h(`Address ${a}: ${n.address} (${t})`)}return r}catch(e){return h(`Error calculating BIP-44 addresses: ${e}`),[]}}generatePrivateKeyFromString(e){try{const t=(new TextEncoder).encode(e),r=e=>{let t=3735928559,r=1103547991;for(let a=0;a<e.length;a++)t=Math.imul(t^e[a],2654435761),r=Math.imul(r^e[a],1597334677);t=Math.imul(t^t>>>16,2246822507),t=Math.imul(t^t>>>13,3266489909),r=Math.imul(r^r>>>16,2246822507),r=Math.imul(r^r>>>13,3266489909);const a=new Uint8Array(32);for(let e=0;e<4;e++)a[e]=t>>8*e&255;for(let e=0;e<4;e++)a[e+4]=r>>8*e&255;for(let e=8;e<32;e++)a[e]=255&(a[e%8]^a[(e-1)%8]);return a},a=r(t);return"0x"+Array.from(a).map((e=>e.toString(16).padStart(2,"0"))).join("")}catch(e){return"0x"+Array.from({length:32}).map((()=>Math.floor(256*Math.random()).toString(16).padStart(2,"0"))).join("")}}getMainWallet(){try{if(!this.mainWallet){const e=this.gun.user();if(!e||!e.is)return h("getMainWallet: User not authenticated"),null;if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub)){if(h("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),e.is.alias&&e.is.alias.startsWith("0x")){h("getMainWallet: MetaMask user detected, using alternative approach");const t=`metamask-${e.is.alias}-${Date.now()}`,r=this.generatePrivateKeyFromString(t);return this.mainWallet=new T.u(r),this.mainWallet}return null}const t=e._.sea.priv,r=e._.sea.pub,a=`${t}|${r}|${e.is.alias}`,n=this.generatePrivateKeyFromString(a);this.mainWallet=new T.u(n)}return this.mainWallet}catch(e){return null}}async encryptSensitiveData(e){try{const t=this.gun.user();if(t&&t._&&t._.sea){const r=await i().encrypt(e,t._.sea);return JSON.stringify(r)}{const t=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`,r=await i().encrypt(e,t);return JSON.stringify(r)}}catch(t){return h("WARNING: Sensitive data saved without encryption"),`unencrypted:${e}`}}async decryptSensitiveData(e){try{if(e.startsWith("unencrypted:"))return e.substring(12);const t=JSON.parse(e),r=this.gun.user();if(r&&r._&&r._.sea){return await i().decrypt(t,r._.sea)}{const e=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`;return await i().decrypt(t,e)}}catch(e){return null}}async getUserMasterMnemonic(){try{const e=this.gun.user();if(e&&e.is){const t=await new Promise((t=>{e.get("master_mnemonic").once((e=>{t(e||null)}))}));if(t)return h("Mnemonic retrieved from GunDB"),h("gunMnemonic: "),t}const t=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,r=this.storage.getItem(t);if(!r)return h("No mnemonic found in either GunDB or localStorage"),null;const a=await this.decryptSensitiveData(r);return h("Mnemonic retrieved from localStorage"),a&&e&&e.is&&(await e.get("master_mnemonic").put(a),h("Mnemonic from localStorage synced to GunDB")),a}catch(e){return null}}async saveUserMasterMnemonic(e){try{const t=this.gun.user();t&&t.is&&(await t.get("master_mnemonic").put(e),h("Mnemonic saved to GunDB"));const r=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,a=await this.encryptSensitiveData(e);this.storage.setItem(r,a),h("Encrypted mnemonic also saved to localStorage as backup")}catch(e){throw e}}async createWallet(){try{const e=this.gun.user();if(!e.is)throw new Error("User is not authenticated");const t=Object.values(this.walletPaths).length,r=`m/44'/60'/0'/0/${t}`;let a,n=await this.getUserMasterMnemonic();if(!n)try{n=this.generateNewMnemonic(),await this.saveUserMasterMnemonic(n),h(`Generated new mnemonic: ${n}`)}catch(e){throw new Error(`Failed to generate or save mnemonic: ${e instanceof Error?e.message:String(e)}`)}h("*** masterMnemonic: ");try{a=this.derivePrivateKeyFromMnemonic(n,r),h(`Derived wallet for path ${r} with address ${a.address}`)}catch(e){throw new Error(`Failed to derive wallet: ${e instanceof Error?e.message:String(e)}`)}const s=Date.now();this.walletPaths[a.address]={path:r,created:s};try{await e.get("wallet_paths").get(a.address).put({path:r,created:s}),this.saveWalletPathsToLocalStorage()}catch(e){h("Wallet created but path might not be persisted properly")}return{wallet:a,path:r,address:a.address,getAddressString:()=>a.address}}catch(e){throw new Error(`Failed to create wallet: ${e instanceof Error?e.message:String(e)}`)}}async loadWallets(){try{if(!this.gun.user())throw new Error("Gun user not available");try{await this.initializeWalletPaths()}catch(e){h("Will attempt to continue with any available wallet data")}let e=await this.getUserMasterMnemonic();if(!e){return[await this.createWallet()]}h(`masterMnemonic found: ${e}`);const t=[];for(const[r,a]of Object.entries(this.walletPaths))try{const n=this.derivePrivateKeyFromMnemonic(e,a.path||`m/44'/60'/0'/0/${r.substring(0,6)}`);h(`Derived wallet for path ${a.path||"fallback"} with address ${n.address}`),n.address.toLowerCase(),r.toLowerCase(),t.push({wallet:n,path:a.path||`m/44'/60'/0'/0/${n.address.substring(0,8)}`,address:n.address,getAddressString:()=>n.address})}catch(e){}return t.length>0&&(this.mainWallet=t[0].wallet),t}catch(e){throw new Error(`Failed to load wallets: ${e instanceof Error?e.message:String(e)}`)}}async getBalance(e){try{const t=e.address,r=Date.now(),a=this.balanceCache.get(t);if(a&&r-a.timestamp<this.config.balanceCacheTTL)return a.balance;const n=this.getProvider(),s=await n.getBalance(t),i=C.ck(s);return this.balanceCache.set(t,{balance:i,timestamp:r}),this.emit(W.BALANCE_UPDATED,{type:W.BALANCE_UPDATED,data:{address:t,balance:i},timestamp:r}),i}catch(e){return d(0),"0.0"}}invalidateBalanceCache(e){this.balanceCache.delete(e),h(`Balance cache invalidated for ${e}`)}async getNonce(e){const t=this.getProvider();return await t.getTransactionCount(e.address)}async sendTransaction(e,t,r,a={}){try{const n=this.getProvider();e=e.connect(n);const s=await n.getFeeData(),i={to:t,value:C.g5(r),gasLimit:a.gasLimit||this.config.defaultGasLimit,nonce:a.nonce||await n.getTransactionCount(e.address),maxFeePerGas:a.maxFeePerGas?C.XS(a.maxFeePerGas,"gwei"):s.maxFeePerGas,maxPriorityFeePerGas:a.maxPriorityFeePerGas?C.XS(a.maxPriorityFeePerGas,"gwei"):s.maxPriorityFeePerGas};for(let t=1;t<=(this.config.maxRetries||3);t++)try{const t=await e.sendTransaction(i);return this.pendingTransactions.set(t.hash,t),this.emit(W.TRANSACTION_SENT,{type:W.TRANSACTION_SENT,data:{txHash:t.hash,tx:i},timestamp:Date.now()}),t.hash}catch(r){if(t===this.config.maxRetries)throw r;await new Promise((e=>setTimeout(e,this.config.retryDelay))),i.nonce=await n.getTransactionCount(e.address);const a=await n.getFeeData();i.maxFeePerGas=a.maxFeePerGas,i.maxPriorityFeePerGas=a.maxPriorityFeePerGas}throw new Error("Transaction failed after all retry attempts")}catch(t){throw d(0),this.emit(W.ERROR,{type:W.ERROR,data:{error:t,wallet:e.address},timestamp:Date.now()}),t}}async signMessage(e,t){try{return await e.signMessage(t)}catch(e){throw e}}verifySignature(e,t){return M.l(e,t)}async signTransaction(e,t,r,a){try{h(`Signing transaction from wallet ${e.address} to ${t} for ${r} ETH`);const n=a||this.getProvider(),s=await n.getTransactionCount(e.address);h(`Nonce for transaction: ${s}`);const i=await n.getFeeData(),o={nonce:s,to:t,value:C.g5(r),gasPrice:i.gasPrice,gasLimit:21e3},c=await e.signTransaction(o);return h("Transaction signed successfully"),c}catch(e){throw e}}resetMainWallet(){h("Resetting main wallet"),this.mainWallet=null}async exportMnemonic(e){try{h("⚠️ SECURITY WARNING: Exporting mnemonic phrase - handle with extreme care!");const t=await this.getUserMasterMnemonic();if(!t)throw new Error("No mnemonic available for this user");return e?this.encryptSensitiveData(t):t}catch(e){throw d(0),e}}async exportWalletKeys(e){try{if(h("⚠️ SECURITY WARNING: Exporting wallet private keys - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export wallet keys");const t=await this.loadWallets();if(0===t.length)throw new Error("No wallets found to export");const r=t.map((e=>{const t=e.wallet;return{address:t.address,privateKey:t.privateKey,path:e.path,created:this.walletPaths[t.address]?.created||Date.now()}})),a=JSON.stringify(r);return e?this.encryptSensitiveData(a):a}catch(e){throw d(0),e}}async exportGunPair(e){try{if(h("⚠️ SECURITY WARNING: Exporting GunDB pair - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export GunDB pair");const t=this.gun.user()._.sea;if(!t)throw new Error("No GunDB pair available for this user");const r=JSON.stringify(t);return e?this.encryptSensitiveData(r):r}catch(e){throw d(0),e}}async exportAllUserData(e){if(!e)throw new Error("È richiesta una password per esportare tutti i dati");try{const t=await this.getUserMasterMnemonic(),r=await this.loadWallets(),a=this.gun.user();if(!a||!a._||!a._.sea)throw new Error("Utente non autenticato o dati non disponibili");const n=r.map((e=>{const t=e.address||"";return{address:t,privateKey:e.wallet.privateKey,path:e.path,created:t&&this.walletPaths[t]?.created||Date.now()}})),s={user:{alias:a.is.alias,pub:a.is.pub,pair:a._.sea},mnemonic:t,wallets:n,version:"1.0",exportedAt:(new Date).toISOString(),appName:"Shogun Wallet"},o=await i().encrypt(JSON.stringify(s),e);return JSON.stringify({type:"encrypted-shogun-backup",data:o,version:"1.0"})}catch(e){throw e}}async importMnemonic(e,t){try{let r=e;if(e.startsWith("{"))try{const a=JSON.parse(e);if("encrypted-mnemonic"===a.type&&a.data&&t){const e=await i().decrypt(a.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=e}else a.mnemonic&&(r=a.mnemonic)}catch(e){throw new Error("Formato JSON non valido o password errata")}try{_.v.fromPhrase(r)}catch(e){throw new Error("La mnemonica fornita non è valida")}const a=this.gun.user();if(!a||!a.is)throw new Error("L'utente deve essere autenticato per importare una mnemonica");h("Cancellazione dei wallet path esistenti prima dell'importazione della nuova mnemonica");try{await a.get("wallet_paths").put(null),h("Wallet path eliminati da Gun con successo")}catch(e){}try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`;this.storage.removeItem(e),h("Wallet path eliminati da localStorage con successo")}catch(e){}return this.walletPaths={},await this.saveUserMasterMnemonic(r),h("Nuova mnemonica salvata con successo"),this.resetMainWallet(),await this.createWallet(),h("Generato nuovo wallet con la mnemonica importata"),!0}catch(e){throw e}}async importWalletKeys(e,t){try{let r=[];e.length,e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(e.startsWith("{")||e.startsWith("[")){const a=JSON.parse(e);if("encrypted-wallets"===a.type&&a.data&&t)try{const e=await i().decrypt(a.data,t);if(!e)throw new Error("Password non valida o dati corrotti");"string"==typeof e&&e.length;try{const t=JSON.parse(e);if(t.wallets&&Array.isArray(t.wallets))r=t.wallets;else{if(!Array.isArray(t))throw new Error("Formato JSON decifrato non valido: manca il campo 'wallets'");r=t}}catch(e){throw new Error("Formato JSON decifrato non valido")}}catch(e){throw new Error(`Errore durante la decifratura: ${e.message||String(e)}`)}else if(a.wallets){if(!Array.isArray(a.wallets))throw new Error("Formato JSON non valido: il campo 'wallets' non è un array");r=a.wallets}else{if(!Array.isArray(a))throw new Error("Formato JSON non valido: manca il campo 'wallets'");r=a}}else{if(e.split(" ").length>=12)throw new Error("I dati sembrano essere una mnemonic, usa 'Importa Mnemonica' invece");if(!e.startsWith("0x")||66!==e.length)throw new Error("Formato non riconosciuto. Fornisci un file JSON valido.");try{const t=new T.u(e),a="m/44'/60'/0'/0/0";r=[{address:t.address,privateKey:t.privateKey,path:a,created:Date.now()}]}catch(e){throw new Error(`Chiave privata non valida: ${e}`)}}}catch(e){throw new Error(`Formato JSON non valido o password errata: ${e||String(e)}`)}if(!Array.isArray(r)||0===r.length)throw new Error("Nessun wallet valido trovato nei dati forniti");let a=0;for(const e of r)try{if(!e.privateKey)continue;const t=e.path||"m/44'/60'/0'/0/0";try{const r=new T.u(e.privateKey);e.address&&(r.address.toLowerCase(),e.address.toLowerCase()),this.walletPaths[r.address]={path:t,created:e.created||Date.now()},this.saveWalletPathsToLocalStorage(),a++}catch(e){}}catch(e){}if(0===a)throw new Error("Nessun wallet è stato importato con successo");return this.resetMainWallet(),a}catch(e){throw e}}async importGunPair(e,t){try{let r;try{const a=JSON.parse(e);if("encrypted-gun-pair"===a.type&&a.data&&t){const e=await i().decrypt(a.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=JSON.parse(e)}else r=a}catch(e){throw new Error("Formato JSON non valido o password errata")}if(!(r&&r.pub&&r.priv&&r.epub&&r.epriv))throw new Error("Il pair di Gun non è completo o valido");try{if(!this.gun.user())throw new Error("Gun non disponibile");return h("Pair di Gun validato con successo, pronto per l'autenticazione"),!0}catch(e){throw new Error(`Errore nell'autenticazione con il pair importato: ${e}`)}}catch(e){throw e}}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){try{if(!t)throw new Error("La password è obbligatoria per importare il backup");let a;e.length,e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(!e.startsWith("{")&&!e.startsWith("["))throw new Error("Il backup deve essere in formato JSON valido");const r=JSON.parse(e);if("encrypted-shogun-backup"!==r.type||!r.data)throw new Error("Formato del backup non valido: manca il tipo o i dati");try{a=await i().decrypt(r.data,t)}catch(e){throw new Error(`Errore nella decifratura: ${e}`)}if(!a)throw new Error("Password non valida o dati corrotti");"string"==typeof a&&a.length;try{a=JSON.parse(a)}catch(e){throw new Error(`Errore nel parsing del contenuto decifrato: ${e}`)}}catch(e){throw new Error(`Formato JSON non valido o password errata: ${e}`)}const n={success:!1};if(r.importMnemonic&&a.mnemonic)try{await this.saveUserMasterMnemonic(a.mnemonic),n.mnemonicImported=!0}catch(e){n.mnemonicImported=!1}if(r.importWallets&&a.wallets&&Array.isArray(a.wallets))try{const e=JSON.stringify({wallets:a.wallets});n.walletsImported=await this.importWalletKeys(e)}catch(e){n.walletsImported=0}else r.importWallets;if(r.importGunPair&&a.user&&a.user.pair)try{const e=JSON.stringify(a.user.pair);await this.importGunPair(e),n.gunPairImported=!0}catch(e){n.gunPairImported=!1}else r.importGunPair;return n.success=!!(r.importMnemonic&&n.mnemonicImported||r.importWallets&&n.walletsImported&&n.walletsImported>0||r.importGunPair&&n.gunPairImported),n}catch(e){throw e}}setBalanceCacheTTL(e){if(e<0)throw new Error("Cache TTL must be a positive number");this.config.balanceCacheTTL=e,h(`Balance cache TTL updated to ${e}ms`)}isUserAuthenticated(){const e=this.gun.user();return!!(e&&e._&&e._.sea)}async exportWalletData(e={}){try{const t=await this.loadWallets(),r={version:"2.0",timestamp:Date.now(),wallets:t.map((t=>({address:t.address,path:t.path,created:this.walletPaths[t.address]?.created||Date.now(),...e.includePrivateKeys?{privateKey:t.wallet.privateKey}:{}}))),...e.includeHistory?{history:await this.getWalletHistory()}:{}};if(e.encryptionPassword){const t=await i().encrypt(JSON.stringify(r),e.encryptionPassword);return JSON.stringify({type:"encrypted-wallet-backup",version:"2.0",data:t})}return JSON.stringify(r)}catch(e){throw d(0),e}}async importWalletData(e,t={}){try{let r;if(!e.startsWith("{"))throw new Error("Invalid wallet data format");{const a=JSON.parse(e);if("encrypted-wallet-backup"===a.type&&t.decryptionPassword){const e=await i().decrypt(a.data,t.decryptionPassword);if(!e)throw new Error("Decryption failed");r=JSON.parse(e)}else r=a}let a=0;for(const e of r.wallets)try{if(t.validateAddresses){if(!S.PW(e.address))continue}if(!t.overwriteExisting&&this.walletPaths[e.address])continue;this.walletPaths[e.address]={path:e.path,created:e.created||Date.now()},a++}catch(t){d(e.address);continue}return await this.saveWalletPathsToLocalStorage(),this.emit(W.WALLET_IMPORTED,{type:W.WALLET_IMPORTED,data:{count:a},timestamp:Date.now()}),a}catch(e){throw d(0),e}}async getWalletHistory(){return[]}}var k=r(7776),G=r(7828);class F{constructor(e){if(h("Initializing ShogunSDK"),this.config=e,e.logging&&(u(e.logging),h("Logging configured with custom settings")),this.storage=new R,this.eventEmitter=new N.EventEmitter,f.addListener((e=>{this.eventEmitter.emit("error",{action:e.code,message:e.message,type:e.type})})),e.gundb||(e.gundb={},h("No GunDB configuration provided, using defaults")),e.gundb.authToken){h(`Auth token from config: ${e.gundb.authToken}`)}else h("No auth token in config");const t={peers:e.gundb?.peers,websocket:e.gundb?.websocket??!1,localStorage:e.gundb?.localStorage??!1,radisk:e.gundb?.radisk??!1,authToken:e.gundb?.authToken,multicast:e.gundb?.multicast??!1,axe:e.gundb?.axe??!1};this.gundb=new y(t),this.gun=this.gundb.getGun(),e.webauthn?.enabled&&(this.webauthn=new E.Webauthn),e.metamask?.enabled&&(this.metamask=new P),e.stealth?.enabled&&(this.stealth=new U.Stealth(this.storage)),e.did?.enabled&&(this.did=new G.ShogunDID(this)),e.providerUrl?(this.provider=new D.FR(e.providerUrl),h(`Using configured provider URL: ${e.providerUrl}`)):(this.provider=k.x("mainnet"),h("WARNING: Using default Ethereum provider. For production use, configure a specific provider URL.")),e.walletManager?.enabled&&(this.walletManager=new $(this.gundb,this.gun,this.storage,{balanceCacheTTL:e.walletManager?.balanceCacheTTL,rpcUrl:e.providerUrl}),e.providerUrl&&this.walletManager.setRpcUrl(e.providerUrl)),h("ShogunSDK initialized!")}getRecentErrors(e=10){return f.getRecentErrors(e)}isLoggedIn(){const e=this.gundb.isLoggedIn(),t=this.gun.user();if(e)return!0;const r=t&&t._&&t._.sea,a=this.storage.getItem("pair");return!!r||!!a}logout(){try{if(!this.isLoggedIn())return void h("Logout ignored: user not authenticated");this.gundb.logout(),this.eventEmitter.emit("auth:logout",{}),h("Logout completed successfully")}catch(e){f.handle(m.AUTHENTICATION,"LOGOUT_FAILED",e instanceof Error?e.message:"Error during logout",e)}}async login(e,t){h("Login");try{if(h(`Login attempt for user: ${e}`),!e||!t)return{success:!1,error:"Username and password are required"};const r=new Promise((r=>{this.gundb.gun.user().auth(e,t,(t=>{if(t.err)h(`Login error: ${t.err}`),r({success:!1,error:t.err});else{const t=this.gundb.gun.user();if(t.is){h("Login completed successfully");const a=t.is?.pub||"";r({success:!0,userPub:a,username:e})}else r({success:!1,error:"Login failed: user not authenticated"})}}))})),a=this.config?.timeouts?.login||15e3,n=new Promise((e=>{setTimeout((()=>{e({success:!1,error:"Login timeout"})}),a)})),s=await Promise.race([r,n]);if(s.success){this.eventEmitter.emit("auth:login",{userPub:s.userPub||""});try{const e=await this.ensureUserHasDID();e&&(s.did=e)}catch(e){d(0)}}return s}catch(e){return f.handle(m.AUTHENTICATION,"LOGIN_FAILED",e.message||"Unknown error during login",e),{success:!1,error:e.message||"Unknown error during login"}}}async signUp(e,t,r){h("Sign up");try{if(!e||!t)return{success:!1,error:"Username and password are required"};if(void 0!==r&&t!==r)return{success:!1,error:"Passwords do not match"};if(t.length<6)return{success:!1,error:"Password must be at least 6 characters long"};const a=new Promise((r=>{this.gundb.gun.user().create(e,t,(a=>{a.err?r({success:!1,error:a.err}):this.gundb.gun.user().auth(e,t,(t=>{if(t.err)r({success:!1,error:"Registration completed but login failed"});else{const t=this.gundb.gun.user();t.is?r({success:!0,userPub:t.is?.pub||"",username:e||""}):r({success:!1,error:"Registration completed but user not authenticated"})}}))}))})),n=this.config?.timeouts?.signup||2e4,s=new Promise((e=>{setTimeout((()=>{e({success:!1,error:"Registration timeout"})}),n)})),i=await Promise.race([a,s]);if(i.success){this.eventEmitter.emit("auth:signup",{userPub:i.userPub||"",username:e});try{const e=await this.ensureUserHasDID();e&&(h(`Created DID for new user: ${e}`),i.did=e)}catch(e){d(0)}}return i}catch(e){return d(0),{success:!1,error:e.message||"Unknown error during registration"}}}isWebAuthnSupported(){return this.webauthn?.isSupported()||!1}async loginWithWebAuthn(e){h("Login with WebAuthn");try{if(h(`Attempting WebAuthn login for user: ${e}`),!e)throw new Error("Username required for WebAuthn login");if(!this.isWebAuthnSupported())throw new Error("WebAuthn is not supported by this browser");const t=await(this.webauthn?.generateCredentials(e,null,!0));if(!t?.success)throw new Error(t?.error||"WebAuthn verification failed");const r=b.S(I.YW(t.credentialId||"")),a=await this.login(e,r);if(a.success){if(h(`WebAuthn login completed successfully for user: ${e}`),!a.did)try{const e=await this.ensureUserHasDID();e&&(a.did=e)}catch(e){d(0)}return{...a,username:e,password:r,credentialId:t.credentialId}}return a}catch(e){return d(),{success:!1,error:e.message||"Error during WebAuthn login"}}}async signUpWithWebAuthn(e){h("Sign up with WebAuthn");try{if(h(`Attempting WebAuthn registration for user: ${e}`),!e)throw new Error("Username required for WebAuthn registration");if(!this.isWebAuthnSupported())throw new Error("WebAuthn is not supported by this browser");const t=await(this.webauthn?.generateCredentials(e,null,!1));if(!t?.success)throw new Error(t?.error||"Unable to generate WebAuthn credentials");const r=b.S(I.YW(t.credentialId||"")),a=await this.signUp(e,r);if(a.success){if(h(`WebAuthn registration completed successfully for user: ${e}`),!a.did)try{const t=await this.ensureUserHasDID({services:[{type:"WebAuthnVerification",endpoint:`webauthn:${e}`}]});t&&(a.did=t)}catch(e){d(0)}return{...a,username:e,password:r,credentialId:t.credentialId}}return a}catch(e){return d(),{success:!1,error:e.message||"Error during WebAuthn registration"}}}async loginWithMetaMask(e){h("Login with MetaMask");try{if(h(`MetaMask login attempt for address: ${e}`),!e)throw p(m.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask login");if(!this.metamask?.isAvailable())throw p(m.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");h("Generating credentials for MetaMask login...");const t=await(this.metamask?.generateCredentials(e));if(!(t?.username&&t?.password&&t.signature&&t.message))throw p(m.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");h(`Credentials generated successfully. Username: ${t.username}`),h("Verifying MetaMask signature...");const r=M.l(t.message,t.signature);if(r.toLowerCase()!==e.toLowerCase())throw d(),p(m.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");h("MetaMask signature verified successfully."),h("Attempting login or user creation with verified credentials...");const a=await this.createUserWithGunDB(t.username,t.password);if(!a.success||!a.userPub)throw p(m.AUTHENTICATION,"LOGIN_CREATE_FAILED",a.error||"Login or user creation failed after signature verification");h(`Login/Creation successful: ${a.userPub}`);let n=null;try{h("Ensuring user has a DID..."),n=await this.ensureUserHasDID({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),n?h(`DID assigned/verified: ${n}`):g()}catch(e){f.handle(m.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user",e)}return this.eventEmitter.emit("auth:login",{userPub:a.userPub,username:t.username,method:"metamask",did:n||void 0}),{success:!0,userPub:a.userPub,username:t.username,password:t.password,did:n||void 0}}catch(e){const t=e?.type||m.AUTHENTICATION,r=e?.code||"METAMASK_LOGIN_ERROR",a=e?.message||"Unknown error during MetaMask login";return{success:!1,error:f.handle(t,r,a,e).message}}}async signUpWithMetaMask(e){h("Sign up with MetaMask");try{if(h(`MetaMask registration attempt for address: ${e}`),!e)throw p(m.VALIDATION,"ADDRESS_REQUIRED","Ethereum address required for MetaMask registration");if(!this.metamask?.isAvailable())throw p(m.ENVIRONMENT,"METAMASK_UNAVAILABLE","MetaMask is not available in the browser");h("Generating credentials for MetaMask registration...");const t=await(this.metamask?.generateCredentials(e));if(!(t?.username&&t?.password&&t.signature&&t.message))throw p(m.AUTHENTICATION,"CREDENTIAL_GENERATION_FAILED","MetaMask credentials not generated correctly or signature missing");h(`Credentials generated successfully. Username: ${t.username}`),h("Verifying MetaMask signature...");const r=M.l(t.message,t.signature);if(r.toLowerCase()!==e.toLowerCase())throw d(),p(m.SECURITY,"SIGNATURE_VERIFICATION_FAILED","MetaMask signature verification failed. Address mismatch.");h("MetaMask signature verified successfully."),h("Attempting user creation (or login if exists) with verified credentials...");const a=await this.createUserWithGunDB(t.username,t.password);if(!a.success||!a.userPub)throw p(m.AUTHENTICATION,"USER_CREATE_LOGIN_FAILED",a.error||"User creation or login failed after signature verification");h(`User creation/login successful: ${a.userPub}`);let n=null;try{h("Creating/Ensuring DID with MetaMask verification service..."),n=await this.ensureUserHasDID({services:[{type:"EcdsaSecp256k1VerificationKey2019",endpoint:`ethereum:${e}`}]}),n?h(`DID created/verified: ${n}`):g()}catch(e){f.handle(m.DID,"DID_ENSURE_FAILED","Error ensuring DID for MetaMask user during signup",e)}return this.eventEmitter.emit("auth:signup",{userPub:a.userPub,username:t.username,method:"metamask",did:n||void 0}),{success:!0,userPub:a.userPub,username:t.username,password:t.password,did:n||void 0}}catch(e){const t=e?.type||m.AUTHENTICATION,r=e?.code||"METAMASK_SIGNUP_ERROR",a=e?.message||"Unknown error during MetaMask registration";return{success:!1,error:f.handle(t,r,a,e).message}}}createUserWithGunDB(e,t){return h(`Ensuring user exists with GunDB: ${e}`),new Promise((async r=>{try{const a=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().auth(e,t,(e=>{if(e.err)r({err:e.err});else{const e=this.gundb.gun.user(),t=e.is?.pub||"";e.is&&t?r({pub:t}):r({err:"Authentication failed after apparent success."})}}))})),n=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().create(e,t,(e=>{r({err:e.err,pub:e.pub})}))}));h(`Attempting login first for ${e}...`);let s=await a();if(s.pub)return h(`Login successful for existing user. Pub: ${s.pub}`),void r({success:!0,userPub:s.pub});h(`Login failed (${s.err||"unknown reason"}), attempting user creation...`);const i=await n();if(i.err)return h(`User creation error: ${i.err}`),void r({success:!1,error:`User creation failed: ${i.err}`});h("User created successfully, attempting login again for confirmation..."),s=await a(),s.pub?(h(`Post-creation login successful! User pub: ${s.pub}`),r({success:!0,userPub:s.pub})):(d(s.err),r({success:!1,error:`User created, but subsequent login failed: ${s.err}`}))}catch(e){const t=e.message||"Unknown error during user existence check";d(0),r({success:!1,error:t})}}))}getMainWallet(){return this.walletManager?.getMainWallet()||null}async createWallet(){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.createWallet()}async loadWallets(){try{if(!this.isLoggedIn())return h("Cannot load wallets: user not authenticated"),f.handle(m.AUTHENTICATION,"AUTH_REQUIRED","User authentication required to load wallets",null),[];try{if(!this.walletManager)throw new Error("Wallet manager not initialized");return await this.walletManager.loadWallets()}catch(e){return f.handle(m.WALLET,"LOAD_WALLETS_ERROR",`Error loading wallets: ${e instanceof Error?e.message:String(e)}`,e),[]}}catch(e){return f.handle(m.UNKNOWN,"UNEXPECTED_ERROR",`Unexpected error loading wallets: ${e instanceof Error?e.message:String(e)}`,e),[]}}async signMessage(e,t){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.signMessage(e,t)}verifySignature(e,t){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.verifySignature(e,t)}async signTransaction(e,t,r){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.signTransaction(e,t,r)}async exportMnemonic(e){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.exportMnemonic(e)}async exportWalletKeys(e){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.exportWalletKeys(e)}async exportGunPair(e){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.exportGunPair(e)}async exportAllUserData(e){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.exportAllUserData(e)}async importMnemonic(e,t){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.importMnemonic(e,t)}async importWalletKeys(e,t){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.importWalletKeys(e,t)}async importGunPair(e,t){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.importGunPair(e,t)}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.importAllUserData(e,t,r)}getStandardBIP44Addresses(e,t=5){if(!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager.getStandardBIP44Addresses(e,t)}generateNewMnemonic(){try{const e=T.u.createRandom().mnemonic;if(!e||!e.phrase)throw new Error("Failed to generate mnemonic phrase");return e.phrase}catch(e){throw d(0),new Error("Failed to generate mnemonic phrase")}}setRpcUrl(e){try{return e?(this.walletManager&&this.walletManager.setRpcUrl(e),this.provider=new D.FR(e),h(`RPC URL updated to: ${e}`),!0):(h("Invalid RPC URL provided"),!1)}catch(e){return d(0),!1}}getRpcUrl(){return this.provider instanceof D.FR&&this.provider.connection?.url||null}async ensureUserHasDID(e){try{if(!this.isLoggedIn())return d(),null;let t=await(this.did?.getCurrentUserDID());if(t){if(h(`User already has DID: ${t}`),e&&Object.keys(e).length>0)try{await(this.did?.updateDIDDocument(t,{service:e.services?.map(((e,r)=>({id:`${t}#service-${r+1}`,type:e.type,serviceEndpoint:e.endpoint})))}))&&h(`Updated DID document for: ${t}`)}catch(e){d(0)}return t}h("Creating new DID for authenticated user");const r=this.gundb.gun.user().is?.pub||"",a={network:"main",controller:r,...e};return t=await(this.did?.createDID(a)),this.eventEmitter.emit("did:created",{did:t,userPub:r}),h(`Created new DID for user: ${t}`),t||null}catch(e){return d(0),null}}configureLogging(e){u(e),h("Logging reconfigured with new settings")}}let x;const K={loadWebAuthn:()=>Promise.resolve().then(r.bind(r,3439)),loadStealth:()=>Promise.resolve().then(r.bind(r,1058)),loadDID:()=>Promise.resolve().then(r.bind(r,7828))};"undefined"!=typeof window&&(window.ShogunCore=x,window.initShogunBrowser=function(e){const t={...e};return t.gundb||(t.gundb={}),e.gundb?.peers||h("WARNING: Using default GunDB peers. For production, always configure custom peers."),e.providerUrl||h("WARNING: No Ethereum provider URL specified. Using default public endpoint with rate limits."),x=new F(t),x},window.ShogunModules=K)},3439:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Webauthn:()=>a,default:()=>n});class a{constructor(){}isSupported(){return!1}validateUsername(){throw new Error("WebAuthn functionality disabled in light version")}async createAccount(){throw new Error("WebAuthn functionality disabled in light version")}async authenticateUser(){throw new Error("WebAuthn functionality disabled in light version")}async sign(){throw new Error("WebAuthn functionality disabled in light version")}}const n=a},5736:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5736,e.exports=t},7828:(e,t,r)=>{"use strict";r.r(t),r.d(t,{ShogunDID:()=>a,default:()=>n});class a{constructor(){}async createDID(){throw new Error("DID functionality disabled in light version")}async getCurrentUserDID(){throw new Error("DID functionality disabled in light version")}async resolveDID(){throw new Error("DID functionality disabled in light version")}async authenticateWithDID(){throw new Error("DID functionality disabled in light version")}async updateDIDDocument(){throw new Error("DID functionality disabled in light version")}async deactivateDID(){throw new Error("DID functionality disabled in light version")}isValidDID(){throw new Error("DID functionality disabled in light version")}}const n=a}},r={};function a(e){var n=r[e];if(void 0!==n)return n.exports;var s=r[e]={id:e,loaded:!1,exports:{}};return t[e](s,s.exports,a),s.loaded=!0,s.exports}a.m=t,e=[],a.O=(t,r,n,s)=>{if(!r){var i=1/0;for(u=0;u<e.length;u++){for(var[r,n,s]=e[u],o=!0,c=0;c<r.length;c++)(!1&s||i>=s)&&Object.keys(a.O).every((e=>a.O[e](r[c])))?r.splice(c--,1):(o=!1,s<i&&(i=s));if(o){e.splice(u--,1);var l=n();void 0!==l&&(t=l)}}return t}s=s||0;for(var u=e.length;u>0&&e[u-1][2]>s;u--)e[u]=e[u-1];e[u]=[r,n,s]},a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},a.d=(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e={792:0};a.O.j=t=>0===e[t];var t=(t,r)=>{var n,s,[i,o,c]=r,l=0;if(i.some((t=>0!==e[t]))){for(n in o)a.o(o,n)&&(a.m[n]=o[n]);if(c)var u=c(a)}for(t&&t(r);l<i.length;l++)s=i[l],a.o(e,s)&&e[s]&&e[s][0](),e[s]=0;return a.O(u)},r=this.webpackChunkShogunCore=this.webpackChunkShogunCore||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var n=a.O(void 0,[96],(()=>a(1447)));return n=(n=a.O(n)).default})()));