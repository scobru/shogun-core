!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ShogunCore=t():e.ShogunCore=t()}(this,(()=>(()=>{var e,t,r,n={409:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Webauthn:()=>n,default:()=>i});class n{constructor(){}isSupported(){return!1}validateUsername(){throw new Error("WebAuthn functionality disabled in light version")}async createAccount(){throw new Error("WebAuthn functionality disabled in light version")}async authenticateUser(){throw new Error("WebAuthn functionality disabled in light version")}async sign(){throw new Error("WebAuthn functionality disabled in light version")}}const i=n},1656:(e,t,r)=>{"use strict";var n=r(9229),i=r.n(n),a=r(8030),s=r.n(a);const o={TIMEOUT:{AUTH:6e4,GUN:5e3,WALLET:3e4},PATHS:{DERIVATION_BASE:"m/44'/60'/0'/0/",DEFAULT_INDEX:0},STORAGE_KEYS:{ENTROPY:"hedgehog-entropy-key",GUN_PAIR:"gun-current-pair",WALLET_PATHS:"walletPaths_",SESSION:"gun-current-session"},GUN_TABLES:{USERS:"users",WALLET_PATHS:"walletPathsV2",AUTHENTICATIONS:"authenticationsV2",WEBAUTHN:"webauthn",STEALTH:"stealth"},AUTH:{MIN_PASSWORD_LENGTH:8,MAX_USERNAME_LENGTH:64,MIN_USERNAME_LENGTH:3},PREFIX:"⚔️ ShogunSDK:",PEERS:[],MESSAGE_TO_SIGN:"Access With Shogun"};let c={enabled:"true"===r(5606).env.DEBUG,level:"info",prefix:"[ShogunSDK]"},l=!1;function u(e){c={...c,...e}}function h(e,...t){(new Date).toISOString()}function d(e,...t){(new Date).toISOString()}function g(e,...t){(new Date).toISOString()}function p(e,...t){if(!l)return;(new Date).toISOString()}var m;!function(e){e.AUTHENTICATION="AuthenticationError",e.AUTHORIZATION="AuthorizationError",e.VALIDATION="ValidationError",e.NETWORK="NetworkError",e.DATABASE="DatabaseError",e.WALLET="WalletError",e.DID="DIDError",e.STORAGE="StorageError",e.ENCRYPTION="EncryptionError",e.SIGNATURE="SignatureError",e.ENVIRONMENT="EnvironmentError",e.SECURITY="SecurityError",e.GUN="GunError",e.STEALTH="StealthError",e.WEBAUTHN="WebAuthnError",e.PLUGIN="PluginError",e.UNKNOWN="UnknownError",e.CONNECTOR="CONNECTOR",e.GENERAL="GENERAL"}(m||(m={}));class w{static handleError(e){d((e.type,e.code,e.message)),this.errors.push(e),this.errors.length>this.maxErrors&&(this.errors=this.errors.slice(-this.maxErrors)),this.notifyListeners(e)}static handle(e,t,r,n,i="error"){const a=n?`${r} - ${this.formatError(n)}`:r;switch(i){case"debug":h(`[${e}.${t}] (DEBUG) ${a}`);break;case"warn":h(`[${e}.${t}] (WARN) ${a}`);break;case"info":h(`[${e}.${t}] (INFO) ${a}`);break;default:h(`[${e}.${t}] (ERROR) ${a}`),n&&n instanceof Error&&h(n.stack||"No stack trace available")}const s=function(e,t,r,n){return{type:e,code:t,message:r,originalError:n,timestamp:Date.now()}}(e,t,a,n);return this.handleError(s),s}static getRecentErrors(e=10){return this.errors.slice(-Math.min(e,this.errors.length))}static addListener(e){this.listeners.push(e)}static removeListener(e){const t=this.listeners.indexOf(e);-1!==t&&this.listeners.splice(t,1)}static notifyListeners(e){for(const t of this.listeners)try{t(e)}catch(e){d()}}static formatError(e){if(!e)return"Unknown error";if(e instanceof Error)return`${e.name}: ${e.message}`;if("string"==typeof e)return e;if("object"==typeof e)try{return JSON.stringify(e)}catch(t){return`Object: ${Object.prototype.toString.call(e)}`}return String(e)}static async withRetry(e,t,r,n=3,i=1e3){let a;for(let t=1;t<=n;t++)try{return await e()}catch(e){a=e;const r=i*t;t<n&&(h(`Retrying operation after ${r}ms (attempt ${t}/${n})`),await new Promise((e=>setTimeout(e,r))))}throw this.handle(t,r,`Operation failed after ${n} attempts`,a)}}w.errors=[],w.maxErrors=100,w.listeners=[];class f{constructor(e={}){this.user=null,this.certificato=null,this.onAuthCallbacks=[],this._authenticating=!1,h("Initializing GunDB"),this.retryConfig={attempts:e.retryAttempts??3,delay:e.retryDelay??1e3};const t={peers:e.peers,localStorage:e.localStorage??!1,radisk:e.radisk??!1,multicast:e.multicast??!1,axe:e.axe??!1};if(e.authToken){h(`Auth token received (${e.authToken.substring(0,3)+"..."+(e.authToken.length>6?e.authToken.substring(e.authToken.length-3):"")})`)}else h("No auth token received");this.gun=new(i())(t),this.user=this.gun.user().recall({sessionStorage:!0});e.authToken&&(i().on("opt",(function(e){e.once||e.on("out",(function(t){var r=e.to;t.headers={token:"thisIsTheTokenForReals"},r.next(t)}))})),h("Auth token handler configured for outgoing messages")),this.subscribeToAuthEvents()}async retry(e,t){let r;for(let n=0;n<this.retryConfig.attempts;n++)try{return await e()}catch(e){if(r=e instanceof Error?e:new Error(String(e)),n<this.retryConfig.attempts-1){const e=this.retryConfig.delay*Math.pow(2,n);h(`Retry attempt ${n+1} for ${t} in ${e}ms`),await new Promise((t=>setTimeout(t,e)))}}throw r}subscribeToAuthEvents(){this.gun.on("auth",(e=>{h("Auth event received:"),e.err?w.handle(m.GUN,"AUTH_EVENT_ERROR",e.err,new Error(e.err)):this.notifyAuthListeners(e.sea?.pub||"")}))}notifyAuthListeners(e){const t=this.gun.user();this.onAuthCallbacks.forEach((e=>{e(t)}))}static withPeers(e=o.PEERS){return new f({peers:e})}onAuth(e){this.onAuthCallbacks.push(e);const t=this.gun.user();return t&&t.is&&e(t),()=>{const t=this.onAuthCallbacks.indexOf(e);-1!==t&&this.onAuthCallbacks.splice(t,1)}}getGun(){return this.gun}getUser(){return this.gun.user()}setCertificate(e){this.certificato=e;this.gun.user().get("trust").get("certificate").put(e)}getCertificate(){return this.certificato}async signUp(e,t){try{return h("Attempting user registration:"),new Promise((r=>{this.gun.user().create(e,t,(async n=>{if(n.err)d(n.err),r({success:!1,error:n.err});else{const n=await this.login(e,t);n.success?h("Registration and login completed successfully"):d(),r(n)}}))}))}catch(e){return d(0),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}login(e,t,r){return h(`Attempting login for user: ${e}`),new Promise(((n,i)=>{if(!e||!t){const e="Username and password are required";return h(e),r&&r({err:e}),void i(new Error(e))}try{this.gun.user().leave(),h("Current user reset before login attempt")}catch(e){}h(`Performing auth with Gun for user: ${e}`),this.gun.user().auth(e,t,(t=>{if(t.err)h(`Login error: ${t.err}`),r&&r({err:t.err}),i(new Error(t.err));else{h("Authentication completed successfully");try{this._savePair(),h("User auth pair saved")}catch(e){h(`Warning: Error saving auth pair: ${e}`)}r&&r(t),n({success:!0,userPub:this.gun.user().is?.pub,username:e})}}))}))}_savePair(){try{const e=this.gun.user(),t=e._&&e._.sea;t&&"undefined"!=typeof localStorage&&localStorage.setItem("pair",JSON.stringify(t))}catch(e){}}isAuthenticating(){return!0===this._authenticating}_setAuthenticating(e){this._authenticating=e}logout(){try{h("Attempting logout"),this.gun.user().leave(),h("Logout completed")}catch(e){d(0)}}isLoggedIn(){const e=this.gun.user();return!!(e&&e.is&&e.is.pub)}getCurrentUser(){const e=this.gun.user()?.is?.pub;return e?{pub:e,user:this.gun.user()}:null}async saveWithRetry(e,t,r){return this.retry((()=>new Promise(((n,i)=>{e.put(t,(e=>{e.err?i(new Error(e.err)):n(t)}),r)}))),"data save operation")}async readWithRetry(e){return this.retry((()=>new Promise((t=>{e.once((e=>t(e)))}))),"data read operation")}async saveUserData(e,t){try{if(!this.gun.user()?.is?.pub)throw new Error("User not authenticated");const r=this.certificato?{opt:{cert:this.certificato}}:void 0;return await this.saveWithRetry(this.gun.user().get(e),t,r)}catch(t){throw w.handle(m.GUN,"SAVE_USER_DATA_ERROR",`Error saving data to path ${e}`,t),t}}async getUserData(e){try{if(!this.gun.user()?.is?.pub)throw new Error("User not authenticated");const t=await this.readWithRetry(this.gun.user().get(e));return t?(h(`Data retrieved from ${e}`),t):(h(`No data found at ${e}`),null)}catch(t){throw w.handle(m.GUN,"GET_USER_DATA_ERROR",`Error retrieving data from path ${e}`,t),t}}async savePublicData(e,t,r){return new Promise(((n,i)=>{const a=this.certificato?{opt:{cert:this.certificato}}:void 0;this.gun.get(e).get(t).put(r,(a=>{a&&a.err?(d(a.err),i(new Error(a.err))):(h(`Public data saved to ${e}/${t}`),n(r))}),a)}))}async getPublicData(e,t){return new Promise((r=>{this.gun.get(e).get(t).once((n=>{n?(h(`Public data retrieved from ${e}/${t}`),r(n)):(h(`No public data found at ${e}/${t}`),r(null))}))}))}async generateKeyPair(){return i().SEA.pair()}}"undefined"!=typeof window?window.GunDB=f:void 0!==r.g&&(r.g.GunDB=f);var y,v,E=r(7007);class D{constructor(){if(this.store=new Map,"undefined"!=typeof localStorage)try{const e=localStorage.getItem("shogun_keypair");e&&this.store.set("keypair",JSON.parse(e))}catch(e){}}async getPair(){return this.getPairSync()}getPairSync(){return this.store.get("keypair")||null}async setPair(e){if(this.store.set("keypair",e),"undefined"!=typeof localStorage)try{localStorage.setItem("shogun_keypair",JSON.stringify(e))}catch(e){}}clearAll(){if(this.store.clear(),"undefined"!=typeof localStorage)try{localStorage.removeItem("shogun_keypair")}catch(e){}}getItem(e){const t=this.store.get(e);return void 0!==t?JSON.stringify(t):null}setItem(e,t){try{const r=JSON.parse(t);if(this.store.set(e,r),"undefined"!=typeof localStorage)try{localStorage.setItem(e,t)}catch(e){}}catch(r){if(this.store.set(e,t),"undefined"!=typeof localStorage)try{localStorage.setItem(e,t)}catch(e){}}}removeItem(e){if(this.store.delete(e),"undefined"!=typeof localStorage)try{localStorage.removeItem(e)}catch(e){}}}!function(e){e.Authentication="authentication",e.Wallet="wallet",e.Privacy="privacy",e.Identity="identity",e.Utility="utility"}(y||(y={})),function(e){e.WebAuthn="webauthn",e.MetaMask="metamask",e.Stealth="stealth",e.DID="did",e.WalletManager="wallet"}(v||(v={}));var S=r(8051),b=r(7776),I=r(5330),A=r(5010);class P{constructor(e){this.gun=e,this.user=e.user().recall({sessionStorage:!0})}getUser(){return this.user}getUserPub(){return this.user.is?.pub}observe(e){return new I.c((t=>{const r="string"==typeof e?this.gun.get(e):e,n=r.on(((e,r)=>{if(null!=e)if("object"==typeof e&&null!==e){const r=this.removeGunMeta(e);t.next(r)}else t.next(e);else t.next(null)}));return()=>{n&&"function"==typeof n&&n(),r.off()}})).pipe((0,A.F)(((e,t)=>JSON.stringify(e)===JSON.stringify(t))))}match(e,t){return new I.c((r=>{const n="string"==typeof e?this.gun.get(e):e,i={},a=n.map().on(((e,n)=>{if("_"===n||!e)return;if(t&&!t(e))return void(i[n]&&(delete i[n],r.next(Object.values(i))));const a="object"==typeof e?this.removeGunMeta(e):e;i[n]=a,r.next(Object.values(i))}));return()=>{a&&"function"==typeof a&&a(),n.off()}}))}put(e,t){const r="string"==typeof e?this.gun.get(e):e;return new I.c((e=>{r.put(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}set(e,t){const r="string"==typeof e?this.gun.get(e):e;return new I.c((e=>{r.set(t,(r=>{r.err?e.error(new Error(r.err)):(e.next(t),e.complete())}))}))}once(e){const t="string"==typeof e?this.gun.get(e):e;return new I.c((e=>{t.once((t=>{if(null==t)return e.next(null),void e.complete();const r="object"==typeof t?this.removeGunMeta(t):t;e.next(r),e.complete()}))}))}compute(e,t){const r=e.map((e=>"string"==typeof e?this.observe(e):e));return new I.c((n=>{let i=new Array(e.length).fill(void 0),a=new Array(e.length).fill(!1);const s=r.map(((e,r)=>e.subscribe({next:e=>{if(i[r]=e,i.every((e=>void 0!==e)))try{const e=t(...i);n.next(e)}catch(e){n.error(e)}},error:e=>n.error(e),complete:()=>{a[r]=!0,a.every((e=>e))&&n.complete()}})));return()=>{s.forEach((e=>e.unsubscribe()))}}))}userPut(e,t){return new I.c((r=>{this.gun.user().get(e).put(t,(e=>{e.err?r.error(new Error(e.err)):(r.next(t),r.complete())}))}))}userGet(e){return this.observe(this.gun.user().get(e))}observeUser(e){return this.observe(this.gun.user().get(e))}removeGunMeta(e){if(!e||"object"!=typeof e)return e;const t=Array.isArray(e)?[]:{};return Object.keys(e).forEach((r=>{if("_"===r||"#"===r)return;const n=e[r];t[r]=n&&"object"==typeof n?this.removeGunMeta(n):n})),t}}var T=r(409);class M{constructor(){this.core=null}initialize(e){this.core=e}destroy(){this.core=null}assertInitialized(){if(!this.core)throw new Error(`Plugin ${this.name} not initialized`)}}var U=r(6525),R=r(1442),C=r(31),N=r(2011),W=r(7303),_=r(4532),O=r(7649);class k extends E.EventEmitter{constructor(e={}){super(),this.MESSAGE_TO_SIGN="I Love Shogun!",this.DEFAULT_CONFIG={cacheDuration:18e5,maxRetries:3,retryDelay:1e3,timeout:6e4},this.signatureCache=new Map,this.provider=null,this.customProvider=null,this.customWallet=null,this.config={...this.DEFAULT_CONFIG,...e},this.AUTH_DATA_TABLE=o.GUN_TABLES.AUTHENTICATIONS||"Authentications",this.setupProvider(),this.setupEventListeners()}async setupProvider(){try{"undefined"!=typeof window&&window.ethereum?(this.provider=new U.k(window.ethereum),p()):g()}catch(e){d(0)}}setupEventListeners(){this.provider&&(this.provider.on("network",((e,t)=>{this.emit("chainChanged",e)})),window.ethereum?.on&&window.ethereum.on("accountsChanged",(e=>{this.emit("accountsChanged",e)})))}cleanup(){this.provider&&this.provider.removeAllListeners(),this.removeAllListeners()}getCachedSignature(e){const t=this.signatureCache.get(e);if(!t)return null;return Date.now()-t.timestamp>this.config.cacheDuration?(this.signatureCache.delete(e),null):t.signature}cacheSignature(e,t){this.signatureCache.set(e,{signature:t,timestamp:Date.now(),address:e})}validateAddress(e){if(!e)throw new Error("Address not provided");try{const t=String(e).trim().toLowerCase();if(!R.PW(t))throw new Error("Invalid address format");return C.b(t)}catch(e){throw w.handle(m.VALIDATION,"INVALID_ADDRESS","Invalid Ethereum address provided",e),e}}async connectMetaMask(){try{if(p(),!this.provider&&(p(),await this.setupProvider(),!this.provider))throw new Error("MetaMask is not available. Please install MetaMask extension.");p();let e=[];if(window.ethereum)try{e=await window.ethereum.request({method:"eth_requestAccounts"}),p(e.length)}catch(e){throw d(0),new Error("User denied account access")}e&&0!==e.length||p();for(let e=1;e<=this.config.maxRetries;e++)try{p();const e=await this.provider.getSigner(),t=await e.getAddress();if(!t)throw d(),new Error("No accounts found in MetaMask");p();const r=`mm_${t.toLowerCase()}`;return this.emit("connected",{address:t}),p(),{success:!0,address:t,username:r}}catch(t){if(d(0),e===this.config.maxRetries)throw t;p(this.config.retryDelay),await new Promise((e=>setTimeout(e,this.config.retryDelay)))}throw new Error("Failed to connect after retries")}catch(e){return d(0),w.handle(m.NETWORK,"METAMASK_CONNECTION_ERROR",e.message||"Unknown error while connecting to MetaMask",e),{success:!1,error:e.message}}}async generateCredentials(e){p(0);try{const t=this.validateAddress(e),r=this.getCachedSignature(t);if(r)return p(0),this.generateCredentialsFromSignature(t,r);try{const e=await this.requestSignatureWithTimeout(t,this.MESSAGE_TO_SIGN,this.config.timeout);return this.cacheSignature(t,e),this.generateCredentialsFromSignature(t,e)}catch(e){return g(),this.generateFallbackCredentials(t)}}catch(e){throw w.handle(m.AUTHENTICATION,"CREDENTIALS_GENERATION_ERROR",e.message||"Error generating MetaMask credentials",e),e}}generateCredentialsFromSignature(e,t){return{username:`mm_${e.toLowerCase()}`,password:N.S(W.YW(`${t}:${e.toLowerCase()}`)),message:this.MESSAGE_TO_SIGN,signature:t}}generateFallbackCredentials(e){g(0);const t=`mm_${e.toLowerCase()}`,r=`SHOGUN_FALLBACK:${e.toLowerCase()}`;return{username:t,password:N.S(W.YW(r)),message:r,signature:N.S(W.YW(r))}}static isMetaMaskAvailable(){const e=window.ethereum;return"undefined"!=typeof window&&void 0!==e&&!0===e?.isMetaMask}async requestSignatureWithTimeout(e,t,r=3e4){return new Promise((async(n,i)=>{let a=setTimeout((()=>{a=null,i(new Error("Timeout requesting signature"))}),r);try{if(!this.provider&&(await this.setupProvider(),!this.provider))throw new Error("Provider not initialized");let r,s;try{r=await this.provider.getSigner()}catch(e){throw d(0),new Error(`Failed to get signer: ${e.message}`)}try{s=await r.getAddress()}catch(e){throw d(0),new Error(`Failed to get signer address: ${e.message}`)}if(s.toLowerCase()!==e.toLowerCase())throw new Error(`Signer address (${s}) does not match expected address (${e})`);p();const o=e=>{a&&(clearTimeout(a),a=null),i(e)};window.ethereum?.on&&window.ethereum.on("accountsChanged",o);try{const e=await r.signMessage(t);p(),a&&(clearTimeout(a),a=null),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",o),n(e)}catch(e){throw d(0),window.ethereum?.removeListener&&window.ethereum.removeListener("accountsChanged",o),e}}catch(e){d(0),a&&(clearTimeout(a),a=null),i(e)}}))}isAvailable(){return"undefined"!=typeof window&&!!window.ethereum}setCustomProvider(e,t){if(!e||"string"!=typeof e)throw new Error("Invalid RPC URL");if(!t||"string"!=typeof t)throw new Error("Invalid private key");try{this.customProvider=new S.FR(e),this.customWallet=new _.u(t,this.customProvider),p()}catch(e){throw new Error(`Error configuring provider: ${e.message||"Unknown error"}`)}}async getSigner(){try{if(this.customWallet)return this.customWallet;if(this.provider||await this.setupProvider(),!this.provider)throw new Error("Provider not initialized");return await this.provider.getSigner()}catch(e){throw new Error(`Unable to get Ethereum signer: ${e.message||"Unknown error"}`)}}async generatePassword(e){if(!e)throw new Error("Invalid signature");return N.S(W.YW(e)).slice(2,66)}async verifySignature(e,t){if(!e||!t)throw new Error("Invalid message or signature");try{return O.l(e,t)}catch(e){throw new Error("Invalid message or signature")}}async getEthereumSigner(){if(!k.isMetaMaskAvailable())throw new Error("MetaMask not found. Please install MetaMask to continue.");try{const e=window.ethereum;await e.request({method:"eth_requestAccounts"});return new U.k(e).getSigner()}catch(e){throw new Error(`Error accessing MetaMask: ${e.message||"Unknown error"}`)}}}"undefined"!=typeof window?window.MetaMask=k:void 0!==r.g&&(r.g.MetaMask=k);class $ extends M{constructor(){super(...arguments),this.name="metamask",this.version="1.0.0",this.description="Provides MetaMask wallet connection and authentication for ShogunCore",this.metamask=null}initialize(e){super.initialize(e),this.metamask=new k,h("MetaMask plugin initialized")}destroy(){this.metamask&&this.metamask.cleanup(),this.metamask=null,super.destroy(),h("MetaMask plugin destroyed")}assertMetaMask(){if(this.assertInitialized(),!this.metamask)throw new Error("MetaMask module not initialized");return this.metamask}isAvailable(){return this.assertMetaMask().isAvailable()}async connectMetaMask(){return this.assertMetaMask().connectMetaMask()}async generateCredentials(e){return this.assertMetaMask().generateCredentials(e)}cleanup(){this.assertMetaMask().cleanup()}setCustomProvider(e,t){this.assertMetaMask().setCustomProvider(e,t)}async getSigner(){return this.assertMetaMask().getSigner()}async generatePassword(e){return this.assertMetaMask().generatePassword(e)}async verifySignature(e,t){return this.assertMetaMask().verifySignature(e,t)}}var L=r(2256),x=r(2724);class F extends E.EventEmitter{constructor(e,t,r){super(),this.methodName="shogun",this.didCache=new Map,this.DEFAULT_CACHE_DURATION=18e5,this.DEFAULT_TIMEOUT=1e4,this.DEFAULT_MAX_RETRIES=3,this.DEFAULT_RETRY_DELAY=1e3,this.registryConfig={address:"0x1234...",network:"mainnet",timeout:this.DEFAULT_TIMEOUT,maxRetries:this.DEFAULT_MAX_RETRIES,retryDelay:this.DEFAULT_RETRY_DELAY},this.core=e,this.registryConfig={...this.registryConfig,...t},this.options=r||{useSecureRandomPassword:!0},h("ShogunDID initialized")}async createDID(e={}){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to create a DID");const t=this.getUserPublicKey();if(!t)throw new Error("Cannot retrieve user's public key");let r=N.S(W.YW(t)).slice(2,42);e.network&&(r=`${e.network}:${r}`);const n=`did:${this.methodName}:${r}`;return await this.storeDID(n,e),this.emit("didCreated",{did:n}),h(`Created DID: ${n}`),n}catch(e){throw d(0),w.handle(m.DID,"CREATE_DID_ERROR",e instanceof Error?e.message:"Error creating DID",e),e}}async storeDID(e,t){try{if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=t.document||this.createDidDocument(e,t);return new Promise(((t,n)=>{this.core.gun.get("dids").get(e).put({document:JSON.stringify(r),created:(new Date).toISOString(),updated:(new Date).toISOString(),deactivated:!1},(r=>{r.err?n(new Error(`Failed to store DID: ${r.err}`)):this.core.gun.user().get("did").put(e,(e=>{e.err&&d(e.err),t()}))})),setTimeout((()=>n(new Error("Timeout storing DID"))),1e4)}))}catch(e){throw d(0),e}}createDidDocument(e,t){(new Date).toISOString();const r=t.controller||this.getUserPublicKey()||e,n={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:r,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${this.getUserPublicKey()||N.S(W.YW(e))}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(n.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),n}getUserPublicKey(){try{if(!this.core.isLoggedIn())return null;const e=this.core.gun.user();return e&&e._&&e._.sea&&e._.sea.pub||null}catch(e){return d(0),null}}async resolveDID(e,t={}){try{const r=t.cacheDuration||this.DEFAULT_CACHE_DURATION,n=t.timeout||this.DEFAULT_TIMEOUT,i=this.didCache.get(e);if(i&&Date.now()-i.timestamp<r)return{didResolutionMetadata:{contentType:"application/did+json"},didDocument:this.getDocumentFromCache(i),didDocumentMetadata:{}};if(!this.isValidDID(e))return this.createErrorResolution("invalidDid","Invalid DID format");const[a,s,o]=e.split(":");return s!==this.methodName?this.createErrorResolution("unsupportedDidMethod",`Unsupported DID method: ${s}`):new Promise(((t,r)=>{const i=setTimeout((()=>{t(this.createErrorResolution("timeout","DID resolution timeout"))}),n);this.core.gun.get("dids").get(e).once((r=>{if(clearTimeout(i),r)try{const n=this.parseOrCreateDIDDocument(e,r);this.didCache.set(e,{data:n,document:n,timestamp:Date.now(),network:o.split(":")[0]||"main"}),t({didResolutionMetadata:{contentType:"application/did+json"},didDocument:n,didDocumentMetadata:{created:r.created,updated:r.updated,deactivated:r.deactivated||!1}})}catch(e){t(this.createErrorResolution("invalidDidDocument","Error parsing DID Document"))}else t(this.createErrorResolution("notFound","DID Document not found"))}))}))}catch(e){return d(0),this.createErrorResolution("internalError",e instanceof Error?e.message:"Unknown error")}}async registerDIDOnChain(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to register DID on chain");let r=t||this.getWallet();if(!r)throw new Error("No signer provided and main wallet not available");const n=["function registerDID(string did, string controller) public returns (bool)"],i=new x.NZ(this.registryConfig.address,n,r);for(let t=1;t<=this.registryConfig.maxRetries;t++)try{const t=await i.registerDID(e,this.getUserPublicKey()),r=await t.wait();return this.emit("didRegistered",{did:e,txHash:r.hash}),h(`DID registered on blockchain: ${e}, tx: ${r.hash}`),{success:!0,txHash:r.hash}}catch(e){if(t===this.registryConfig.maxRetries)throw e;await new Promise((e=>setTimeout(e,this.registryConfig.retryDelay)))}throw new Error("Failed to register DID after retries")}catch(e){return d(0),{success:!1,error:e instanceof Error?e.message:"Unknown error"}}}async getCurrentUserDID(){try{if(!this.core.isLoggedIn())return null;return this.getUserPublicKey()?new Promise((e=>{this.core.gun.user().get("did").once((t=>{e(t&&"string"==typeof t?t:null)})),setTimeout((()=>e(null)),5e3)})):null}catch(e){return d(0),null}}async authenticateWithDID(e,t){try{if(h(`Authenticating with DID: ${e}`),!this.isValidDID(e))return{success:!1,error:"Invalid DID format"};const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)return{success:!1,error:`DID resolution failed: ${r.didResolutionMetadata.error}`};const n=this.extractAuthenticationMethod(r.didDocument);return n?n.type.includes("EcdsaSecp256k1")?this.authenticateWithEthereum(n,t):n.type.includes("WebAuthn")?this.authenticateWithWebAuthn(n,t):this.authenticateWithGunDB(n.controller.split(":").pop()||"",t):{success:!1,error:"No valid authentication method found in DID Document"}}catch(e){return d(0),{success:!1,error:e instanceof Error?e.message:"Unknown error during authentication"}}}async updateDIDDocument(e,t){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to update a DID document");if(!this.isValidDID(e))throw new Error("Invalid DID format");const r=await this.resolveDID(e);if(r.didResolutionMetadata.error||!r.didDocument)throw new Error(`Cannot update DID document: ${r.didResolutionMetadata.error||"Document not found"}`);const n=r.didDocument,i={...n,...t};if(t.service&&n.service){const e=[...n.service];for(const r of t.service){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}i.service=e}if(t.verificationMethod&&n.verificationMethod){const e=[...n.verificationMethod];for(const r of t.verificationMethod){const t=e.findIndex((e=>e.id===r.id));t>=0?e[t]=r:e.push(r)}i.verificationMethod=e}await this.storeDID(e,{document:i});const[a,s,o]=e.split(":");return this.didCache.set(e,{data:i,document:i,timestamp:Date.now(),network:o.split(":")[0]||"main"}),this.emit("didUpdated",{did:e,document:i}),h(`Updated DID Document: ${e}`),!0}catch(e){return d(0),w.handle(m.DID,"UPDATE_DID_ERROR",e instanceof Error?e.message:"Error updating DID",e),!1}}async deactivateDID(e){try{if(!this.core.isLoggedIn())throw new Error("User must be logged in to deactivate a DID");const t=await this.getCurrentUserDID();if(e!==t)throw new Error("Cannot deactivate a DID you don't control");return new Promise((t=>{this.core.gun.get("dids").get(e).put({deactivated:!0,updated:(new Date).toISOString()},(r=>{r.err?(d(r.err),t(!1)):(h(`Successfully deactivated DID: ${e}`),t(!0))})),setTimeout((()=>t(!1)),1e4)}))}catch(e){return d(0),!1}}isValidDID(e){return/^did:[a-z0-9]+:[a-zA-Z0-9.:%]+$/.test(e)}generateDIDDocument(e,t={}){const r=this.getUserPublicKey(),n={"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:e,controller:t.controller||e,verificationMethod:[{id:`${e}#keys-1`,type:"Ed25519VerificationKey2020",controller:e,publicKeyMultibase:`z${r}`}],authentication:[`${e}#keys-1`],assertionMethod:[`${e}#keys-1`]};return t.services&&t.services.length>0&&(n.service=t.services.map(((t,r)=>({id:`${e}#service-${r+1}`,type:t.type,serviceEndpoint:t.endpoint})))),n}createErrorResolution(e,t){return{didResolutionMetadata:{error:e,contentType:"application/did+json"},didDocument:null,didDocumentMetadata:{}}}parseOrCreateDIDDocument(e,t){if(t.document)try{return JSON.parse(t.document)}catch(e){d(0)}return{"@context":"https://www.w3.org/ns/did/v1",id:e,authentication:[]}}extractAuthenticationMethod(e){const t=e.authentication||[];for(const r of t){if("string"!=typeof r)return r;{const t=r,n=e.verificationMethod?.find((e=>e.id===t));if(n)return{id:n.id,type:n.type,controller:n.controller}}}return null}getWallet(){try{if("ShogunCore"===this.core.constructor.name){if(!this.core.getPlugin)return null;const e=this.core.getPlugin("ShogunCore"===this.core.constructor.name?"wallet":"walletManager");if(e&&"object"==typeof e&&"getMainWallet"in e)return e.getMainWallet()}else if("getMainWallet"in this.core)return this.core.getMainWallet();return null}catch(e){return null}}async authenticateWithEthereum(e,t){const r=e.id.split("#")[0].split(":").pop()||"";if("loginWithMetaMask"in this.core)return this.core.loginWithMetaMask(r);if(!this.core.getAuthenticationMethod)return{success:!1,error:"Authentication method provider not available"};const n=this.core.getAuthenticationMethod("metamask");return n&&"object"==typeof n&&"login"in n?n.login(r):{success:!1,error:"MetaMask authentication not available"}}async authenticateWithWebAuthn(e,t){const r=e.controller.split(":").pop()||"";if("loginWithWebAuthn"in this.core)return this.core.loginWithWebAuthn(r);if(!this.core.getAuthenticationMethod)return{success:!1,error:"Authentication method provider not available"};const n=this.core.getAuthenticationMethod("webauthn");return n&&"object"==typeof n&&"login"in n?n.login(r):{success:!1,error:"WebAuthn authentication not available"}}async authenticateWithGunDB(e,t){try{h("Authenticating with GunDB using password method");let r=t||"";this.options&&this.options.useSecureRandomPassword&&!r&&(r=function(e=32){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>e.toString(16).padStart(2,"0"))).join("")}());const n=await async function(e,t){const r=(new TextEncoder).encode(`${e}:${t}`),n=await crypto.subtle.digest("SHA-256",r);return Array.from(new Uint8Array(n)).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e,r);if(!this.core.getAuthenticationMethod)throw new Error("Authentication method provider not available");const i=this.core.getAuthenticationMethod("password");if(!i)throw new Error("Password authentication method not available");return await i.authenticate(e,n)}catch(e){throw h("Error authenticating with GunDB:"),e}}async verifyDIDOnChain(e){try{const t=["function isDIDRegistered(string did) public view returns (bool)","function getDIDController(string did) public view returns (string)"],r="0x1234...",n=this.getWallet(),i=n?.provider||this.core.provider;if(!i)throw new Error("Provider non disponibile per verificare il DID on-chain");const a=new x.NZ(r,t,i);if(!await a.isDIDRegistered(e))return{isRegistered:!1};return{isRegistered:!0,controller:await a.getDIDController(e)}}catch(e){return d(0),{isRegistered:!1,error:e instanceof Error?e.message:"Unknown error"}}}clearCache(){this.didCache.clear(),this.emit("cacheCleared")}removeFromCache(e){this.didCache.delete(e),this.emit("didRemovedFromCache",{did:e})}getDocumentFromCache(e){return e.data?e.data:e.document?e.document:null}}class G extends M{constructor(){super(...arguments),this.name="did",this.version="1.0.0",this.description="Provides Decentralized Identifiers (DID) functionality for ShogunCore",this.did=null}initialize(e){super.initialize(e),this.did=new F(e),h("DID plugin initialized")}destroy(){this.did=null,super.destroy(),h("DID plugin destroyed")}assertDID(){if(this.assertInitialized(),!this.did)throw new Error("DID module not initialized");return this.did}async getCurrentUserDID(){return this.assertDID().getCurrentUserDID()}async resolveDID(e){return this.assertDID().resolveDID(e)}async authenticateWithDID(e,t){return this.assertDID().authenticateWithDID(e,t)}async createDID(e){return this.assertDID().createDID(e)}async updateDIDDocument(e,t){return this.assertDID().updateDIDDocument(e,t)}async deactivateDID(e){return this.assertDID().deactivateDID(e)}async registerDIDOnChain(e,t){return this.assertDID().registerDIDOnChain(e,t)}async ensureUserHasDID(e){try{const t=this.core;if(!t)throw new Error("Core not available");if(!t.isLoggedIn())return d(),null;let r=await this.getCurrentUserDID();if(r){if(h(`User already has DID: ${r}`),e&&Object.keys(e).length>0)try{await this.updateDIDDocument(r,{service:e.services?.map(((e,t)=>({id:`${r}#service-${t+1}`,type:e.type,serviceEndpoint:e.endpoint})))})&&h(`Updated DID document for: ${r}`)}catch(e){d(0)}return r}h("Creating new DID for authenticated user");const n=t.gundb.gun.user().is?.pub||"",i={network:"main",controller:n,...e};return r=await this.createDID(i),t.emit("did:created",{did:r,userPub:n}),h(`Created new DID for user: ${r}`),r||null}catch(e){return w.handle(m.DID,"ENSURE_DID_FAILED",`Error ensuring user has DID: ${e instanceof Error?e.message:String(e)}`,e),null}}}var K,H=r(4050),B=r(7514),j=r(7761),J=r(9770);!function(e){e.WALLET_CREATED="walletCreated",e.WALLET_IMPORTED="walletImported",e.BALANCE_UPDATED="balanceUpdated",e.TRANSACTION_SENT="transactionSent",e.TRANSACTION_CONFIRMED="transactionConfirmed",e.ERROR="error"}(K||(K={}));class z extends E.EventEmitter{constructor(e,t,r,n){super(),this.walletPaths={},this.mainWallet=null,this.balanceCache=new Map,this.pendingTransactions=new Map,this.gundb=e,this.gun=t,this.storage=r,this.config={balanceCacheTTL:3e4,rpcUrl:"",defaultGasLimit:21e3,maxRetries:3,retryDelay:1e3,...n},this.initializeWalletPaths(),this.setupTransactionMonitoring()}setupTransactionMonitoring(){setInterval((()=>{null!==this.getProvider()&&this.checkPendingTransactions()}),15e3)}async checkPendingTransactions(){const e=this.getProvider();for(const[t,r]of this.pendingTransactions)try{const n=await e.getTransactionReceipt(t);n&&(1===n.status?this.emit(K.TRANSACTION_CONFIRMED,{type:K.TRANSACTION_CONFIRMED,data:{txHash:t,receipt:n},timestamp:Date.now()}):this.emit(K.ERROR,{type:K.ERROR,data:{txHash:t,error:"Transaction failed"},timestamp:Date.now()}),this.pendingTransactions.delete(t),this.invalidateBalanceCache(r.from),r.to&&this.invalidateBalanceCache(r.to))}catch(e){d(0)}}setRpcUrl(e){this.config.rpcUrl=e,h(`RPC Provider configured: ${e}`)}getProvider(){if(!this.config.rpcUrl)throw new Error("RPC URL not configured");return new S.FR(this.config.rpcUrl)}async initializeWalletPaths(){try{this.walletPaths={},await this.loadWalletPathsFromGun(),await this.loadWalletPathsFromLocalStorage();const e=Object.keys(this.walletPaths).length;h(0===e?"No wallet paths found, new wallets will be created when needed":`Initialized ${e} wallet paths`)}catch(e){throw new Error(`Failed to initialize wallet paths: ${e instanceof Error?e.message:String(e)}`)}}async loadWalletPathsFromGun(){const e=this.gun.user();return e?.is?(h(`Loading wallet paths from GUN for user: ${e.is.alias}`),new Promise((t=>{e.get("wallet_paths").once((e=>{if(!e)return h("No wallet paths found in GUN"),void t();h(`Found wallet paths in GUN: ${Object.keys(e).length-1} wallets`),Object.entries(e).forEach((([e,t])=>{if("_"!==e&&t){const r=t;r?.path&&(this.walletPaths[e]={path:r.path,created:r.created||Date.now()},h(`Loaded path for wallet: ${e} -> ${r.path}`))}})),t()}))}))):(h("User not authenticated on Gun, cannot load wallet paths from Gun"),Promise.resolve())}async loadWalletPathsFromLocalStorage(){const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=this.storage.getItem(e);if(t)try{h("Found wallet paths in localStorage");const e=JSON.parse(t);Object.entries(e).forEach((([e,t])=>{this.walletPaths[e]||(this.walletPaths[e]=t,h(`Loaded path from localStorage for wallet: ${e}`))}))}catch(e){}}getStorageUserIdentifier(){const e=this.gun.user(),t=e?.is?.pub;return t?t.substring(0,12):"guest"}saveWalletPathsToLocalStorage(){try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`,t=JSON.stringify(this.walletPaths);this.storage.setItem(e,t),h(`Saved ${Object.keys(this.walletPaths).length} wallet paths to localStorage`)}catch(e){}}derivePrivateKeyFromMnemonic(e,t){try{h(`Deriving wallet from path: ${t}`);const r=H.QX.fromMnemonic(B.v.fromPhrase(e),t);if(!r||!r.privateKey)throw new Error(`Unable to derive wallet for path ${t}`);return r}catch(e){throw new Error(`Unable to derive wallet for path ${t}`)}}generateNewMnemonic(){return B.v.fromEntropy(j.p(16)).phrase}getStandardBIP44Addresses(e,t=5){try{h("Standard BIP-44 derivation from mnemonic");const r=[];for(let n=0;n<t;n++){const t=`m/44'/60'/0'/0/${n}`,i=H.QX.fromMnemonic(B.v.fromPhrase(e),t);r.push(i.address),h(`Address ${n}: ${i.address} (${t})`)}return r}catch(e){return h(`Error calculating BIP-44 addresses: ${e}`),[]}}generatePrivateKeyFromString(e){try{const t=(new TextEncoder).encode(e),r=e=>{let t=3735928559,r=1103547991;for(let n=0;n<e.length;n++)t=Math.imul(t^e[n],2654435761),r=Math.imul(r^e[n],1597334677);t=Math.imul(t^t>>>16,2246822507),t=Math.imul(t^t>>>13,3266489909),r=Math.imul(r^r>>>16,2246822507),r=Math.imul(r^r>>>13,3266489909);const n=new Uint8Array(32);for(let e=0;e<4;e++)n[e]=t>>8*e&255;for(let e=0;e<4;e++)n[e+4]=r>>8*e&255;for(let e=8;e<32;e++)n[e]=255&(n[e%8]^n[(e-1)%8]);return n},n=r(t);return"0x"+Array.from(n).map((e=>e.toString(16).padStart(2,"0"))).join("")}catch(e){return"0x"+Array.from({length:32}).map((()=>Math.floor(256*Math.random()).toString(16).padStart(2,"0"))).join("")}}getMainWallet(){try{if(!this.mainWallet){const e=this.gun.user();if(!e||!e.is)return h("getMainWallet: User not authenticated"),null;if(!(e._&&e._.sea&&e._.sea.priv&&e._.sea.pub)){if(h("getMainWallet: Insufficient user data",JSON.stringify({hasUserData:!!e._,hasSea:!(!e._||!e._.sea),hasPriv:!!(e._&&e._.sea&&e._.sea.priv),hasPub:!!(e._&&e._.sea&&e._.sea.pub)})),e.is.alias&&e.is.alias.startsWith("0x")){h("getMainWallet: MetaMask user detected, using alternative approach");const t=`metamask-${e.is.alias}-${Date.now()}`,r=this.generatePrivateKeyFromString(t);return this.mainWallet=new _.u(r),this.mainWallet}return null}const t=e._.sea.priv,r=e._.sea.pub,n=`${t}|${r}|${e.is.alias}`,i=this.generatePrivateKeyFromString(n);this.mainWallet=new _.u(i)}return this.mainWallet}catch(e){return null}}async encryptSensitiveData(e){try{const t=this.gun.user();if(t&&t._&&t._.sea){const r=await s().encrypt(e,t._.sea);return JSON.stringify(r)}{const t=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`,r=await s().encrypt(e,t);return JSON.stringify(r)}}catch(t){return h("WARNING: Sensitive data saved without encryption"),`unencrypted:${e}`}}async decryptSensitiveData(e){try{if(e.startsWith("unencrypted:"))return e.substring(12);const t=JSON.parse(e),r=this.gun.user();if(r&&r._&&r._.sea){return await s().decrypt(t,r._.sea)}{const e=`shogun-encrypt-${this.getStorageUserIdentifier()}-key`;return await s().decrypt(t,e)}}catch(e){return null}}async getUserMasterMnemonic(){try{const e=this.gun.user();if(e&&e.is){const t=await new Promise((t=>{e.get("master_mnemonic").once((e=>{t(e||null)}))}));if(t)return h("Mnemonic retrieved from GunDB"),h("gunMnemonic: "),t}const t=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,r=this.storage.getItem(t);if(!r)return h("No mnemonic found in either GunDB or localStorage"),null;const n=await this.decryptSensitiveData(r);return h("Mnemonic retrieved from localStorage"),n&&e&&e.is&&(await e.get("master_mnemonic").put(n),h("Mnemonic from localStorage synced to GunDB")),n}catch(e){return null}}async saveUserMasterMnemonic(e){try{const t=this.gun.user();t&&t.is&&(await t.get("master_mnemonic").put(e),h("Mnemonic saved to GunDB"));const r=`shogun_master_mnemonic_${this.getStorageUserIdentifier()}`,n=await this.encryptSensitiveData(e);this.storage.setItem(r,n),h("Encrypted mnemonic also saved to localStorage as backup")}catch(e){throw e}}async createWallet(){try{const e=this.gun.user();if(!e.is)throw new Error("User is not authenticated");const t=Object.values(this.walletPaths).length,r=`m/44'/60'/0'/0/${t}`;let n,i=await this.getUserMasterMnemonic();if(!i)try{i=this.generateNewMnemonic(),await this.saveUserMasterMnemonic(i),h(`Generated new mnemonic: ${i}`)}catch(e){throw new Error(`Failed to generate or save mnemonic: ${e instanceof Error?e.message:String(e)}`)}h("*** masterMnemonic: ");try{n=this.derivePrivateKeyFromMnemonic(i,r),h(`Derived wallet for path ${r} with address ${n.address}`)}catch(e){throw new Error(`Failed to derive wallet: ${e instanceof Error?e.message:String(e)}`)}const a=Date.now();this.walletPaths[n.address]={path:r,created:a};try{await e.get("wallet_paths").get(n.address).put({path:r,created:a}),this.saveWalletPathsToLocalStorage()}catch(e){h("Wallet created but path might not be persisted properly")}return{wallet:n,path:r,address:n.address,getAddressString:()=>n.address}}catch(e){throw new Error(`Failed to create wallet: ${e instanceof Error?e.message:String(e)}`)}}async loadWallets(){try{if(!this.gun.user())throw new Error("Gun user not available");try{await this.initializeWalletPaths()}catch(e){h("Will attempt to continue with any available wallet data")}let e=await this.getUserMasterMnemonic();if(!e){return[await this.createWallet()]}h(`masterMnemonic found: ${e}`);const t=[];for(const[r,n]of Object.entries(this.walletPaths))try{const i=this.derivePrivateKeyFromMnemonic(e,n.path||`m/44'/60'/0'/0/${r.substring(0,6)}`);h(`Derived wallet for path ${n.path||"fallback"} with address ${i.address}`),i.address.toLowerCase(),r.toLowerCase(),t.push({wallet:i,path:n.path||`m/44'/60'/0'/0/${i.address.substring(0,8)}`,address:i.address,getAddressString:()=>i.address})}catch(e){}return t.length>0&&(this.mainWallet=t[0].wallet),t}catch(e){throw new Error(`Failed to load wallets: ${e instanceof Error?e.message:String(e)}`)}}async getBalance(e){try{const t=e.address,r=Date.now(),n=this.balanceCache.get(t);if(n&&r-n.timestamp<this.config.balanceCacheTTL)return n.balance;const i=this.getProvider(),a=await i.getBalance(t),s=J.ck(a);return this.balanceCache.set(t,{balance:s,timestamp:r}),this.emit(K.BALANCE_UPDATED,{type:K.BALANCE_UPDATED,data:{address:t,balance:s},timestamp:r}),s}catch(e){return d(0),"0.0"}}invalidateBalanceCache(e){this.balanceCache.delete(e),h(`Balance cache invalidated for ${e}`)}async getNonce(e){const t=this.getProvider();return await t.getTransactionCount(e.address)}async sendTransaction(e,t,r,n={}){try{const i=this.getProvider();e=e.connect(i);const a=await i.getFeeData(),s={to:t,value:J.g5(r),gasLimit:n.gasLimit||this.config.defaultGasLimit,nonce:n.nonce||await i.getTransactionCount(e.address),maxFeePerGas:n.maxFeePerGas?J.XS(n.maxFeePerGas,"gwei"):a.maxFeePerGas,maxPriorityFeePerGas:n.maxPriorityFeePerGas?J.XS(n.maxPriorityFeePerGas,"gwei"):a.maxPriorityFeePerGas};for(let t=1;t<=(this.config.maxRetries||3);t++)try{const t=await e.sendTransaction(s);return this.pendingTransactions.set(t.hash,t),this.emit(K.TRANSACTION_SENT,{type:K.TRANSACTION_SENT,data:{txHash:t.hash,tx:s},timestamp:Date.now()}),t.hash}catch(r){if(t===this.config.maxRetries)throw r;await new Promise((e=>setTimeout(e,this.config.retryDelay))),s.nonce=await i.getTransactionCount(e.address);const n=await i.getFeeData();s.maxFeePerGas=n.maxFeePerGas,s.maxPriorityFeePerGas=n.maxPriorityFeePerGas}throw new Error("Transaction failed after all retry attempts")}catch(t){throw d(0),this.emit(K.ERROR,{type:K.ERROR,data:{error:t,wallet:e.address},timestamp:Date.now()}),t}}async signMessage(e,t){try{return await e.signMessage(t)}catch(e){throw e}}verifySignature(e,t){return O.l(e,t)}async signTransaction(e,t,r,n){try{h(`Signing transaction from wallet ${e.address} to ${t} for ${r} ETH`);const i=n||this.getProvider(),a=await i.getTransactionCount(e.address);h(`Nonce for transaction: ${a}`);const s=await i.getFeeData(),o={nonce:a,to:t,value:J.g5(r),gasPrice:s.gasPrice,gasLimit:21e3},c=await e.signTransaction(o);return h("Transaction signed successfully"),c}catch(e){throw e}}resetMainWallet(){h("Resetting main wallet"),this.mainWallet=null}async exportMnemonic(e){try{h("⚠️ SECURITY WARNING: Exporting mnemonic phrase - handle with extreme care!");const t=await this.getUserMasterMnemonic();if(!t)throw new Error("No mnemonic available for this user");return e?this.encryptSensitiveData(t):t}catch(e){throw d(0),e}}async exportWalletKeys(e){try{if(h("⚠️ SECURITY WARNING: Exporting wallet private keys - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export wallet keys");const t=await this.loadWallets();if(0===t.length)throw new Error("No wallets found to export");const r=t.map((e=>{const t=e.wallet;return{address:t.address,privateKey:t.privateKey,path:e.path,created:this.walletPaths[t.address]?.created||Date.now()}})),n=JSON.stringify(r);return e?this.encryptSensitiveData(n):n}catch(e){throw d(0),e}}async exportGunPair(e){try{if(h("⚠️ SECURITY WARNING: Exporting GunDB pair - handle with extreme care!"),!this.isUserAuthenticated())throw new Error("User must be authenticated to export GunDB pair");const t=this.gun.user()._.sea;if(!t)throw new Error("No GunDB pair available for this user");const r=JSON.stringify(t);return e?this.encryptSensitiveData(r):r}catch(e){throw d(0),e}}async exportAllUserData(e){if(!e)throw new Error("È richiesta una password per esportare tutti i dati");try{const t=await this.getUserMasterMnemonic(),r=await this.loadWallets(),n=this.gun.user();if(!n||!n._||!n._.sea)throw new Error("Utente non autenticato o dati non disponibili");const i=r.map((e=>{const t=e.address||"";return{address:t,privateKey:e.wallet.privateKey,path:e.path,created:t&&this.walletPaths[t]?.created||Date.now()}})),a={user:{alias:n.is.alias,pub:n.is.pub,pair:n._.sea},mnemonic:t,wallets:i,version:"1.0",exportedAt:(new Date).toISOString(),appName:"Shogun Wallet"},o=await s().encrypt(JSON.stringify(a),e);return JSON.stringify({type:"encrypted-shogun-backup",data:o,version:"1.0"})}catch(e){throw e}}async importMnemonic(e,t){try{let r=e;if(e.startsWith("{"))try{const n=JSON.parse(e);if("encrypted-mnemonic"===n.type&&n.data&&t){const e=await s().decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=e}else n.mnemonic&&(r=n.mnemonic)}catch(e){throw new Error("Formato JSON non valido o password errata")}try{B.v.fromPhrase(r)}catch(e){throw new Error("La mnemonica fornita non è valida")}const n=this.gun.user();if(!n||!n.is)throw new Error("L'utente deve essere autenticato per importare una mnemonica");h("Cancellazione dei wallet path esistenti prima dell'importazione della nuova mnemonica");try{await n.get("wallet_paths").put(null),h("Wallet path eliminati da Gun con successo")}catch(e){}try{const e=`shogun_wallet_paths_${this.getStorageUserIdentifier()}`;this.storage.removeItem(e),h("Wallet path eliminati da localStorage con successo")}catch(e){}return this.walletPaths={},await this.saveUserMasterMnemonic(r),h("Nuova mnemonica salvata con successo"),this.resetMainWallet(),await this.createWallet(),h("Generato nuovo wallet con la mnemonica importata"),!0}catch(e){throw e}}async importWalletKeys(e,t){try{let r=[];e.length,e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(e.startsWith("{")||e.startsWith("[")){const n=JSON.parse(e);if("encrypted-wallets"===n.type&&n.data&&t)try{const e=await s().decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");"string"==typeof e&&e.length;try{const t=JSON.parse(e);if(t.wallets&&Array.isArray(t.wallets))r=t.wallets;else{if(!Array.isArray(t))throw new Error("Formato JSON decifrato non valido: manca il campo 'wallets'");r=t}}catch(e){throw new Error("Formato JSON decifrato non valido")}}catch(e){throw new Error(`Errore durante la decifratura: ${e.message||String(e)}`)}else if(n.wallets){if(!Array.isArray(n.wallets))throw new Error("Formato JSON non valido: il campo 'wallets' non è un array");r=n.wallets}else{if(!Array.isArray(n))throw new Error("Formato JSON non valido: manca il campo 'wallets'");r=n}}else{if(e.split(" ").length>=12)throw new Error("I dati sembrano essere una mnemonic, usa 'Importa Mnemonica' invece");if(!e.startsWith("0x")||66!==e.length)throw new Error("Formato non riconosciuto. Fornisci un file JSON valido.");try{const t=new _.u(e),n="m/44'/60'/0'/0/0";r=[{address:t.address,privateKey:t.privateKey,path:n,created:Date.now()}]}catch(e){throw new Error(`Chiave privata non valida: ${e}`)}}}catch(e){throw new Error(`Formato JSON non valido o password errata: ${e||String(e)}`)}if(!Array.isArray(r)||0===r.length)throw new Error("Nessun wallet valido trovato nei dati forniti");let n=0;for(const e of r)try{if(!e.privateKey)continue;const t=e.path||"m/44'/60'/0'/0/0";try{const r=new _.u(e.privateKey);e.address&&(r.address.toLowerCase(),e.address.toLowerCase()),this.walletPaths[r.address]={path:t,created:e.created||Date.now()},this.saveWalletPathsToLocalStorage(),n++}catch(e){}}catch(e){}if(0===n)throw new Error("Nessun wallet è stato importato con successo");return this.resetMainWallet(),n}catch(e){throw e}}async importGunPair(e,t){try{let r;try{const n=JSON.parse(e);if("encrypted-gun-pair"===n.type&&n.data&&t){const e=await s().decrypt(n.data,t);if(!e)throw new Error("Password non valida o dati corrotti");r=JSON.parse(e)}else r=n}catch(e){throw new Error("Formato JSON non valido o password errata")}if(!(r&&r.pub&&r.priv&&r.epub&&r.epriv))throw new Error("Il pair di Gun non è completo o valido");try{if(!this.gun.user())throw new Error("Gun non disponibile");return h("Pair di Gun validato con successo, pronto per l'autenticazione"),!0}catch(e){throw new Error(`Errore nell'autenticazione con il pair importato: ${e}`)}}catch(e){throw e}}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){try{if(!t)throw new Error("La password è obbligatoria per importare il backup");let n;e.length,e=(e=e.replace(/^\uFEFF/,"")).trim();try{if(!e.startsWith("{")&&!e.startsWith("["))throw new Error("Il backup deve essere in formato JSON valido");const r=JSON.parse(e);if("encrypted-shogun-backup"!==r.type||!r.data)throw new Error("Formato del backup non valido: manca il tipo o i dati");try{n=await s().decrypt(r.data,t)}catch(e){throw new Error(`Errore nella decifratura: ${e}`)}if(!n)throw new Error("Password non valida o dati corrotti");"string"==typeof n&&n.length;try{n=JSON.parse(n)}catch(e){throw new Error(`Errore nel parsing del contenuto decifrato: ${e}`)}}catch(e){throw new Error(`Formato JSON non valido o password errata: ${e}`)}const i={success:!1};if(r.importMnemonic&&n.mnemonic)try{await this.saveUserMasterMnemonic(n.mnemonic),i.mnemonicImported=!0}catch(e){i.mnemonicImported=!1}if(r.importWallets&&n.wallets&&Array.isArray(n.wallets))try{const e=JSON.stringify({wallets:n.wallets});i.walletsImported=await this.importWalletKeys(e)}catch(e){i.walletsImported=0}else r.importWallets;if(r.importGunPair&&n.user&&n.user.pair)try{const e=JSON.stringify(n.user.pair);await this.importGunPair(e),i.gunPairImported=!0}catch(e){i.gunPairImported=!1}else r.importGunPair;return i.success=!!(r.importMnemonic&&i.mnemonicImported||r.importWallets&&i.walletsImported&&i.walletsImported>0||r.importGunPair&&i.gunPairImported),i}catch(e){throw e}}setBalanceCacheTTL(e){if(e<0)throw new Error("Cache TTL must be a positive number");this.config.balanceCacheTTL=e,h(`Balance cache TTL updated to ${e}ms`)}isUserAuthenticated(){const e=this.gun.user();return!!(e&&e._&&e._.sea)}async exportWalletData(e={}){try{const t=await this.loadWallets(),r={version:"2.0",timestamp:Date.now(),wallets:t.map((t=>({address:t.address,path:t.path,created:this.walletPaths[t.address]?.created||Date.now(),...e.includePrivateKeys?{privateKey:t.wallet.privateKey}:{}}))),...e.includeHistory?{history:await this.getWalletHistory()}:{}};if(e.encryptionPassword){const t=await s().encrypt(JSON.stringify(r),e.encryptionPassword);return JSON.stringify({type:"encrypted-wallet-backup",version:"2.0",data:t})}return JSON.stringify(r)}catch(e){throw d(0),e}}async importWalletData(e,t={}){try{let r;if(!e.startsWith("{"))throw new Error("Invalid wallet data format");{const n=JSON.parse(e);if("encrypted-wallet-backup"===n.type&&t.decryptionPassword){const e=await s().decrypt(n.data,t.decryptionPassword);if(!e)throw new Error("Decryption failed");r=JSON.parse(e)}else r=n}let n=0;for(const e of r.wallets)try{if(t.validateAddresses){if(!R.PW(e.address))continue}if(!t.overwriteExisting&&this.walletPaths[e.address])continue;this.walletPaths[e.address]={path:e.path,created:e.created||Date.now()},n++}catch(t){d(e.address);continue}return await this.saveWalletPathsToLocalStorage(),this.emit(K.WALLET_IMPORTED,{type:K.WALLET_IMPORTED,data:{count:n},timestamp:Date.now()}),n}catch(e){throw d(0),e}}async getWalletHistory(){return[]}}class V extends M{constructor(){super(...arguments),this.name="wallet",this.version="1.0.0",this.description="Provides wallet management functionality for Shogun Core",this.walletManager=null}initialize(e){if(super.initialize(e),!e.gundb||!e.gun||!e.storage)throw new Error("Core dependencies not available");this.walletManager=new z(e.gundb,e.gun,e.storage,{balanceCacheTTL:e.config?.walletManager?.balanceCacheTTL,rpcUrl:e.provider instanceof S.FR?e.provider.connection?.url:void 0}),h("Wallet plugin initialized")}destroy(){this.walletManager=null,super.destroy(),h("Wallet plugin destroyed")}assertWalletManager(){if(this.assertInitialized(),!this.walletManager)throw new Error("Wallet manager not initialized");return this.walletManager}getMainWallet(){return this.assertWalletManager().getMainWallet()}async createWallet(){return this.assertWalletManager().createWallet()}async loadWallets(){try{const e=this.assertWalletManager();return this.core?.isLoggedIn()?await e.loadWallets():(h("Cannot load wallets: user not authenticated"),w.handle(m.AUTHENTICATION,"AUTH_REQUIRED","User authentication required to load wallets",null),[])}catch(e){return w.handle(m.WALLET,"LOAD_WALLETS_ERROR",`Error loading wallets: ${e instanceof Error?e.message:String(e)}`,e),[]}}getStandardBIP44Addresses(e,t=5){return this.assertWalletManager().getStandardBIP44Addresses(e,t)}generateNewMnemonic(){try{const e=_.u.createRandom().mnemonic;if(!e||!e.phrase)throw new Error("Failed to generate mnemonic phrase");return e.phrase}catch(e){throw d(0),new Error("Failed to generate mnemonic phrase")}}async signMessage(e,t){return this.assertWalletManager().signMessage(e,t)}verifySignature(e,t){return this.assertWalletManager().verifySignature(e,t)}async signTransaction(e,t,r){return this.assertWalletManager().signTransaction(e,t,r)}async exportMnemonic(e){return this.assertWalletManager().exportMnemonic(e)}async exportWalletKeys(e){return this.assertWalletManager().exportWalletKeys(e)}async exportGunPair(e){return this.assertWalletManager().exportGunPair(e)}async exportAllUserData(e){return this.assertWalletManager().exportAllUserData(e)}async importMnemonic(e,t){return this.assertWalletManager().importMnemonic(e,t)}async importWalletKeys(e,t){return this.assertWalletManager().importWalletKeys(e,t)}async importGunPair(e,t){return this.assertWalletManager().importGunPair(e,t)}async importAllUserData(e,t,r={importMnemonic:!0,importWallets:!0,importGunPair:!0}){return this.assertWalletManager().importAllUserData(e,t,r)}setRpcUrl(e){try{return e?(this.assertWalletManager().setRpcUrl(e),this.core&&(this.core.provider=new S.FR(e)),h(`RPC URL updated to: ${e}`),!0):(h("Invalid RPC URL provided"),!1)}catch(e){return d(0),!1}}getRpcUrl(){return this.core&&this.core.provider instanceof S.FR&&this.core.provider.connection?.url||null}}class Y{constructor(e){this.lastEphemeralKeyPair=null,this.lastMethodUsed="unknown",this.STEALTH_HISTORY_KEY="stealthHistory",this.logs=[],this.STEALTH_DATA_TABLE="Stealth",this.storage=e||new D}log(e,t,r){const n={timestamp:(new Date).toISOString(),level:e,message:t,data:r};this.logs.push(n)}async cleanupSensitiveData(){try{this.lastEphemeralKeyPair=null,this.lastMethodUsed="unknown",this.logs=[],this.log("info","Sensitive data cleanup completed")}catch(e){throw this.log("error","Error during cleanup",e),e}}validateStealthData(e){try{if(!e||"object"!=typeof e)return this.log("error","Invalid stealth data: data is not an object"),!1;const t=["recipientPublicKey","ephemeralKeyPair","timestamp"];for(const r of t)if(!(r in e))return this.log("error",`Invalid stealth data: missing ${r}`),!1;if("string"!=typeof e.recipientPublicKey||!e.recipientPublicKey.trim())return this.log("error","Invalid recipientPublicKey"),!1;if("number"!=typeof e.timestamp||e.timestamp<=0)return this.log("error","Invalid timestamp"),!1;const r=["pub","priv","epub","epriv"];for(const t of r)if(!(t in e.ephemeralKeyPair)||"string"!=typeof e.ephemeralKeyPair[t])return this.log("error",`Invalid ephemeralKeyPair: missing or invalid ${t}`),!1;return e.method&&!["standard","legacy"].includes(e.method)?(this.log("error","Invalid method value"),!1):e.sharedSecret&&"string"!=typeof e.sharedSecret?(this.log("error","Invalid sharedSecret type"),!1):(this.log("debug","Stealth data validation passed"),!0)}catch(e){return this.log("error","Error during stealth data validation",e),!1}}formatPublicKey(e){if(!e)return null;const t=e.trim();return t&&/^[~]?[\w+/=\-_.]+$/.test(t)?t.startsWith("~")?t.slice(1):t:null}async createAccount(){try{const e=await Gun.SEA.pair();if(!(e&&e.pub&&e.priv&&e.epub&&e.epriv))throw new Error("Failed to generate stealth key pair");return{pub:e.pub,priv:e.priv,epub:e.epub,epriv:e.epriv}}catch(e){throw e}}async generateEphemeralKeyPair(){try{const e=await Gun.SEA.pair();if(!e||!e.epriv||!e.epub)throw new Error("Failed to generate ephemeral key pair");return{privateKey:e.epriv,publicKey:e.epub}}catch(e){throw this.log("error","Error generating ephemeral key pair",e),e}}async generateStealthAddress(e,t){if(!e){const e=new Error("Invalid keys: missing or invalid parameters");throw w.handle(m.STEALTH,"INVALID_KEYS","Invalid or missing recipient public key",e),e}return new Promise(((r,n)=>{let i;const a=()=>{this.lastEphemeralKeyPair=i;const t={recipientPublicKey:e,ephemeralKeyPair:i,timestamp:Date.now()},a={epub:i.epub,epriv:i.epriv};Gun.SEA.secret(e,a,(async a=>{try{const n=N.S(W.YW(a)),s=new _.u(n);this.lastMethodUsed="standard",t.method="standard",t.sharedSecret=a,this.saveStealthHistory(s.address,t),r({stealthAddress:s.address,ephemeralPublicKey:i.epub,recipientPublicKey:e})}catch(e){const t=new Error(`Error creating stealth address: ${e instanceof Error?e.message:"unknown error"}`);w.handle(m.STEALTH,"ADDRESS_GENERATION_FAILED",`Error creating stealth address: ${e instanceof Error?e.message:"unknown error"}`,e),n(t)}}))};t?this.generateEphemeralKeyPair().then((e=>{try{i={epriv:t,epub:e.publicKey,priv:t,pub:e.publicKey},a()}catch(e){return w.handle(m.STEALTH,"EPHEMERAL_KEY_GENERATION_FAILED","Failed to use provided ephemeral key",e),void n(e)}})):this.generateEphemeralKeyPair().then((e=>{try{const t={epriv:e.privateKey,epub:e.publicKey,priv:e.privateKey,pub:e.publicKey};i=t,a()}catch(e){return w.handle(m.STEALTH,"EPHEMERAL_KEY_GENERATION_FAILED","Failed to generate valid ephemeral keys",e),void n(e)}}))}))}async openStealthAddress(e,t,r){try{const t=this.storage.getItem(this.STEALTH_HISTORY_KEY)||"{}",r=JSON.parse(t)[e];if(r){if(r.sharedSecret){const e=N.S(W.YW(r.sharedSecret));return new _.u(e)}if(r.method&&r.ephemeralKeyPair){if("standard"===r.method){const t={epub:r.ephemeralKeyPair.epub,epriv:r.ephemeralKeyPair.epriv};return new Promise(((n,i)=>{Gun.SEA.secret(r.recipientPublicKey,t,(async t=>{if(t)try{const r=N.S(W.YW(t)),i=new _.u(r);if(i.address.toLowerCase()===e.toLowerCase())return n(i);throw new Error("Address does not match")}catch(e){throw new Error("Derivation error")}else i(new Error("Unable to regenerate shared secret"))}))}))}throw new Error("Method not supported")}throw new Error("Insufficient data")}throw new Error("No data found")}catch(n){return this.openStealthAddressStandard(e,t,r)}}async openStealthAddressStandard(e,t,r){if(!e||!t)throw new Error("Missing parameters: stealthAddress or ephemeralPublicKey");return new Promise(((n,i)=>{const a=[()=>new Promise((n=>{Gun.SEA.secret(t,r,(async t=>{try{if(!t)return n(null);const r=this.deriveWalletFromSecret(t);return r.address.toLowerCase()===e.toLowerCase()?n(r):n(null)}catch(e){return n(null)}}))}))];this.deriveWalletFromSecret=e=>{const t=N.S(W.YW(e));return new _.u(t)};const s=async(e=0)=>{if(e>=a.length)return i(new Error("All stealth address derivation methods failed"));const t=await a[e]();if(t)return n(t);s(e+1)};s()}))}async getPublicKey(e){return this.formatPublicKey(e)}prepareStealthKeysForSaving(e){if(!(e?.pub&&e?.priv&&e?.epub&&e?.epriv))throw new Error("Invalid stealth keys: missing or incomplete parameters");return e}deriveWalletFromSecret(e){const t=N.S(W.YW(e));return new _.u(t)}saveStealthHistory(e,t){try{if(!this.validateStealthData(t))throw new Error("Invalid stealth data");const r=this.storage.getItem(this.STEALTH_HISTORY_KEY)||"{}",n=JSON.parse(r);n[e]=t,this.storage.setItem(this.STEALTH_HISTORY_KEY,JSON.stringify(n)),this.log("info",`Stealth data saved for address ${e}`)}catch(e){throw this.log("error","Error saving stealth data:",e),e}}async scanStealthAddresses(e,t){try{const r=[];for(const n of e)try{await this.isStealthAddressMine(n,t)&&r.push(n)}catch(e){this.log("error",`Error checking stealth address: ${e instanceof Error?e.message:"unknown error"}`)}return r}catch(e){throw this.log("error","Error scanning stealth addresses",e),e}}async isStealthAddressMine(e,t){try{if(!e||!t)throw new Error("Invalid parameters for stealth address check");if(!this.validateStealthData(e))throw new Error("Invalid stealth data format");const r=await this.getStealthPrivateKey(e,t);if(!r)return!1;try{new _.u(r);return!0}catch(e){return!1}}catch(e){throw this.log("error","Error checking stealth address ownership",e),e}}async getStealthPrivateKey(e,t){try{if(!e||!t)throw new Error("Invalid parameters for private key derivation");if(!this.validateStealthData(e))throw new Error("Invalid stealth data format");return e.sharedSecret?N.S(W.YW(e.sharedSecret)):new Promise(((r,n)=>{const i={priv:t,epub:e.ephemeralKeyPair.epub};Gun.SEA.secret(e.ephemeralKeyPair.epub,i,(e=>{if(e)try{const t=N.S(W.YW(e));r(t)}catch(e){n(new Error(`Error deriving private key: ${e instanceof Error?e.message:"unknown error"}`))}else n(new Error("Failed to generate shared secret"))}))}))}catch(e){throw this.log("error","Error getting stealth private key",e),e}}}"undefined"!=typeof window?window.Stealth=Y:void 0!==r.g&&(r.g.Stealth=Y);var q,X=r(8650);class Z{constructor(){this.events=new Map}on(e,t){this.events.has(e)||this.events.set(e,[]),this.events.get(e)?.push(t)}emit(e,t){if(!this.events.has(e))return;(this.events.get(e)||[]).forEach((e=>{try{e(t)}catch(e){}}))}off(e,t){if(!this.events.has(e))return;const r=this.events.get(e)||[],n=r.indexOf(t);-1!==n&&(r.splice(n,1),0===r.length?this.events.delete(e):this.events.set(e,r))}once(e,t){const r=n=>{t(n),this.off(e,r)};this.on(e,r)}removeAllListeners(e){e?this.events.delete(e):this.events.clear()}}!function(e){e.DEVICE_REGISTERED="deviceRegistered",e.DEVICE_REMOVED="deviceRemoved",e.AUTHENTICATION_SUCCESS="authenticationSuccess",e.AUTHENTICATION_FAILED="authenticationFailed",e.ERROR="error"}(q||(q={}));const Q={rpName:"Shogun Wallet",timeout:6e4,userVerification:"preferred",attestation:"none",authenticatorAttachment:"platform",requireResidentKey:!1};class ee extends Z{constructor(e,t){super(),this.abortController=null,this.gunInstance=e,this.credential=null,this.config={...Q,...t,rpId:t?.rpId||window.location.hostname.split(":")[0]}}validateUsername(e){if(!e||"string"!=typeof e)throw new Error("Username must be a non-empty string");if(e.length<3||e.length>64)throw new Error("Username must be between 3 and 64 characters");if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error("Username can only contain letters, numbers, underscores and hyphens")}async createAccount(e,t,r=!1){try{this.validateUsername(e);const n=3;let i=null;for(let a=1;a<=n;a++)try{const n=await this.generateCredentials(e,t,r);if(n.success)return this.emit(q.DEVICE_REGISTERED,{type:q.DEVICE_REGISTERED,data:{username:e,deviceInfo:n.deviceInfo},timestamp:Date.now()}),n;i=new Error(n.error||"Unknown error")}catch(e){if(i=e,a<n){await new Promise((e=>setTimeout(e,1e3*a)));continue}}throw i||new Error("Failed to create account after retries")}catch(e){throw this.emit(q.ERROR,{type:q.ERROR,data:{error:e.message},timestamp:Date.now()}),e}}async authenticateUser(e,t,r={}){try{if(this.validateUsername(e),!t){const e=new Error("No WebAuthn credentials found for this username");return w.handle(m.WEBAUTHN,"NO_CREDENTIALS",e.message,e),{success:!1,error:e.message}}this.abortAuthentication(),this.abortController=new AbortController;const n=r.timeout||this.config.timeout,i=setTimeout((()=>this.abortController?.abort()),n);try{const i={challenge:this.generateChallenge(e),allowCredentials:[],timeout:n,userVerification:r.userVerification||this.config.userVerification,rpId:this.config.rpId},a=await navigator.credentials.get({publicKey:i,signal:this.abortController.signal});if(!a)throw new Error("WebAuthn verification failed");const{password:s}=this.generateCredentialsFromSalt(e,t),o=this.getDeviceInfo(a.id),c={success:!0,username:e,password:s,credentialId:this.bufferToBase64(a.rawId),deviceInfo:o};return this.emit(q.AUTHENTICATION_SUCCESS,{type:q.AUTHENTICATION_SUCCESS,data:{username:e,deviceInfo:o},timestamp:Date.now()}),c}finally{clearTimeout(i),this.abortController=null}}catch(t){const r=t instanceof Error?t.message:"Unknown WebAuthn error";return this.emit(q.AUTHENTICATION_FAILED,{type:q.AUTHENTICATION_FAILED,data:{username:e,error:r},timestamp:Date.now()}),w.handle(m.WEBAUTHN,"AUTH_ERROR",r,t),{success:!1,error:r}}}abortAuthentication(){this.abortController&&(this.abortController.abort(),this.abortController=null)}getDeviceInfo(e){const t=this.getPlatformInfo();return{deviceId:e,timestamp:Date.now(),name:t.name,platform:t.platform,lastUsed:Date.now()}}getPlatformInfo(){if("undefined"==typeof navigator)return{name:"unknown",platform:"unknown"};const e=navigator.platform,t=navigator.userAgent;return/iPhone|iPad|iPod/.test(e)?{name:"iOS Device",platform:e}:/Android/.test(t)?{name:"Android Device",platform:e}:/Win/.test(e)?{name:"Windows Device",platform:e}:/Mac/.test(e)?{name:"Mac Device",platform:e}:/Linux/.test(e)?{name:"Linux Device",platform:e}:{name:"Unknown Device",platform:e}}generateChallenge(e){const t=Date.now().toString(),r=this.getRandomBytes(32),n=`${e}-${t}-${this.uint8ArrayToHex(r)}`;return(new TextEncoder).encode(n)}getRandomBytes(e){if("undefined"!=typeof window&&window.crypto)return window.crypto.getRandomValues(new Uint8Array(e));throw new Error("No cryptographic implementation available")}uint8ArrayToHex(e){return Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("")}bufferToBase64(e){const t=new Uint8Array(e).reduce(((e,t)=>e+String.fromCharCode(t)),"");return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}generateCredentialsFromSalt(e,t){const r=W.YW(e+t);return{password:X.s(r)}}isSupported(){return"undefined"!=typeof window&&void 0!==window.PublicKeyCredential}async createCredential(e){try{const t=crypto.getRandomValues(new Uint8Array(32)),r=(new TextEncoder).encode(e),n={challenge:t,rp:{name:"Shogun Wallet",..."localhost"!==this.config.rpId&&{id:this.config.rpId}},user:{id:r,name:e,displayName:e},pubKeyCredParams:[{type:"public-key",alg:-7}],timeout:this.config.timeout,attestation:this.config.attestation,authenticatorSelection:{authenticatorAttachment:this.config.authenticatorAttachment,userVerification:this.config.userVerification,requireResidentKey:this.config.requireResidentKey}},i=await navigator.credentials.create({publicKey:n});if(!i)throw new Error("Credential creation failed");const a=i,s={id:a.id,rawId:a.rawId,type:a.type,response:{clientDataJSON:a.response.clientDataJSON},getClientExtensionResults:a.getClientExtensionResults};return"attestationObject"in a.response&&(s.response.attestationObject=a.response.attestationObject),this.credential=s,s}catch(e){const t=e instanceof Error?e.message:"Unknown error";throw new Error(`Error creating credentials: ${t}`)}}async generateCredentials(e,t,r=!1){try{if(r){const t=await this.verifyCredential(e);return{success:t.success,error:t.error,credentialId:t.credentialId,username:t.username}}{const t=await this.createCredential(e),r=t.id;let n=null;return t?.response?.getPublicKey&&(n=t.response.getPublicKey()),{success:!0,credentialId:r,publicKey:n}}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error during WebAuthn operation"}}}async verifyCredential(e){try{const t={challenge:crypto.getRandomValues(new Uint8Array(32)),timeout:this.config.timeout,userVerification:this.config.userVerification,..."localhost"!==this.config.rpId&&{rpId:this.config.rpId}};this.credential?.rawId&&(t.allowCredentials=[{id:this.credential.rawId,type:"public-key"}]);const r=await navigator.credentials.get({publicKey:t});return r?{success:!0,credentialId:r.id,username:e}:{success:!1,error:"Credential verification failed"}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error verifying credentials"}}}async saveToGun(e,t){if(this.gunInstance)try{await this.gunInstance.get(`webauthn_${e}`).put({credentialId:t.id,type:t.type,timestamp:Date.now()})}catch(e){}}async removeDevice(e,t,r){if(!r||!r.credentials||!r.credentials[t])return{success:!1};const n={...r};return n.credentials&&delete n.credentials[t],{success:!0,updatedCredentials:n}}async sign(e){return await navigator.credentials.get({publicKey:{challenge:new Uint8Array(16),rpId:this.config.rpId}})}}"undefined"!=typeof window?window.Webauthn=ee:void 0!==r.g&&(r.g.Webauthn=ee);class te{constructor(e){if(this.plugins=new Map,h("Initializing ShogunSDK"),this.config=e,e.logging&&(u(e.logging),h("Logging configured with custom settings")),this.storage=new D,this.eventEmitter=new E.EventEmitter,w.addListener((e=>{this.eventEmitter.emit("error",{action:e.code,message:e.message,type:e.type})})),e.gundb||(e.gundb={},h("No GunDB configuration provided, using defaults")),e.gundb.authToken){h(`Auth token from config: ${e.gundb.authToken}`)}else h("No auth token in config");const t={peers:e.gundb?.peers,websocket:e.gundb?.websocket??!1,localStorage:e.gundb?.localStorage??!1,radisk:e.gundb?.radisk??!1,authToken:e.gundb?.authToken,multicast:e.gundb?.multicast??!1,axe:e.gundb?.axe??!1};if(this.gundb=new f(t),this.gun=this.gundb.getGun(),this.user=this.gun.user().recall({sessionStorage:!0}),this.rx=new P(this.gun),e.providerUrl?(this.provider=new S.FR(e.providerUrl),h(`Using configured provider URL: ${e.providerUrl}`)):(this.provider=b.x("mainnet"),h("WARNING: Using default Ethereum provider. For production use, configure a specific provider URL.")),this.registerBuiltinPlugins(e),e.plugins?.autoRegister&&e.plugins.autoRegister.length>0)for(const t of e.plugins.autoRegister)try{this.register(t),h(`Auto-registered plugin: ${t.name}`)}catch(e){d(t.name)}h("ShogunSDK initialized!")}registerBuiltinPlugins(e){try{if(e.webauthn?.enabled){const e=new T.WebauthnPlugin;e._category=y.Authentication,this.register(e),h("Webauthn plugin registered")}if(e.metamask?.enabled){const e=new $;e._category=y.Authentication,this.register(e),h("MetaMask plugin registered")}if(e.stealth?.enabled){const e=new L.StealthPlugin;e._category=y.Privacy,this.register(e),h("Stealth plugin registered")}if(e.did?.enabled){const e=new G;e._category=y.Identity,this.register(e),h("DID plugin registered")}if(e.walletManager?.enabled){const e=new V;e._category=y.Wallet,this.register(e),h("Wallet plugin registered")}}catch(e){d(0)}}register(e){if(this.plugins.has(e.name))throw new Error(`Plugin with name "${e.name}" already registered`);e.initialize(this),this.plugins.set(e.name,e),h(`Registered plugin: ${e.name}`)}unregister(e){const t=this.plugins.get(e);t?(t.destroy&&t.destroy(),this.plugins.delete(e),h(`Unregistered plugin: ${e}`)):h(`Plugin "${e}" not found, nothing to unregister`)}getPlugin(e){return this.plugins.get(e)}hasPlugin(e){return this.plugins.has(e)}getPluginsByCategory(e){const t=[];return this.plugins.forEach((r=>{r._category===e&&t.push(r)})),t}getAuthenticationMethod(e){switch(e){case"webauthn":return this.getPlugin(v.WebAuthn);case"metamask":return this.getPlugin(v.MetaMask);default:return{login:(e,t)=>this.login(e,t),signUp:(e,t,r)=>this.signUp(e,t,r)}}}observe(e){return this.rx.observe(e)}match(e,t){return this.rx.match(e,t)}rxPut(e,t){return this.rx.put(e,t)}rxSet(e,t){return this.rx.set(e,t)}onceObservable(e){return this.rx.once(e)}compute(e,t){return this.rx.compute(e,t)}rxUserPut(e,t){return this.rx.userPut(e,t)}observeUser(e){return this.rx.observeUser(e)}getRecentErrors(e=10){return w.getRecentErrors(e)}configureLogging(e){u(e),h("Logging reconfigured with new settings")}isLoggedIn(){const e=this.gundb.isLoggedIn(),t=this.gun.user();if(e)return!0;const r=t&&t._&&t._.sea,n=this.storage.getItem("pair");return!!r||!!n}logout(){try{if(!this.isLoggedIn())return void h("Logout ignored: user not authenticated");this.gundb.logout(),this.eventEmitter.emit("auth:logout",{}),h("Logout completed successfully")}catch(e){w.handle(m.AUTHENTICATION,"LOGOUT_FAILED",e instanceof Error?e.message:"Error during logout",e)}}async login(e,t){h("Login");try{if(h(`Login attempt for user: ${e}`),!e||!t)return{success:!1,error:"Username and password are required"};const r=new Promise((r=>{this.gundb.gun.user().auth(e,t,(t=>{if(t.err)h(`Login error: ${t.err}`),r({success:!1,error:t.err});else{const t=this.gundb.gun.user();if(t.is){h("Login completed successfully");const n=t.is?.pub||"";r({success:!0,userPub:n,username:e})}else r({success:!1,error:"Login failed: user not authenticated"})}}))})),n=this.config?.timeouts?.login||15e3,i=new Promise((e=>{setTimeout((()=>{e({success:!1,error:"Login timeout"})}),n)})),a=await Promise.race([r,i]);if(a.success){this.eventEmitter.emit("auth:login",{userPub:a.userPub||""});try{const e=await this.ensureUserHasDID();e&&(a.did=e)}catch(e){d(0)}}return a}catch(e){return w.handle(m.AUTHENTICATION,"LOGIN_FAILED",e.message||"Unknown error during login",e),{success:!1,error:e.message||"Unknown error during login"}}}async signUp(e,t,r){h("Sign up");try{if(!e||!t)return{success:!1,error:"Username and password are required"};if(void 0!==r&&t!==r)return{success:!1,error:"Passwords do not match"};if(t.length<6)return{success:!1,error:"Password must be at least 6 characters long"};const n=new Promise((r=>{this.gundb.gun.user().create(e,t,(n=>{n.err?r({success:!1,error:n.err}):this.gundb.gun.user().auth(e,t,(t=>{if(t.err)r({success:!1,error:"Registration completed but login failed"});else{const t=this.gundb.gun.user();t.is?r({success:!0,userPub:t.is?.pub||"",username:e||""}):r({success:!1,error:"Registration completed but user not authenticated"})}}))}))})),i=this.config?.timeouts?.signup||2e4,a=new Promise((e=>{setTimeout((()=>{e({success:!1,error:"Registration timeout"})}),i)})),s=await Promise.race([n,a]);if(s.success){this.eventEmitter.emit("auth:signup",{userPub:s.userPub||"",username:e});try{const e=await this.ensureUserHasDID();e&&(h(`Created DID for new user: ${e}`),s.did=e)}catch(e){d(0)}}return s}catch(e){return d(0),{success:!1,error:e.message||"Unknown error during registration"}}}async ensureUserHasDID(e){try{const t=this.getPlugin("did");return t?await t.ensureUserHasDID(e):(h("DID plugin not available, cannot ensure DID"),null)}catch(e){return d(0),null}}createUserWithGunDB(e,t){return h(`Ensuring user exists with GunDB: ${e}`),new Promise((async r=>{try{const n=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().auth(e,t,(e=>{if(e.err)r({err:e.err});else{const e=this.gundb.gun.user(),t=e.is?.pub||"";e.is&&t?r({pub:t}):r({err:"Authentication failed after apparent success."})}}))})),i=()=>new Promise((r=>{try{this.gundb.logout()}catch(e){}this.gundb.gun.user().create(e,t,(e=>{r({err:e.err,pub:e.pub})}))}));h(`Attempting login first for ${e}...`);let a=await n();if(a.pub)return h(`Login successful for existing user. Pub: ${a.pub}`),void r({success:!0,userPub:a.pub});h(`Login failed (${a.err||"unknown reason"}), attempting user creation...`);const s=await i();if(s.err)return h(`User creation error: ${s.err}`),void r({success:!1,error:`User creation failed: ${s.err}`});h("User created successfully, attempting login again for confirmation..."),a=await n(),a.pub?(h(`Post-creation login successful! User pub: ${a.pub}`),r({success:!0,userPub:a.pub})):(d(a.err),r({success:!1,error:`User created, but subsequent login failed: ${a.err}`}))}catch(e){const t=e.message||"Unknown error during user existence check";d(0),r({success:!1,error:t})}}))}get(e){return new Promise(((t,r)=>{this.gundb.gun.get(e).once((e=>{e.err?r(e.err):t(e)}))}))}put(e){return new Promise(((t,r)=>{this.gundb.gun.put(e,(e=>{e.err?r(e.err):t(e)}))}))}userPut(e){return new Promise(((t,r)=>{this.gundb.gun.user().put(e,(e=>{e.err?r(e.err):t(e)}))}))}userGet(e){return new Promise(((t,r)=>{this.gundb.gun.user().get(e).once((e=>{e.err?r(e.err):t(e)}))}))}setRpcUrl(e){try{return e?(this.provider=new S.FR(e),h(`RPC URL updated to: ${e}`),!0):(h("Invalid RPC URL provided"),!1)}catch(e){return d(0),!1}}getRpcUrl(){return this.provider instanceof S.FR&&this.provider.connection?.url||null}emit(e,...t){return this.eventEmitter.emit(e,...t)}on(e,t){return this.eventEmitter.on(e,t),this}once(e,t){return this.eventEmitter.once(e,t),this}off(e,t){return this.eventEmitter.off(e,t),this}removeAllListeners(e){return this.eventEmitter.removeAllListeners(e),this}}te.API_VERSION="2.0.0";let re;const ne={loadWebAuthn:()=>Promise.resolve().then(r.bind(r,409)),loadStealth:()=>Promise.resolve().then(r.bind(r,2256)),loadDID:()=>r.e(662).then(r.bind(r,4662))};"undefined"!=typeof window&&(window.ShogunCore=re,window.initShogunBrowser=function(e){const t={...e};return t.gundb||(t.gundb={}),e.gundb?.peers||h("WARNING: Using default GunDB peers. For production, always configure custom peers."),e.providerUrl||h("WARNING: No Ethereum provider URL specified. Using default public endpoint with rate limits."),re=new te(t),re},window.ShogunModules=ne)},2256:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Stealth:()=>n,default:()=>i});class n{constructor(){}formatPublicKey(){throw new Error("Stealth functionality disabled in light version")}async createAccount(){throw new Error("Stealth functionality disabled in light version")}async generateStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async openStealthAddress(){throw new Error("Stealth functionality disabled in light version")}async getPublicKey(){throw new Error("Stealth functionality disabled in light version")}prepareStealthKeysForSaving(){throw new Error("Stealth functionality disabled in light version")}deriveWalletFromSecret(){throw new Error("Stealth functionality disabled in light version")}}const i=n},5736:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5736,e.exports=t}},i={};function a(e){var t=i[e];if(void 0!==t)return t.exports;var r=i[e]={id:e,loaded:!1,exports:{}};return n[e](r,r.exports,a),r.loaded=!0,r.exports}a.m=n,e=[],a.O=(t,r,n,i)=>{if(!r){var s=1/0;for(u=0;u<e.length;u++){for(var[r,n,i]=e[u],o=!0,c=0;c<r.length;c++)(!1&i||s>=i)&&Object.keys(a.O).every((e=>a.O[e](r[c])))?r.splice(c--,1):(o=!1,i<s&&(s=i));if(o){e.splice(u--,1);var l=n();void 0!==l&&(t=l)}}return t}i=i||0;for(var u=e.length;u>0&&e[u-1][2]>i;u--)e[u]=e[u-1];e[u]=[r,n,i]},a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},a.d=(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},a.f={},a.e=e=>Promise.all(Object.keys(a.f).reduce(((t,r)=>(a.f[r](e,t),t)),[])),a.u=e=>e+".shogun-core.light.js",a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),t={},r="ShogunCore:",a.l=(e,n,i,s)=>{if(t[e])t[e].push(n);else{var o,c;if(void 0!==i)for(var l=document.getElementsByTagName("script"),u=0;u<l.length;u++){var h=l[u];if(h.getAttribute("src")==e||h.getAttribute("data-webpack")==r+i){o=h;break}}o||(c=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,a.nc&&o.setAttribute("nonce",a.nc),o.setAttribute("data-webpack",r+i),o.src=e),t[e]=[n];var d=(r,n)=>{o.onerror=o.onload=null,clearTimeout(g);var i=t[e];if(delete t[e],o.parentNode&&o.parentNode.removeChild(o),i&&i.forEach((e=>e(n))),r)return r(n)},g=setTimeout(d.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=d.bind(null,o.onerror),o.onload=d.bind(null,o.onload),c&&document.head.appendChild(o)}},a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;a.g.importScripts&&(e=a.g.location+"");var t=a.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var r=t.getElementsByTagName("script");if(r.length)for(var n=r.length-1;n>-1&&(!e||!/^http(s?):/.test(e));)e=r[n--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),a.p=e})(),(()=>{var e={792:0};a.f.j=(t,r)=>{var n=a.o(e,t)?e[t]:void 0;if(0!==n)if(n)r.push(n[2]);else{var i=new Promise(((r,i)=>n=e[t]=[r,i]));r.push(n[2]=i);var s=a.p+a.u(t),o=new Error;a.l(s,(r=>{if(a.o(e,t)&&(0!==(n=e[t])&&(e[t]=void 0),n)){var i=r&&("load"===r.type?"missing":r.type),s=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+i+": "+s+")",o.name="ChunkLoadError",o.type=i,o.request=s,n[1](o)}}),"chunk-"+t,t)}},a.O.j=t=>0===e[t];var t=(t,r)=>{var n,i,[s,o,c]=r,l=0;if(s.some((t=>0!==e[t]))){for(n in o)a.o(o,n)&&(a.m[n]=o[n]);if(c)var u=c(a)}for(t&&t(r);l<s.length;l++)i=s[l],a.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return a.O(u)},r=this.webpackChunkShogunCore=this.webpackChunkShogunCore||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var s=a.O(void 0,[96],(()=>a(1656)));return s=(s=a.O(s)).default})()));