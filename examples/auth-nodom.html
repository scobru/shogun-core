<!doctype html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Auth - NoDom Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
      :root {
        --primary-color: #007AFF;
        --primary-hover: #0056CC;
        --secondary-color: #5856D6;
        --success-color: #34C759;
        --warning-color: #FF9500;
        --warning-hover: #E6850E;
        --error-color: #FF3B30;
        --background: #F2F2F7;
        --surface: #FFFFFF;
        --surface-secondary: #F9F9FB;
        --text-primary: #1D1D1F;
        --text-secondary: #86868B;
        --text-tertiary: #C7C7CC;
        --border-color: #E5E5EA;
        --border-focus: #007AFF;
        --shadow-light: 0 1px 3px rgba(0, 0, 0, 0.1);
        --shadow-medium: 0 4px 12px rgba(0, 0, 0, 0.15);
        --shadow-heavy: 0 8px 25px rgba(0, 0, 0, 0.15);
        --radius-small: 8px;
        --radius-medium: 12px;
        --radius-large: 16px;
        --spacing-xs: 4px;
        --spacing-sm: 8px;
        --spacing-md: 16px;
        --spacing-lg: 24px;
        --spacing-xl: 32px;
        --spacing-2xl: 48px;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: var(--background);
        color: var(--text-primary);
        line-height: 1.6;
        font-size: 16px;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: var(--spacing-lg);
        min-height: 100vh;
      }

      .app-header {
        text-align: center;
        margin-bottom: var(--spacing-2xl);
        padding: var(--spacing-xl) 0;
      }

      .app-title {
        font-size: 2.5rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: var(--spacing-sm);
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .app-subtitle {
        font-size: 1.1rem;
        color: var(--text-secondary);
        font-weight: 400;
      }

      .main-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: var(--spacing-xl);
        margin-bottom: var(--spacing-2xl);
      }

      .action-group {
        background: var(--surface);
        border-radius: var(--radius-large);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-medium);
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
      }

      .action-group:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-heavy);
      }

      .action-group h2 {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }

      .action-group h3 {
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: var(--spacing-md);
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .status-badge {
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .status-supported {
        background: rgba(52, 199, 89, 0.1);
        color: var(--success-color);
      }

      .status-not-supported {
        background: rgba(255, 59, 48, 0.1);
        color: var(--error-color);
      }

      .status-warning {
        background: rgba(255, 149, 0, 0.1);
        color: var(--warning-color);
      }

      .form-group {
        margin-bottom: var(--spacing-md);
      }

      .form-group input,
      .form-group select {
        width: 100%;
        padding: var(--spacing-md);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-small);
        font-size: 1rem;
        font-family: inherit;
        background: var(--surface);
        color: var(--text-primary);
        transition: all 0.2s ease;
      }

      .form-group input:focus,
      .form-group select:focus {
        outline: none;
        border-color: var(--border-focus);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
      }

      .form-group input::placeholder {
        color: var(--text-tertiary);
      }

      .primary-button,
      .action-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
        padding: var(--spacing-md) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-small);
        font-size: 0.95rem;
        font-weight: 500;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
        min-height: 44px;
        margin: var(--spacing-xs);
      }

      .primary-button {
        background: var(--primary-color);
        color: white;
      }

      .primary-button:hover:not(:disabled) {
        background: var(--primary-hover);
        transform: translateY(-1px);
      }

      .action-button {
        background: var(--surface);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
      }

      .action-button:hover:not(:disabled) {
        background: var(--surface-secondary);
        border-color: var(--border-focus);
        transform: translateY(-1px);
      }

      .warning-button {
        background: var(--warning-color);
        color: white;
      }

      .warning-button:hover:not(:disabled) {
        background: var(--warning-hover);
        transform: translateY(-1px);
      }

      .primary-button:disabled,
      .action-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
      }

      .form-actions {
        display: flex;
        gap: var(--spacing-sm);
        flex-wrap: wrap;
        margin-top: var(--spacing-md);
      }

      .form-actions button {
        flex: 1;
        min-width: 120px;
      }

      .user-id {
        background: var(--surface-secondary);
        padding: var(--spacing-md);
        border-radius: var(--radius-small);
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        font-size: 0.85rem;
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        word-break: break-all;
        margin-bottom: var(--spacing-md);
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      .user-id.empty {
        color: var(--text-tertiary);
        font-style: italic;
        background: var(--background);
      }

      .user-status-display {
        background: var(--surface-secondary);
        border-radius: var(--radius-small);
        padding: var(--spacing-md);
        border: 1px solid var(--border-color);
        margin-top: var(--spacing-md);
        overflow: hidden;
      }

      .status-row {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
        flex-wrap: wrap;
      }

      .status-row:last-child {
        margin-bottom: 0;
      }

      .status-indicator {
        font-weight: 500;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: var(--radius-small);
        font-size: 0.9rem;
        white-space: nowrap;
        flex-shrink: 0;
      }

      .status-indicator.status-success {
        background: rgba(52, 199, 89, 0.1);
        color: var(--success-color);
        border: 1px solid var(--success-color);
      }

      .status-indicator.status-warning {
        background: rgba(255, 149, 0, 0.1);
        color: var(--warning-color);
        border: 1px solid var(--warning-color);
      }

      .status-indicator.status-error {
        background: rgba(255, 59, 48, 0.1);
        color: var(--error-color);
        border: 1px solid var(--error-color);
      }

      .user-info {
        background: var(--surface);
        border-radius: var(--radius-small);
        padding: var(--spacing-sm);
        font-size: 0.9rem;
        line-height: 1.4;
        word-break: break-all;
        overflow-wrap: break-word;
        max-width: 100%;
        margin-top: var(--spacing-sm);
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        border: 1px solid var(--border-color);
      }

      #results {
        background: var(--surface);
        border-radius: var(--radius-large);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-medium);
        border: 1px solid var(--border-color);
        min-height: 200px;
        margin-top: var(--spacing-xl);
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        font-size: 0.9rem;
        line-height: 1.5;
        color: var(--text-primary);
        white-space: pre-wrap;
        word-break: break-word;
        max-height: 400px;
        overflow-y: auto;
        background: var(--surface-secondary);
      }

      .loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid transparent;
        border-top: 2px solid currentColor;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .fade-in {
        animation: fadeInUp 0.6s ease-out;
      }

      @keyframes fadeInUp {
        from { 
          opacity: 0; 
          transform: translateY(20px) scale(0.95);
        }
        to { 
          opacity: 1; 
          transform: translateY(0) scale(1);
        }
      }

      /* Responsive design */
      @media (max-width: 768px) {
        .container {
          padding: var(--spacing-md);
        }

        .app-title {
          font-size: 2rem;
        }

        .action-group {
          padding: var(--spacing-lg);
        }

        .form-actions {
          flex-direction: column;
        }

        .form-actions button {
          flex: none;
        }

        .main-grid {
          grid-template-columns: 1fr;
        }
      }

      /* Dark mode support */
      @media (prefers-color-scheme: dark) {
        :root {
          --background: #000000;
          --surface: #1C1C1E;
          --surface-secondary: #2C2C2E;
          --text-primary: #FFFFFF;
          --text-secondary: #8E8E93;
          --text-tertiary: #48484A;
          --border-color: #38383A;
        }
      }

      /* Custom Styles for Relay Management */
      .relay-status-card {
        background: var(--surface-secondary);
        border-radius: var(--radius-small);
        padding: var(--spacing-md);
        margin-bottom: var(--spacing-lg);
      }

      .relay-status-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--spacing-sm);
      }

      .peer-count-badge {
        background: var(--success-color);
        color: white;
        padding: var(--spacing-xs) var(--spacing-sm);
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        min-width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .current-peers-display {
        overflow-y: auto;
        max-height: 150px;
        border: 1px solid var(--border-color);
        border-radius: var(--radius-small);
        background: var(--surface);
        padding: var(--spacing-sm);
      }

      .peers-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
      }

      .no-peers-message {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: var(--spacing-lg);
        color: var(--text-tertiary);
        font-style: italic;
        text-align: center;
      }

      .add-peer-section {
        margin-top: var(--spacing-lg);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
      }

      .add-peer-section h4 {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: var(--spacing-md);
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
      }

      .relay-examples {
        margin-top: var(--spacing-sm);
      }

      .relay-examples-details {
        cursor: pointer;
        background: var(--surface);
        border-radius: var(--radius-small);
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-sm);
      }

      .relay-examples-content {
        padding-left: var(--spacing-md);
      }

      .relay-example {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-xs) 0;
        cursor: pointer;
      }

      .relay-example:hover {
        background: var(--surface-secondary);
        border-radius: var(--radius-small);
        padding: var(--spacing-xs);
      }

      .example-label {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .warning-button {
        background: var(--warning-color);
        color: white;
      }

      .warning-button:hover:not(:disabled) {
        background: var(--warning-hover);
        transform: translateY(-1px);
      }

      /* Peer List Items */
      .peer-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--spacing-sm);
        margin-bottom: var(--spacing-xs);
        border-radius: var(--radius-small);
        border: 1px solid var(--border-color);
        transition: all 0.2s ease;
      }

      .peer-item:hover {
        background: var(--surface);
        transform: translateX(4px);
      }

      .peer-connected {
        border-left: 4px solid var(--success-color);
        background: rgba(52, 199, 89, 0.05);
      }

      .peer-disconnected {
        border-left: 4px solid var(--error-color);
        background: rgba(255, 59, 48, 0.05);
      }

      .peer-status {
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
      }

      .peer-status-icon {
        font-size: 0.8rem;
      }

      .peer-status-text {
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .peer-url {
        font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        font-size: 0.85rem;
        color: var(--text-secondary);
      }

      /* Responsive improvements for relay management */
      @media (max-width: 768px) {
        .peer-item {
          flex-direction: column;
          align-items: flex-start;
          gap: var(--spacing-xs);
        }

        .relay-examples-content {
          padding-left: 0;
        }

        .form-actions {
          flex-direction: column;
        }

        .form-actions button {
          width: 100%;
          margin: var(--spacing-xs) 0;
        }

        .status-row {
          flex-direction: column;
          align-items: flex-start;
          gap: var(--spacing-xs);
        }

        .status-indicator {
          width: 100%;
          text-align: center;
          white-space: normal;
          word-break: break-word;
        }

        .user-id {
          font-size: 0.8rem;
          padding: var(--spacing-sm);
        }

        .user-info {
          font-size: 0.8rem;
          padding: var(--spacing-sm);
          line-height: 1.3;
        }

        .relay-status-header {
          flex-direction: column;
          align-items: flex-start;
          gap: var(--spacing-sm);
        }

        .main-grid {
          grid-template-columns: 1fr;
          gap: var(--spacing-lg);
        }

        .user-status-display {
          padding: var(--spacing-sm);
        }

        .action-group {
          padding: var(--spacing-md);
        }
      }

      /* Improved animations */
      @keyframes fadeInUp {
        from { 
          opacity: 0; 
          transform: translateY(20px) scale(0.95);
        }
        to { 
          opacity: 1; 
          transform: translateY(0) scale(1);
        }
      }

      .fade-in {
        animation: fadeInUp 0.6s ease-out;
      }

      /* Improved button states */
      .primary-button:disabled,
      .action-button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
        box-shadow: none;
      }

      .primary-button:hover:not(:disabled),
      .action-button:hover:not(:disabled) {
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      }

      /* Better focus states */
      .form-group input:focus,
      .form-group select:focus {
        outline: none;
        border-color: var(--border-focus);
        box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        transform: translateY(-1px);
      }
    </style>
  </head>

  <body>
    <div id="app"></div>

    <!-- Include libraries -->
    <script src="https://cdn.jsdelivr.net/npm/gun/dist/gun.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/dist/lib/wire.js"></script>
    <script src="./shogun-core.js"></script>
    <script type="module">
      // Import NoDom functions
      import { 
        init, 
        setSignal, 
        setEffect, 
        setMemo, 
        h, 
        Fragment,
        auth as nodomAuth,
        logout as nodomLogout,
        getNamespace,
        setNamespace
      } from './nodom.js';

      // Global state signals
      let shogun;
      let gun;
      
      // Reactive state
      const [getInitialized, setInitialized] = setSignal(false, { key: 'app.initialized' });
      const [getAuthStatus, setAuthStatus] = setSignal('❌ Not authenticated', { key: 'app.authStatus' });
      const [getUserInfo, setUserInfo] = setSignal('', { key: 'app.userInfo' });
      const [getResults, setResults] = setSignal('Results will appear here...', { key: 'app.results' });
      const [getLoading, setLoading] = setSignal(false, { key: 'app.loading' });
      
      // Plugin status signals
      const [getWebAuthnStatus, setWebAuthnStatus] = setSignal('NON INIZIALIZZATO', { key: 'plugins.webauthn' });
      const [getEthereumStatus, setEthereumStatus] = setSignal('NON INIZIALIZZATO', { key: 'plugins.ethereum' });
      const [getBitcoinStatus, setBitcoinStatus] = setSignal('NON INIZIALIZZATO', { key: 'plugins.bitcoin' });
      
      // Form data signals
      const [getUsername, setUsername] = setSignal('', { key: 'forms.username' });
      const [getPassword, setPassword] = setSignal('', { key: 'forms.password' });
      const [getWebAuthnUsername, setWebAuthnUsername] = setSignal('', { key: 'forms.webauthn.username' });
      
      // Wallet state signals
      const [getMetamaskAddress, setMetamaskAddress] = setSignal('No wallet connected', { key: 'wallets.metamask.address' });
      const [getBitcoinAddress, setBitcoinAddress] = setSignal('No wallet connected', { key: 'wallets.bitcoin.address' });

      // Relay management signals
      const [getPeerCount, setPeerCount] = setSignal(0, { key: 'relay.peerCount' });
      const [getPeersList, setPeersList] = setSignal('No peers configured', { key: 'relay.peersList' });
      const [getNewPeerUrl, setNewPeerUrl] = setSignal('', { key: 'relay.newPeerUrl' });

      // Plugin references
      let webauthnPlugin;
      let ethereumPlugin;
      let bitcoinPlugin;
      let bip44Plugin;

      // Utility functions
      function showResult(title, data) {
        const resultText = `${title}\n\n${JSON.stringify(data, null, 2)}`;
        setResults(resultText);
      }

      function showError(title, error) {
        const errorText = `${title} - ERRORE\n\n${error.message || error}`;
        setResults(errorText);
        console.error(error);
      }

      function setButtonLoading(isLoading) {
        setLoading(isLoading);
      }

      // Helper functions to extract clean addresses
      function extractAddress(addressString) {
        if (!addressString || addressString === 'No wallet connected') {
          return null;
        }
        
        // If it starts with "Indirizzo: ", extract the actual address
        if (addressString.startsWith('Indirizzo: ')) {
          return addressString.replace('Indirizzo: ', '').trim();
        }
        
        // Otherwise return as is
        return addressString.trim();
      }

      function getCleanEthereumAddress() {
        return extractAddress(getMetamaskAddress());
      }

      function getCleanBitcoinAddress() {
        return extractAddress(getBitcoinAddress());
      }

      // Check support functions
      function checkWebAuthnSupport() {
        if (!webauthnPlugin) {
          setWebAuthnStatus('NON INIZIALIZZATO');
          return false;
        }

        try {
          // Check browser support for WebAuthn
          const browserSupported = typeof window.PublicKeyCredential !== "undefined";
          
          // Check plugin support
          const pluginSupported = webauthnPlugin.isSupported();
          
          const isSupported = browserSupported && pluginSupported;
          
          if (isSupported) {
            setWebAuthnStatus('SUPPORTATO');
          } else if (browserSupported && !pluginSupported) {
            setWebAuthnStatus('PLUGIN ERROR');
          } else {
            setWebAuthnStatus('NON SUPPORTATO');
          }
          
          return isSupported;
        } catch (error) {
          console.error('Errore durante il controllo del supporto WebAuthn:', error);
          setWebAuthnStatus('ERRORE');
          return false;
        }
      }

      function checkEthereumSupport() {
        if (!ethereumPlugin) {
          setEthereumStatus('NON INIZIALIZZATO');
          return false;
        }

        try {
          const isAvailable = typeof window.ethereum !== "undefined";
          setEthereumStatus(isAvailable ? 'RILEVATO' : 'NON RILEVATO');
          return isAvailable;
        } catch (error) {
          console.error('Errore durante il controllo del supporto Ethereum:', error);
          setEthereumStatus('ERRORE');
          return false;
        }
      }

      function checkBitcoinSupport() {
        if (!bitcoinPlugin) {
          setBitcoinStatus('NON INIZIALIZZATO');
          return false;
        }

        try {
          const nostrAvailable = typeof window.nostr !== "undefined";
          let pluginNostrAvailable = false;
          if (typeof bitcoinPlugin.isNostrExtensionAvailable === "function") {
            pluginNostrAvailable = bitcoinPlugin.isNostrExtensionAvailable();
          }

          const isAvailable = nostrAvailable || pluginNostrAvailable || true;
          const supportText = isAvailable
            ? nostrAvailable || pluginNostrAvailable
              ? "Nostr"
              : "Manuale"
            : "NON DISPONIBILE";

          setBitcoinStatus(supportText);
          return isAvailable;
        } catch (error) {
          console.error('Errore durante il controllo del supporto Bitcoin:', error);
          setBitcoinStatus('ERRORE');
          return false;
        }
      }

      function updateAuthenticationStatus() {
        if (!shogun) {
          setAuthStatus('❌ Not authenticated');
          setUserInfo('');
          return;
        }

        const isLoggedIn = shogun.isLoggedIn();
        const authMethod = typeof shogun.getAuthMethod === 'function' ? shogun.getAuthMethod() : null;
        
        const hasSessionData = sessionStorage.getItem('gun/') || 
                              sessionStorage.getItem('gun/user') || 
                              sessionStorage.getItem('gun/auth');
        
        if (isLoggedIn) {
          let statusText = '✅ Authenticated';
          if (authMethod) {
            statusText += ` (${authMethod})`;
          }
          setAuthStatus(statusText);
          
          const user = shogun.gun.user();
          if (user && user.is && user.is.alias) {
            // Format user info with proper line breaks and structure
            const userInfoText = `User: ${user.is.alias}\n\nPublic Key:\n${user.is.pub}`;
            setUserInfo(userInfoText);
          } else {
            setUserInfo('');
          }
        } else if (hasSessionData) {
          setAuthStatus('🔄 Session Active (checking...)');
          setUserInfo('');
        } else {
          setAuthStatus('❌ Not authenticated');
          setUserInfo('');
        }
      }

      // Authentication handlers
      async function handleInitialize() {
        try {
          console.log('🚀 Starting Shogun initialization...');
          setButtonLoading(true);
          
          // Check if required dependencies are available
          if (typeof Gun === 'undefined') {
            console.error('❌ Gun.js not loaded');
            throw new Error('Gun.js not loaded. Please check the script tags.');
          }
          
          if (typeof window.initShogunBrowser === 'undefined') {
            console.error('❌ Shogun Core not loaded');
            throw new Error('Shogun Core not loaded. Please check the script tags.');
          }
          
          console.log('✅ Dependencies check passed');
          
          const options = {
            peers: ["http://localhost:8000/gun"],
            localStorage: false,
            radisk: false,
            wire: true,
          };

          const config = {
            gunInstance: new Gun(options),
            scope: "shogun",
            peers: ["http://localhost:8000/gun"],
            webauthn: {
              enabled: true,
              rpName: "Shogun Demo",
              rpId: window.location.hostname,
            },
            ethereum: {
              enabled: true,
            },
            bitcoin: {
              enabled: true,
              network: "mainnet",
              defaultWalletType: "nostr",
            },
            bip44: {
              enabled: true,
            },
            logging: {
              enabled: true,
              level: "debug",
              prefix: "[Shogun Demo]",
            },
          };

          showResult("Inizializzazione", { message: "Inizializzazione in corso...", status: "processing" });

          console.log('🔧 Creating Shogun instance...');
          try {
          shogun = window.initShogunBrowser(config);
            console.log('✅ Shogun instance created');
          } catch (shogunError) {
            console.error('❌ Error creating Shogun instance:', shogunError);
            throw new Error(`Failed to create Shogun instance: ${shogunError.message}`);
          }
          
          gun = shogun.gun;

          console.log('🔗 Initializing NoDom with Gun instance...');
          try {
          // Initialize NoDom with Gun instance
          init(gun);
            console.log('✅ NoDom initialized');
          } catch (nodomError) {
            console.error('❌ Error initializing NoDom:', nodomError);
            throw new Error(`Failed to initialize NoDom: ${nodomError.message}`);
          }

          try {
          shogun.gun.on("out", function (msg) {
            var to = this.to;
            msg.headers = { token: "automa25" };
            to.next(msg);
          });

          shogun.gun.on("get", function (msg) {
            var to = this.to;
            msg.headers = { token: "automa25" };
            to.next(msg);
          });
            console.log('✅ Gun event handlers attached');
          } catch (gunError) {
            console.warn('⚠️ Warning: Could not attach Gun event handlers:', gunError);
            // Non-fatal error, continue
          }

          // Get plugin references
          try {
          webauthnPlugin = shogun.getPlugin("webauthn");
          bitcoinPlugin = shogun.getPlugin("bitcoin");
          bip44Plugin = shogun.getPlugin("bip44");
          ethereumPlugin = shogun.getPlugin("ethereum");
            console.log('✅ Plugin references obtained');
          } catch (pluginError) {
            console.warn('⚠️ Warning: Could not get all plugin references:', pluginError);
            // Non-fatal error, continue
          }

          // Check support - declare variables outside try block
          let webauthnSupported = false;
          let ethereumSupported = false;
          let bitcoinSupported = false;
          
          try {
            webauthnSupported = checkWebAuthnSupport();
            ethereumSupported = checkEthereumSupport();
            bitcoinSupported = checkBitcoinSupport();
            console.log('✅ Support checks completed');
          } catch (supportError) {
            console.warn('⚠️ Warning: Error during support checks:', supportError);
            // Non-fatal error, continue - variables remain false
          }

          window.shogun = shogun;
          console.log("✅ Shogun initialized and exposed globally");

          setInitialized(true);
          updateAuthenticationStatus();

          showResult("Shogun Inizializzato", {
            stato: "Successo",
            connesso: true,
            webauthn: webauthnSupported || false,
            ethereum: ethereumSupported || false,
            bitcoin: bitcoinSupported || false,
            plugins: {
              webauthn: !!webauthnPlugin,
              ethereum: !!ethereumPlugin,
              bitcoin: !!bitcoinPlugin,
              bip44: !!bip44Plugin,
            },
            timestamp: new Date().toISOString()
          });
          
          // Update peers list after initialization
          setTimeout(() => {
            updatePeersList();
          }, 500);
          
          console.log('🎉 Shogun initialization completed successfully');
          
        } catch (error) {
          console.error('💥 Fatal error in handleInitialize:', error);
          showError("Inizializzazione", error);
          // Ensure loading state is reset even on error
          setButtonLoading(false);
          throw error; // Re-throw to be caught by button handler
        } finally {
          setButtonLoading(false);
          console.log('🔄 handleInitialize finally block executed');
        }
      }

      // Wallet connection handlers
      async function handleConnectEthereum() {
        try {
          if (!ethereumPlugin) {
            showError("MetaMask", new Error("Plugin Ethereum non disponibile"));
            return;
          }

          setButtonLoading(true);
          showResult("MetaMask", { message: "Connessione in corso..." });

          const result = await ethereumPlugin.connectMetaMask();

          if (result.success) {
            setMetamaskAddress(`Indirizzo: ${result.address}`);
            showResult("MetaMask Connesso", result);
          } else {
            showError("MetaMask", new Error(result.error || "Errore durante la connessione"));
          }
        } catch (error) {
          showError("MetaMask", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleConnectBitcoin() {
        try {
          if (!bitcoinPlugin) {
            showError("Bitcoin Wallet", new Error("Plugin Bitcoin non disponibile"));
            return;
          }

          setButtonLoading(true);
          showResult("Bitcoin Wallet", { message: "Connessione in corso..." });

          const result = await bitcoinPlugin.connectBitcoinWallet("nostr");

          if (result.success) {
            setBitcoinAddress(`Indirizzo: ${result.address}`);
            showResult("Bitcoin Wallet Connesso", result);
          } else {
            showError("Bitcoin Wallet", new Error(result.error || "Errore durante la connessione"));
          }
        } catch (error) {
          showError("Bitcoin Wallet", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Ethereum login/signup handlers
      async function handleEthereumLogin() {
        try {
          if (!ethereumPlugin) {
            showError("Login MetaMask", new Error("Plugin Ethereum non disponibile"));
            return;
          }

          setButtonLoading(true);
          
          // Connect first if not connected
          let currentAddress = getCleanEthereumAddress();
          if (!currentAddress) {
            const connectResult = await ethereumPlugin.connectMetaMask();
            if (!connectResult.success) {
              showError("Connessione MetaMask", new Error(connectResult.error || "Errore durante la connessione"));
              return;
            }
            setMetamaskAddress(`Indirizzo: ${connectResult.address}`);
            currentAddress = connectResult.address;
          }

          showResult("MetaMask", { message: "Login in corso..." });

          const result = await ethereumPlugin.login ? 
            await ethereumPlugin.login(currentAddress) : 
            await ethereumPlugin.loginWithMetaMask(currentAddress);

          if (result.success) {
            showResult("Login con MetaMask completato", result);
            updateAuthenticationStatus();
          } else {
            showError("Login MetaMask", new Error(result.error || "Errore durante il login"));
          }
        } catch (error) {
          showError("Login MetaMask", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleEthereumSignup() {
        try {
          if (!ethereumPlugin) {
            showError("Registrazione MetaMask", new Error("Plugin Ethereum non disponibile"));
            return;
          }

          setButtonLoading(true);
          
          // Connect first if not connected
          let currentAddress = getCleanEthereumAddress();
          if (!currentAddress) {
            const connectResult = await ethereumPlugin.connectMetaMask();
            if (!connectResult.success) {
              showError("Connessione MetaMask", new Error(connectResult.error || "Errore durante la connessione"));
              return;
            }
            setMetamaskAddress(`Indirizzo: ${connectResult.address}`);
            currentAddress = connectResult.address;
          }

          showResult("MetaMask", { message: "Registrazione in corso..." });

          const result = await ethereumPlugin.signUp ? 
            await ethereumPlugin.signUp(currentAddress) : 
            await ethereumPlugin.signUpWithMetaMask(currentAddress);

          if (result.success) {
            showResult("Registrazione con MetaMask completata", result);
            updateAuthenticationStatus();
          } else {
            showError("Registrazione MetaMask", new Error(result.error || "Errore durante la registrazione"));
          }
        } catch (error) {
          showError("Registrazione MetaMask", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Bitcoin login/signup handlers
      async function handleBitcoinLogin() {
        try {
          if (!bitcoinPlugin) {
            showError("Login Bitcoin", new Error("Plugin Bitcoin non disponibile"));
            return;
          }

          const currentAddress = getCleanBitcoinAddress();
          if (!currentAddress) {
            showError("Login Bitcoin", new Error("Nessun indirizzo Bitcoin configurato. Clicca prima su 'Connect Wallet'."));
            return;
          }

          setButtonLoading(true);
          showResult("Bitcoin Wallet", { message: "Login in corso..." });

          const alias = localStorage.getItem("bitcoin_user_alias") || `btc_user_fallback_${currentAddress.substring(0, 6)}`;
          const options = { walletType: "nostr", alias, forceConnect: true, debug: true };

          console.log('🔍 Bitcoin login debug:', {
            currentAddress,
            addressLength: currentAddress.length,
            alias,
            options
          });

          const result = await bitcoinPlugin.login(currentAddress, options);

          if (result.success) {
            showResult("Login con Bitcoin completato", result);
            updateAuthenticationStatus();
          } else {
            showError("Login Bitcoin", new Error(result.error || "Login fallito"));
          }
        } catch (error) {
          showError("Login Bitcoin", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleBitcoinSignup() {
        try {
          if (!bitcoinPlugin) {
            showError("Registrazione Bitcoin", new Error("Plugin Bitcoin non disponibile"));
            return;
          }

          const currentAddress = getCleanBitcoinAddress();
          if (!currentAddress) {
            showError("Registrazione Bitcoin", new Error("Nessun indirizzo Bitcoin configurato. Clicca prima su 'Connect Wallet'."));
            return;
          }

          setButtonLoading(true);
          showResult("Bitcoin Wallet", { message: "Registrazione in corso..." });

          const alias = `btc_user_${Date.now().toString(36)}_${currentAddress.substring(0, 6)}`;
          const options = { walletType: "nostr", alias, forceCreate: true };

          console.log('🔍 Bitcoin signup debug:', {
            currentAddress,
            addressLength: currentAddress.length,
            alias,
            options
          });

          const result = await bitcoinPlugin.signUp(currentAddress, options);

          if (result.success) {
            localStorage.setItem("bitcoin_user_alias", alias);
            showResult("Registrazione con Bitcoin completata", result);
            updateAuthenticationStatus();
          } else {
            if (result.error && (result.error.includes("already created") || result.error.includes("già creato") || result.error.includes("already exists"))) {
              localStorage.setItem("bitcoin_user_alias", alias);
              showResult("Account già esistente", {
                success: true,
                message: "L'utente esiste già. Prova a effettuare il login.",
                alias: alias,
                suggestion: "Clicca sul pulsante 'Login con Bitcoin' per accedere."
              });
              updateAuthenticationStatus();
            } else {
              showError("Registrazione Bitcoin", new Error(result.error || "Registrazione fallita"));
            }
          }
        } catch (error) {
          showError("Registrazione Bitcoin", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Relay management functions
      function updatePeersList() {
        if (!shogun || !shogun.gundb) {
          setPeersList('Shogun not initialized');
          setPeerCount(0);
          return;
        }

        try {
          const peerInfo = shogun.gundb.getPeerInfo();
          const peerEntries = Object.entries(peerInfo);
          const connectedCount = peerEntries.filter(([_, info]) => info.connected).length;
          
          setPeerCount(peerEntries.length);
          
          if (peerEntries.length === 0) {
            setPeersList('No peers configured');
            return;
          }

          // Create peer list HTML
          const peerListHtml = peerEntries.map(([peer, info]) => {
            const statusIcon = info.connected ? '🟢' : '🔴';
            const statusText = info.connected ? 'Connected' : 'Disconnected';
            
            return `
              <div class="peer-item ${info.connected ? 'peer-connected' : 'peer-disconnected'}">
                <div class="peer-status">
                  <span class="peer-status-icon">${statusIcon}</span>
                  <span class="peer-status-text">${statusText}</span>
                </div>
                <div class="peer-url">
                  <code>${peer}</code>
                </div>
              </div>
            `;
          }).join('');
          
          setPeersList(peerListHtml);
          
        } catch (error) {
          console.error("Error updating peers list:", error);
          setPeersList('Error loading peers');
          setPeerCount(0);
        }
      }

      function fillPeerUrl(url) {
        setNewPeerUrl(url);
        showResult("Peer URL", { message: `URL impostato: ${url}` });
      }

      async function handleAddPeer() {
        if (!shogun || !shogun.gundb) {
          showError("Add Peer", new Error("Shogun not initialized"));
          return;
        }

        const peerUrl = getNewPeerUrl().trim();
        if (!peerUrl) {
          showError("Add Peer", new Error("Please enter a peer URL"));
          return;
        }

        try {
          new URL(peerUrl);
        } catch (error) {
          showError("Add Peer", new Error("Invalid URL format"));
          return;
        }

        try {
          setButtonLoading(true);
          
          const existingPeers = shogun.gundb.getAllConfiguredPeers();
          if (existingPeers.includes(peerUrl)) {
            showResult("Add Peer", {
              success: false,
              message: "Peer already configured",
              peer: peerUrl,
              suggestion: "Try reconnecting to the peer instead"
            });
            return;
          }

          shogun.gundb.addPeer(peerUrl);
          setNewPeerUrl('');
          
          setTimeout(() => {
            updatePeersList();
            showResult("Peer Added", {
              success: true,
              peer: peerUrl,
              message: "Peer added successfully",
              timestamp: new Date().toISOString()
            });
          }, 1000);
          
        } catch (error) {
          showError("Add Peer", error);
        } finally {
          setButtonLoading(false);
        }
      }

      function handleRefreshPeers() {
        try {
          setButtonLoading(true);
          updatePeersList();
          
          showResult("Peers Refreshed", {
            success: true,
            message: "Peer list updated",
            timestamp: new Date().toISOString()
          });
        } catch (error) {
          showError("Refresh Peers", error);
        } finally {
          setButtonLoading(false);
        }
      }

      function handleClearAllPeers() {
        if (!shogun || !shogun.gundb) {
          showError("Clear Peers", new Error("Shogun not initialized"));
          return;
        }

        const confirmed = confirm(
          "⚠️ Attenzione!\n\n" +
          "Questa operazione rimuoverà TUTTI i peer configurati.\n" +
          "Potresti perdere la connessione alla rete Gun.js.\n\n" +
          "Sei sicuro di voler continuare?"
        );
        
        if (!confirmed) {
          return;
        }

        try {
          setButtonLoading(true);
          
          const existingPeers = shogun.gundb.getAllConfiguredPeers();
          shogun.gundb.resetPeers();
          updatePeersList();
          
          showResult("All Peers Cleared", {
            success: true,
            message: "All peers have been removed",
            removedPeers: existingPeers,
            warning: "You may need to add new peers to reconnect to the network",
            timestamp: new Date().toISOString()
          });
        } catch (error) {
          showError("Clear Peers", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Traditional auth handlers
      async function handleLogin() {
        const username = getUsername();
        const password = getPassword();

        if (!username || !password) {
          showError("Login", new Error("Username e password sono richiesti!"));
          return;
        }

        try {
          setButtonLoading(true);
          
          const result = await shogun.login(username, password);

          if (result.success) {
            showResult("Login completato", result);
            updateAuthenticationStatus();
            setUsername('');
            setPassword('');
          } else {
            showError("Login", new Error(result.error || "Login fallito"));
          }
        } catch (error) {
          showError("Login", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleSignUp() {
        const username = getUsername();
        const password = getPassword();

        if (!username || !password) {
          showError("Registrazione", new Error("Username e password sono richiesti!"));
          return;
        }

        try {
          setButtonLoading(true);
          
          const result = await shogun.signUp(username, password);

          if (result.success) {
            showResult("Registrazione completata", result);
            updateAuthenticationStatus();
            setUsername('');
            setPassword('');
          } else {
            showError("Registrazione", new Error(result.error || "Registrazione fallita"));
          }
        } catch (error) {
          showError("Registrazione", error);
        } finally {
          setButtonLoading(false);
        }
      }

      function handleLogout() {
        if (!shogun) {
          showError("Logout", new Error("Shogun non è stato inizializzato!"));
          return;
        }

        try {
          if (!shogun.isLoggedIn()) {
            showResult("Logout", {
              success: true,
              message: "Nessun utente connesso, logout non necessario",
            });
            return;
          }

          shogun.logout();
          
          // Reset state
          setMetamaskAddress('No wallet connected');
          setBitcoinAddress('No wallet connected');
          setUsername('');
          setPassword('');
          setWebAuthnUsername('');
          
          // Clear localStorage
          try {
            localStorage.removeItem("bitcoin_user_alias");
            localStorage.removeItem("auth_attempt");
            localStorage.removeItem("auth_reload");
            localStorage.removeItem("is_authenticated");
            localStorage.removeItem("current_user");
          } catch (localStorageError) {
            console.warn("Could not clear localStorage:", localStorageError);
          }

          setTimeout(() => {
            checkWebAuthnSupport();
            checkEthereumSupport();
            checkBitcoinSupport();
            updateAuthenticationStatus();
          }, 100);

          showResult("Logout Completato", {
            success: true,
            message: "Disconnessione completata con successo",
            timestamp: new Date().toISOString()
          });

        } catch (error) {
          showError("Logout", error);
        }
      }

      function clearAllStorage() {
        try {
          const localStorageKeys = [];
          const sessionStorageKeys = [];
          
          for (let i = 0; i < localStorage.length; i++) {
            localStorageKeys.push(localStorage.key(i));
          }
          
          for (let i = 0; i < sessionStorage.length; i++) {
            sessionStorageKeys.push(sessionStorage.key(i));
          }
          
          localStorage.clear();
          sessionStorage.clear();
          
          if (bitcoinPlugin) {
            try {
              bitcoinPlugin.clearSignatureCache();
            } catch (bitcoinCacheError) {
              console.warn("Could not clear Bitcoin signature cache:", bitcoinCacheError);
            }
          }
          
          // Reset state
          setMetamaskAddress('No wallet connected');
          setBitcoinAddress('No wallet connected');
          setUsername('');
          setPassword('');
          setWebAuthnUsername('');
          
          setTimeout(() => {
            checkWebAuthnSupport();
            checkEthereumSupport();
            checkBitcoinSupport();
            updateAuthenticationStatus();
          }, 100);
          
          showResult("Storage Pulito", {
            success: true,
            message: "Tutti i dati di storage sono stati cancellati",
            cleared: {
              localStorage: localStorageKeys,
              sessionStorage: sessionStorageKeys,
              totalKeys: localStorageKeys.length + sessionStorageKeys.length
            },
            timestamp: new Date().toISOString()
          });
          
        } catch (error) {
          showError("Pulizia Storage", error);
        }
      }

      // WebAuthn handlers
      async function handleWebAuthnRegister() {
        const username = getWebAuthnUsername();

        if (!username) {
          showError("WebAuthn Registration", new Error("Username è richiesto per la registrazione WebAuthn!"));
          return;
        }

        if (!webauthnPlugin) {
          showError("WebAuthn Registration", new Error("Plugin WebAuthn non disponibile"));
          return;
        }

        try {
          setButtonLoading(true);
          showResult("WebAuthn", { message: "Registrazione in corso..." });

          // Check WebAuthn support
          if (!webauthnPlugin.isSupported()) {
            showError("WebAuthn Registration", new Error("WebAuthn non è supportato in questo browser"));
            return;
          }

          const result = await webauthnPlugin.signUp(username);

          if (result.success) {
            showResult("Registrazione WebAuthn completata", result);
            updateAuthenticationStatus();
            setWebAuthnUsername('');
          } else {
            showError("WebAuthn Registration", new Error(result.error || "Registrazione fallita"));
          }
        } catch (error) {
          showError("WebAuthn Registration", error);
        } finally {
          setButtonLoading(false);
        }
      }

      async function handleWebAuthnLogin() {
        const username = getWebAuthnUsername();

        if (!username) {
          showError("WebAuthn Login", new Error("Username è richiesto per il login WebAuthn!"));
          return;
        }

        if (!webauthnPlugin) {
          showError("WebAuthn Login", new Error("Plugin WebAuthn non disponibile"));
          return;
        }

        try {
          setButtonLoading(true);
          showResult("WebAuthn", { message: "Login in corso..." });

          // Check WebAuthn support
          if (!webauthnPlugin.isSupported()) {
            showError("WebAuthn Login", new Error("WebAuthn non è supportato in questo browser"));
            return;
          }

          const result = await webauthnPlugin.login(username);

          if (result.success) {
            showResult("Login WebAuthn completato", result);
            updateAuthenticationStatus();
            setWebAuthnUsername('');
          } else {
            showError("WebAuthn Login", new Error(result.error || "Login fallito"));
          }
        } catch (error) {
          showError("WebAuthn Login", error);
        } finally {
          setButtonLoading(false);
        }
      }

      // Component functions
      function AppHeader() {
        return h('div', { class: 'app-header' },
          h('h1', { class: 'app-title' }, '🥷 Shogun Auth - NoDom Edition'),
          h('p', { class: 'app-subtitle' }, 'Secure authentication with reactive signals')
        );
      }

      function InitializationSection() {
        return h('div', { class: 'action-group fade-in' },
          h('h2', {}, '⚡ Inizializzazione'),
          h('p', {}, 'Initialize the Shogun SDK and test connections'),
          
          h('div', { class: 'form-actions' },
            h('button', { 
              class: () => `primary-button ${getLoading() ? 'disabled' : ''}`,
              onclick: async (e) => {
                try {
                e.preventDefault();
                e.stopPropagation();
                  console.log('🔴 Initialize button clicked');
                  await handleInitialize();
                  console.log('✅ Initialize completed successfully');
                } catch (error) {
                  console.error('❌ Error in initialize button handler:', error);
                  showError("Button Handler", error);
                } finally {
                  console.log('🔄 Initialize button handler finished');
                }
                return false;
              },
              disabled: () => getLoading(),
              type: 'button'
            }, () => getLoading() ? 'Initializing...' : 'Initialize Shogun'),
            
            h('button', { 
              class: 'action-button warning-button',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                clearAllStorage();
                return false;
              },
              type: 'button'
            }, '🗑️ Clear Storage')
          ),
          
          h('div', { class: 'user-status-display' },
            h('div', { class: 'status-row' },
              h('strong', {}, 'Status: '),
              h('span', { 
                class: () => {
                  const status = getAuthStatus();
                  if (status.includes('✅')) return 'status-indicator status-success';
                  if (status.includes('🔄')) return 'status-indicator status-warning';
                  return 'status-indicator status-error';
                }
              }, () => getAuthStatus())
            ),
            () => getUserInfo() ? h('div', { 
              class: 'user-info'
            }, () => getUserInfo()) : null
          )
        );
      }

      function TraditionalAuthSection() {
        return h('div', { class: 'action-group fade-in' },
          h('h2', {}, '🔐 Username & Password'),
          h('p', {}, 'Traditional authentication method'),

          h('form', { onsubmit: (e) => { e.preventDefault(); return false; } },
            h('div', { class: 'form-group' },
              h('input', {
                type: 'text',
                placeholder: 'Enter your username',
                autocomplete: 'username',
                value: () => getUsername(),
                oninput: (e) => setUsername(e.target.value)
              })
            ),
            h('div', { class: 'form-group' },
              h('input', {
                type: 'password',
                placeholder: 'Enter your password',
                autocomplete: 'current-password',
                value: () => getPassword(),
                oninput: (e) => setPassword(e.target.value)
              })
            ),
            h('div', { class: 'form-actions' },
              h('button', { 
                class: () => `primary-button ${getLoading() ? 'disabled' : ''}`,
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleLogin();
                  return false;
                },
                disabled: () => getLoading(),
                type: 'button'
              }, 'Sign In'),
              h('button', { 
                class: () => `action-button ${getLoading() ? 'disabled' : ''}`,
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleSignUp();
                  return false;
                },
                disabled: () => getLoading(),
                type: 'button'
              }, 'Sign Up'),
              h('button', { 
                class: 'action-button',
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleLogout();
                  return false;
                },
                type: 'button'
              }, 'Sign Out')
            )
          )
        );
      }

      function WebAuthnSection() {
        return h('div', { class: 'action-group fade-in' },
          h('h3', {},
            '🔑 WebAuthn',
            h('span', { 
              class: () => {
                const status = getWebAuthnStatus();
                if (status === 'SUPPORTATO') return 'status-badge status-supported';
                if (status === 'NON INIZIALIZZATO' || status === 'PLUGIN ERROR') return 'status-badge status-warning';
                return 'status-badge status-not-supported';
              }
            }, () => getWebAuthnStatus())
          ),
          h('p', {}, 'Biometric and hardware key authentication'),

          h('form', { onsubmit: (e) => { e.preventDefault(); return false; } },
            h('div', { class: 'form-group' },
              h('input', {
                type: 'text',
                placeholder: 'Username for WebAuthn',
                autocomplete: 'username',
                value: () => getWebAuthnUsername(),
                oninput: (e) => setWebAuthnUsername(e.target.value)
              })
            ),
            h('div', { class: 'form-actions' },
              h('button', { 
                class: () => `primary-button ${getLoading() ? 'disabled' : ''}`,
                disabled: () => getWebAuthnStatus() !== 'SUPPORTATO' || getLoading(),
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleWebAuthnLogin();
                  return false;
                },
                type: 'button'
              }, () => getLoading() ? 'Signing In...' : 'Sign In'),
              h('button', { 
                class: () => `action-button ${getLoading() ? 'disabled' : ''}`,
                disabled: () => getWebAuthnStatus() !== 'SUPPORTATO' || getLoading(),
                onclick: (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  handleWebAuthnRegister();
                  return false;
                },
                type: 'button'
              }, () => getLoading() ? 'Registering...' : 'Register')
            )
          )
        );
      }

      function EthereumSection() {
        return h('div', { class: 'action-group fade-in' },
          h('h3', {},
            '🦊 Wallet Ethereum',
            h('span', { 
              class: () => {
                const status = getEthereumStatus();
                if (status === 'RILEVATO') return 'status-badge status-supported';
                if (status === 'NON INIZIALIZZATO') return 'status-badge status-warning';
                return 'status-badge status-not-supported';
              }
            }, () => getEthereumStatus())
          ),
          h('p', {}, 'Connect with MetaMask or other Ethereum wallets'),

          h('div', { 
            class: () => {
              const address = getMetamaskAddress();
              return address === 'No wallet connected' ? 'user-id empty' : 'user-id';
            }
          }, () => getMetamaskAddress()),
          
          h('div', { class: 'form-actions' },
            h('button', { 
              class: 'action-button',
              disabled: () => getEthereumStatus() !== 'RILEVATO',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleConnectEthereum();
                return false;
              },
              type: 'button'
            }, 'Connect Wallet'),
            h('button', { 
              class: 'primary-button',
              disabled: () => getEthereumStatus() !== 'RILEVATO',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleEthereumLogin();
                return false;
              },
              type: 'button'
            }, 'Sign In'),
            h('button', { 
              class: 'action-button',
              disabled: () => getEthereumStatus() !== 'RILEVATO',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleEthereumSignup();
                return false;
              },
              type: 'button'
            }, 'Register')
          )
        );
      }

      function BitcoinSection() {
        return h('div', { class: 'action-group fade-in' },
          h('h3', {},
            '₿ Bitcoin Wallet',
            h('span', { 
              class: () => {
                const status = getBitcoinStatus();
                if (status === 'Nostr') return 'status-badge status-supported';
                if (status === 'NON INIZIALIZZATO') return 'status-badge status-warning';
                return 'status-badge status-not-supported';
              }
            }, () => getBitcoinStatus())
          ),
          h('p', {}, 'Connect with Nostr extension'),

          h('div', { 
            class: () => {
              const address = getBitcoinAddress();
              return address === 'No wallet connected' ? 'user-id empty' : 'user-id';
            }
          }, () => getBitcoinAddress()),

          h('div', { class: 'form-actions' },
            h('button', { 
              class: 'action-button',
              disabled: () => getBitcoinStatus() === 'NON INIZIALIZZATO',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleConnectBitcoin();
                return false;
              },
              type: 'button'
            }, 'Connect Wallet'),
            h('button', { 
              class: 'primary-button',
              disabled: () => getBitcoinStatus() === 'NON INIZIALIZZATO',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleBitcoinLogin();
                return false;
              },
              type: 'button'
            }, 'Sign In'),
            h('button', { 
              class: 'action-button',
              disabled: () => getBitcoinStatus() === 'NON INIZIALIZZATO',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleBitcoinSignup();
                return false;
              },
              type: 'button'
            }, 'Register')
          )
        );
      }

      function RelayManagementSection() {
        return h('div', { class: 'action-group fade-in' },
          h('h2', {}, '🌐 Relay Management'),
          h('p', {}, 'Manage Gun.js relay peers for decentralized networking'),

          // Current Peers Status Card
          h('div', { class: 'relay-status-card' },
            h('div', { class: 'relay-status-header' },
              h('h4', {}, '🔗 Current Peers Status'),
              h('span', { 
                class: 'peer-count-badge',
                style: () => {
                  const count = getPeerCount();
                  return count === 0 ? 'background: var(--error-color);' : 'background: var(--success-color);';
                }
              }, () => getPeerCount().toString())
            ),
            h('div', { class: 'current-peers-display' },
              () => {
                const peersList = getPeersList();
                if (peersList === 'No peers configured' || peersList === 'Shogun not initialized' || peersList === 'Error loading peers') {
                  return h('div', { class: 'no-peers-message' }, 
                    peersList === 'Shogun not initialized' ? '⚠️ Shogun not initialized' :
                    peersList === 'Error loading peers' ? '❌ Error loading peers' :
                    '📡 No peers configured yet'
                  );
                } else {
                  return h('div', { 
                    class: 'peers-list',
                    innerHTML: peersList
                  });
                }
              }
            )
          ),

          // Add New Peer Section
          h('div', { class: 'add-peer-section' },
            h('h4', {}, '➕ Add New Relay'),
            h('div', { class: 'form-group' },
              h('input', {
                type: 'url',
                placeholder: 'Enter relay URL (e.g., http://localhost:8000/gun)',
                value: () => getNewPeerUrl(),
                oninput: (e) => setNewPeerUrl(e.target.value)
              })
            ),

            h('div', { class: 'relay-examples' },
              h('details', { class: 'relay-examples-details' },
                h('summary', {}, '📋 Common relay examples'),
                h('div', { class: 'relay-examples-content' },
                  h('div', { 
                    class: 'relay-example',
                    onclick: () => fillPeerUrl('http://localhost:8000/gun')
                  },
                    h('code', {}, 'http://localhost:8000/gun'),
                    h('span', { class: 'example-label' }, 'Local test relay')
                  ),
                  h('div', { 
                    class: 'relay-example',
                    onclick: () => fillPeerUrl('http://localhost:8765/gun')
                  },
                    h('code', {}, 'http://localhost:8765/gun'),
                    h('span', { class: 'example-label' }, 'Alternative local relay')
                  ),
                  h('div', { 
                    class: 'relay-example',
                    onclick: () => fillPeerUrl('https://gun-manhattan.herokuapp.com/gun')
                  },
                    h('code', {}, 'https://gun-manhattan.herokuapp.com/gun'),
                    h('span', { class: 'example-label' }, 'Public relay')
                  )
                )
              )
            )
          ),

          // Action Buttons
          h('div', { class: 'form-actions' },
            h('button', { 
              class: 'primary-button',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleAddPeer();
                return false;
              },
              type: 'button'
            }, '➕ Add Peer'),
            h('button', { 
              class: 'action-button',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleRefreshPeers();
                return false;
              },
              type: 'button'
            }, '🔄 Refresh'),
            h('button', { 
              class: 'action-button warning-button',
              onclick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                handleClearAllPeers();
                return false;
              },
              type: 'button'
            }, '🗑️ Clear All')
          )
        );
      }

      function ResultsSection() {
        return h('div', { class: 'action-group fade-in', style: 'grid-column: 1 / -1;' },
          h('h2', {}, '📊 Results'),
          h('div', { id: 'results' }, () => getResults())
        );
      }

      function App() {
        return h('div', { class: 'container' },
          AppHeader(),
          h('div', { class: 'main-grid' },
            InitializationSection(),
            TraditionalAuthSection(),
            WebAuthnSection(),
            EthereumSection(),
            BitcoinSection(),
            RelayManagementSection(),
            ResultsSection()
          )
        );
      }

      // Initialize the app
      document.addEventListener('DOMContentLoaded', () => {
        const appElement = App();
        document.getElementById('app').appendChild(appElement);
        
        // Show welcome message
        setTimeout(() => {
          showResult("Benvenuto", {
            message: "🥷 Benvenuto in Shogun Auth - NoDom Edition!",
            instructions: "Clicca su 'Initialize Shogun' per iniziare",
            features: [
              "🔐 Autenticazione tradizionale",
              "🔑 WebAuthn biometrico", 
              "🦊 Wallet Ethereum",
              "₿ Wallet Bitcoin",
              "⚡ Reattività con NoDom"
            ],
            timestamp: new Date().toISOString()
          });
        }, 500);
      });

    </script>
  </body>
</html> 