import { GunDB } from "./gun/gun";
import { EventEmitter } from "events";
import { ShogunStorage } from "./storage/storage";
import {
  IShogunCore,
  ShogunSDKConfig,
  AuthResult,
  SignUpResult,
  LoggingConfig,
  PluginCategory,
  CorePlugins,
} from "./types/shogun";
import { IGunInstance } from "gun/types";
import { log, logError, configureLogging, logWarn } from "./utils/logger";
import { ethers } from "ethers";
import {
  ErrorHandler,
  ErrorType,
  ShogunError,
  createError,
} from "./utils/errorHandler";
import { DIDCreateOptions } from "./types/did";
import { IGunUserInstance } from "gun";
import { GunRxJS } from "./gun/rxjs-integration";
import { Observable } from "rxjs";
import { ShogunPlugin } from "./types/plugin";
import { DIDPluginInterface } from "./plugins/did/types";
;

export {
  ShogunDID,
  DIDDocument,
  DIDResolutionResult,
  DIDCreateOptions,
} from "./plugins/did/DID";

export { ErrorHandler, ErrorType, ShogunError } from "./utils/errorHandler";

export { GunRxJS } from "./gun/rxjs-integration";

export * from "./plugins";
export { ShogunPlugin, PluginManager } from "./types/plugin";

export class ShogunCore implements IShogunCore {
  public gun: IGunInstance<any>;
  public user: IGunUserInstance<any> | null;
  public gundb: GunDB;
  public storage: ShogunStorage;
  private eventEmitter: EventEmitter;
  public provider?: ethers.Provider;
  public config: ShogunSDKConfig;
  public rx: GunRxJS; 

  private plugins: Map<string, ShogunPlugin> = new Map();

  /**
   * Initialize the Shogun SDK
   * @param config - SDK Configuration object
   * @description Creates a new instance of ShogunCore with the provided configuration.
   * Initializes all required components including storage, event emitter, GunDB connection,
   * and plugin system.
   */
  constructor(config: ShogunSDKConfig) {
    log("Initializing ShogunSDK");

    this.config = config;

    if (config.logging) {
      configureLogging(config.logging);
      log("Logging configured with custom settings");
    }

    this.storage = new ShogunStorage();
    this.eventEmitter = new EventEmitter();

    ErrorHandler.addListener((error: ShogunError) => {
      this.eventEmitter.emit("error", {
        action: error.code,
        message: error.message,
        type: error.type,
      });
    });

    if (!config.gundb) {
      config.gundb = {};
      log("No GunDB configuration provided, using defaults");
    }

    if (config.gundb.authToken) {
      const tokenPreview = config.gundb.authToken;
      log(`Auth token from config: ${tokenPreview}`);
    } else {
      log("No auth token in config");
    }

    const gundbConfig = {
      peers: config.gundb?.peers,
      websocket: config.gundb?.websocket ?? false,
      localStorage: config.gundb?.localStorage ?? false,
      radisk: config.gundb?.radisk ?? false,
      authToken: config.gundb?.authToken,
      multicast: config.gundb?.multicast ?? false,
      axe: config.gundb?.axe ?? false,
    };

    this.gundb = new GunDB(gundbConfig);
    this.gun = this.gundb.getGun();
    this.user = this.gun.user().recall({ sessionStorage: true });

    this.rx = new GunRxJS(this.gun);

    if (config.providerUrl) {
      this.provider = new ethers.JsonRpcProvider(config.providerUrl);
      log(`Using configured provider URL: ${config.providerUrl}`);
    } else {
      // Default provider (can be replaced as needed)
      this.provider = ethers.getDefaultProvider("mainnet");
      log(
        "WARNING: Using default Ethereum provider. For production use, configure a specific provider URL.",
      );
    }

    this.registerBuiltinPlugins(config);

    if (
      config.plugins?.autoRegister &&
      config.plugins.autoRegister.length > 0
    ) {
      for (const plugin of config.plugins.autoRegister) {
        try {
          this.register(plugin);
          log(`Auto-registered plugin: ${plugin.name}`);
        } catch (error) {
          logError(`Failed to auto-register plugin ${plugin.name}:`, error);
        }
      }
    }

    log("ShogunSDK initialized!");
  }

  /**
   * Registra i plugin integrati in base alla configurazione
   * @private
   */
  private registerBuiltinPlugins(config: ShogunSDKConfig): void {
    try {
      // Import dinamici per i plugin integrati
      const { WebauthnPlugin } = require("./plugins/webauthn/webauthnPlugin");
      const { MetaMaskPlugin } = require("./plugins/metamask/metamaskPlugin");
      const { StealthPlugin } = require("./plugins/stealth/stealthPlugin");
      const { DIDPlugin } = require("./plugins/did/didPlugin");
      const { WalletPlugin } = require("./plugins/wallet/walletPlugin");

      // Gruppo: Plugin di Autenticazione

      if (config.webauthn?.enabled) {
        const webauthnPlugin = new WebauthnPlugin();
        webauthnPlugin._category = PluginCategory.Authentication;
        this.register(webauthnPlugin);
        log("Webauthn plugin registered");
      }

      if (config.metamask?.enabled) {
        const metamaskPlugin = new MetaMaskPlugin();
        metamaskPlugin._category = PluginCategory.Authentication;
        this.register(metamaskPlugin);
        log("MetaMask plugin registered");
      }

      // Gruppo: Plugin di Privacy

      if (config.stealth?.enabled) {
        const stealthPlugin = new StealthPlugin();
        stealthPlugin._category = PluginCategory.Privacy;
        this.register(stealthPlugin);
        log("Stealth plugin registered");
      }

      // Gruppo: Plugin di Identità

      if (config.did?.enabled) {
        const didPlugin = new DIDPlugin();
        didPlugin._category = PluginCategory.Identity;
        this.register(didPlugin);
        log("DID plugin registered");
      }

      if (config.walletManager?.enabled) {
        const walletPlugin = new WalletPlugin();
        walletPlugin._category = PluginCategory.Wallet;
        this.register(walletPlugin);
        log("Wallet plugin registered");
      }
    } catch (error) {
      logError("Error registering builtin plugins:", error);
    }
  }

  // *********************************************************************************************************
  // 🔌 PLUGIN MANAGER 🔌
  // *********************************************************************************************************

  /**
   * Registra un nuovo plugin
   * @param plugin Il plugin da registrare
   */
  register(plugin: ShogunPlugin): void {
    if (this.plugins.has(plugin.name)) {
      throw new Error(`Plugin with name "${plugin.name}" already registered`);
    }

    plugin.initialize(this);
    this.plugins.set(plugin.name, plugin);
    log(`Registered plugin: ${plugin.name}`);
  }

  /**
   * Cancella la registrazione di un plugin
   * @param pluginName Nome del plugin da cancellare
   */
  unregister(pluginName: string): void {
    const plugin = this.plugins.get(pluginName);
    if (!plugin) {
      log(`Plugin "${pluginName}" not found, nothing to unregister`);
      return;
    }

    if (plugin.destroy) {
      plugin.destroy();
    }

    this.plugins.delete(pluginName);
    log(`Unregistered plugin: ${pluginName}`);
  }

  /**
   * Recupera un plugin registrato per nome
   * @param name Nome del plugin
   * @returns Il plugin richiesto o undefined se non trovato
   * @template T Tipo del plugin o dell'interfaccia pubblica del plugin
   */
  getPlugin<T>(name: string): T | undefined {
    return this.plugins.get(name) as T | undefined;
  }

  /**
   * Verifica se un plugin è registrato
   * @param name Nome del plugin da verificare
   * @returns true se il plugin è registrato, false altrimenti
   */
  hasPlugin(name: string): boolean {
    return this.plugins.has(name);
  }

  /**
   * Ottiene tutti i plugin di una determinata categoria
   * @param category Categoria di plugin da filtrare
   * @returns Array di plugin della categoria specificata
   */
  getPluginsByCategory(category: PluginCategory): ShogunPlugin[] {
    const result: ShogunPlugin[] = [];
    this.plugins.forEach((plugin) => {
      if (plugin._category === category) {
        result.push(plugin);
      }
    });
    return result;
  }

  // *********************************************************************************************************
  // 🔄 RXJS INTEGRATION 🔄
  // *********************************************************************************************************

  /**
   * Observe a Gun node for changes
   * @param path - Path to observe (can be a string or a Gun chain)
   * @returns Observable that emits whenever the node changes
   */
  observe<T>(path: string | any): Observable<T> {
    return this.rx.observe<T>(path);
  }

  /**
   * Match data based on Gun's '.map()' and convert to Observable
   * @param path - Path to the collection
   * @param matchFn - Optional function to filter results
   * @returns Observable array of matched items
   */
  match<T>(
    path: string | any,
    matchFn?: (data: any) => boolean,
  ): Observable<T[]> {
    return this.rx.match<T>(path, matchFn);
  }

  /**
   * Put data and return an Observable
   * @param path - Path where to put the data
   * @param data - Data to put
   * @returns Observable that completes when the put is acknowledged
   */
  rxPut<T>(path: string | any, data: T): Observable<T> {
    return this.rx.put<T>(path, data);
  }

  /**
   * Set data on a node and return an Observable
   * @param path - Path to the collection
   * @param data - Data to set
   * @returns Observable that completes when the set is acknowledged
   */
  rxSet<T>(path: string | any, data: T): Observable<T> {
    return this.rx.set<T>(path, data);
  }

  /**
   * Get data once and return as Observable
   * @param path - Path to get data from
   * @returns Observable that emits the data once
   */
  once<T>(path: string | any): Observable<T> {
    return this.rx.once<T>(path);
  }

  /**
   * Compute derived values from gun data
   * @param sources - Array of paths or observables to compute from
   * @param computeFn - Function that computes a new value from the sources
   * @returns Observable of computed values
   */
  compute<T, R>(
    sources: Array<string | Observable<any>>,
    computeFn: (...values: T[]) => R,
  ): Observable<R> {
    return this.rx.compute<T, R>(sources, computeFn);
  }

  /**
   * User put data and return an Observable (for authenticated users)
   * @param path - Path where to put the data
   * @param data - Data to put
   * @returns Observable that completes when the put is acknowledged
   */
  rxUserPut<T>(path: string, data: T): Observable<T> {
    return this.rx.userPut<T>(path, data);
  }

  /**
   * Observe user data
   * @param path - Path to observe in user space
   * @returns Observable that emits whenever the user data changes
   */
  observeUser<T>(path: string): Observable<T> {
    return this.rx.observeUser<T>(path);
  }

  // *********************************************************************************************************
  // 🔐 ERROR HANDLER 🔐
  // *********************************************************************************************************

  /**
   * Recupera gli errori recenti registrati dal sistema
   * @param count - Numero di errori da recuperare
   * @returns Lista degli errori più recenti
   */
  getRecentErrors(count: number = 10): ShogunError[] {
    return ErrorHandler.getRecentErrors(count);
  }

  // *********************************************************************************************************
  // 🔐 LOGGING 🔐
  // *********************************************************************************************************

  /**
   * Configure logging behavior for the Shogun SDK
   * @param {LoggingConfig} config - Logging configuration object containing:
   *   - level: The minimum log level to display (error, warn, info, debug, trace)
   *   - logToConsole: Whether to output logs to the console (default: true)
   *   - customLogger: Optional custom logger implementation
   *   - logTimestamps: Whether to include timestamps in logs (default: true)
   * @returns {void}
   * @description Updates the logging configuration for the SDK. Changes take effect immediately
   * for all subsequent log operations.
   */
  configureLogging(config: LoggingConfig): void {
    configureLogging(config);
    log("Logging reconfigured with new settings");
  }

  // *********************************************************************************************************
  // 🔐 AUTHENTICATION
  // *********************************************************************************************************

  /**
   * Check if user is logged in
   * @returns {boolean} True if user is logged in, false otherwise
   * @description Verifies authentication status by checking GunDB login state
   * and presence of authentication credentials in storage
   */
  isLoggedIn(): boolean {
    const gunLoggedIn = this.gundb.isLoggedIn();
    const gunUser = this.gun.user();

    if (gunLoggedIn) {
      return true;
    }

    // @ts-ignore - Accessing internal Gun property that is not fully typed
    const hasPair = gunUser && gunUser._ && gunUser._.sea;
    const hasLocalPair = this.storage.getItem("pair");

    return !!hasPair || !!hasLocalPair;
  }

  /**
   * Perform user logout
   * @description Logs out the current user from GunDB and emits logout event.
   * If user is not authenticated, the logout operation is ignored.
   */
  logout(): void {
    try {
      if (!this.isLoggedIn()) {
        log("Logout ignored: user not authenticated");
        return;
      }

      this.gundb.logout();
      this.eventEmitter.emit("auth:logout", {});
      log("Logout completed successfully");
    } catch (error) {
      // Usa il gestore errori centralizzato
      ErrorHandler.handle(
        ErrorType.AUTHENTICATION,
        "LOGOUT_FAILED",
        error instanceof Error ? error.message : "Error during logout",
        error,
      );
    }
  }

  /**
   * Authenticate user with username and password
   * @param username - Username
   * @param password - User password
   * @returns {Promise<AuthResult>} Promise with authentication result
   * @description Attempts to log in user with provided credentials.
   * Emits login event on success.
   */
  async login(username: string, password: string): Promise<AuthResult> {
    log("Login");
    try {
      log(`Login attempt for user: ${username}`);

      // Verify parameters
      if (!username || !password) {
        return {
          success: false,
          error: "Username and password are required",
        };
      }

      const loginPromise = new Promise<AuthResult>((resolve) => {
        this.gundb.gun.user().auth(username, password, (ack: any) => {
          if (ack.err) {
            log(`Login error: ${ack.err}`);
            resolve({
              success: false,
              error: ack.err,
            });
          } else {
            const user = this.gundb.gun.user();
            if (!user.is) {
              resolve({
                success: false,
                error: "Login failed: user not authenticated",
              });
            } else {
              log("Login completed successfully");
              const userPub = user.is?.pub || "";
              resolve({
                success: true,
                userPub,
                username,
              });
            }
          }
        });
      });

      // Timeout dopo un intervallo configurabile (default 15 secondi)
      const timeoutDuration = this.config?.timeouts?.login || 15000;
      const timeoutPromise = new Promise<AuthResult>((resolve) => {
        setTimeout(() => {
          resolve({
            success: false,
            error: "Login timeout",
          });
        }, timeoutDuration);
      });

      const result = await Promise.race([loginPromise, timeoutPromise]);

      if (result.success) {
        this.eventEmitter.emit("auth:login", {
          userPub: result.userPub || "",
        });

        try {
          const did = await this.ensureUserHasDID();
          if (did) {
            result.did = did;
          }
        } catch (didError) {
          logError("Error ensuring DID after login:", didError);
        }
      }

      return result;
    } catch (error: any) {
      ErrorHandler.handle(
        ErrorType.AUTHENTICATION,
        "LOGIN_FAILED",
        error.message || "Unknown error during login",
        error,
      );

      return {
        success: false,
        error: error.message || "Unknown error during login",
      };
    }
  }

  /**
   * Register a new user with provided credentials
   * @param username - Username
   * @param password - Password
   * @param passwordConfirmation - Password confirmation
   * @returns {Promise<SignUpResult>} Registration result
   * @description Creates a new user account with the provided credentials.
   * Validates password requirements and emits signup event on success.
   */
  async signUp(
    username: string,
    password: string,
    passwordConfirmation?: string,
  ): Promise<SignUpResult> {
    log("Sign up");
    try {
      if (!username || !password) {
        return {
          success: false,
          error: "Username and password are required",
        };
      }

      if (
        passwordConfirmation !== undefined &&
        password !== passwordConfirmation
      ) {
        return {
          success: false,
          error: "Passwords do not match",
        };
      }

      if (password.length < 6) {
        return {
          success: false,
          error: "Password must be at least 6 characters long",
        };
      }

      const signupPromise = new Promise<SignUpResult>((resolve) => {
        this.gundb.gun.user().create(username, password, (ack: any) => {
          if (ack.err) {
            resolve({
              success: false,
              error: ack.err,
            });
          } else {
            this.gundb.gun.user().auth(username, password, (loginAck: any) => {
              if (loginAck.err) {
                resolve({
                  success: false,
                  error: "Registration completed but login failed",
                });
              } else {
                const user = this.gundb.gun.user();
                if (!user.is) {
                  resolve({
                    success: false,
                    error: "Registration completed but user not authenticated",
                  });
                } else {
                  resolve({
                    success: true,
                    userPub: user.is?.pub || "",
                    username: username || "",
                  });
                }
              }
            });
          }
        });
      });

      const timeoutDuration = this.config?.timeouts?.signup || 20000;
      const timeoutPromise = new Promise<SignUpResult>((resolve) => {
        setTimeout(() => {
          resolve({
            success: false,
            error: "Registration timeout",
          });
        }, timeoutDuration);
      });

      // Use Promise.race to handle timeout
      const result = await Promise.race([signupPromise, timeoutPromise]);

      if (result.success) {
        this.eventEmitter.emit("auth:signup", {
          userPub: result.userPub || "",
          username,
        });

        try {
          const did = await this.ensureUserHasDID();

          if (did) {
            log(`Created DID for new user: ${did}`);

            result.did = did;
          }
        } catch (didError) {
          logError("Error creating DID for new user:", didError);
        }
      }

      return result;
    } catch (error: any) {
      logError(`Error during registration for user ${username}:`, error);
      return {
        success: false,
        error: error.message || "Unknown error during registration",
      };
    }
  }

  // *********************************************************************************************************
  // 🔐 WEBAUTHN AUTHENTICATION
  // *********************************************************************************************************

  /**
   * Check if WebAuthn is supported by the browser
   * @returns {boolean} True if WebAuthn is supported, false otherwise
   * @description Verifies if the current browser environment supports WebAuthn authentication
   */
  isWebAuthnSupported(): boolean {
    const webauthnPlugin = this.getPlugin<any>("webauthn");
    return webauthnPlugin?.isSupported() || false;
  }

  /**
   * Perform WebAuthn login
   * @param username - Username
   * @returns {Promise<AuthResult>} Authentication result
   * @description Authenticates user using WebAuthn credentials.
   * Requires browser support for WebAuthn and existing credentials.
   */
  async loginWithWebAuthn(username: string): Promise<AuthResult> {
    log("Login with WebAuthn");

    try {
      log(`Attempting WebAuthn login for user: ${username}`);

      if (!username) {
        throw new Error("Username required for WebAuthn login");
      }

      if (!this.isWebAuthnSupported()) {
        throw new Error("WebAuthn is not supported by this browser");
      }

      const webauthnPlugin = this.getPlugin<any>("webauthn");
      if (!webauthnPlugin) {
        throw new Error("WebAuthn plugin not available");
      }

      const assertionResult = await webauthnPlugin.generateCredentials(
        username,
        null,
        true,
      );

      if (!assertionResult?.success) {
        throw new Error(
          assertionResult?.error || "WebAuthn verification failed",
        );
      }

      const hashedCredentialId = ethers.keccak256(
        ethers.toUtf8Bytes(assertionResult.credentialId || ""),
      );

      const result = await this.login(username, hashedCredentialId);

      if (result.success) {
        log(`WebAuthn login completed successfully for user: ${username}`);

        if (!result.did) {
          try {
            const did = await this.ensureUserHasDID();
            if (did) {
              result.did = did;
            }
          } catch (didError) {
            logError("Error ensuring DID for WebAuthn user:", didError);
          }
        }

        return {
          ...result,
          username,
          password: hashedCredentialId,
          credentialId: assertionResult.credentialId,
        };
      } else {
        return result;
      }
    } catch (error: any) {
      logError(`Error during WebAuthn login: ${error}`);
      return {
        success: false,
        error: error.message || "Error during WebAuthn login",
      };
    }
  }

  /**
   * Register new user with WebAuthn
   * @param username - Username
   * @returns {Promise<AuthResult>} Registration result
   * @description Creates a new user account using WebAuthn credentials.
   * Requires browser support for WebAuthn.
   */
  async signUpWithWebAuthn(username: string): Promise<AuthResult> {
    log("Sign up with WebAuthn");

    try {
      log(`Attempting WebAuthn registration for user: ${username}`);

      if (!username) {
        throw new Error("Username required for WebAuthn registration");
      }

      if (!this.isWebAuthnSupported()) {
        throw new Error("WebAuthn is not supported by this browser");
      }

      const webauthnPlugin = this.getPlugin<any>("webauthn");
      if (!webauthnPlugin) {
        throw new Error("WebAuthn plugin not available");
      }

      const attestationResult = await webauthnPlugin.generateCredentials(
        username,
        null,
        false,
      );

      if (!attestationResult?.success) {
        throw new Error(
          attestationResult?.error || "Unable to generate WebAuthn credentials",
        );
      }

      const hashedCredentialId = ethers.keccak256(
        ethers.toUtf8Bytes(attestationResult.credentialId || ""),
      );

      const result = await this.signUp(username, hashedCredentialId);

      if (result.success) {
        log(
          `WebAuthn registration completed successfully for user: ${username}`,
        );

        if (!result.did) {
          try {
            const did = await this.ensureUserHasDID({
              services: [
                {
                  type: "WebAuthnVerification",
                  endpoint: `webauthn:${username}`,
                },
              ],
            });

            if (did) {
              result.did = did;
            }
          } catch (didError) {
            logError("Error creating DID for WebAuthn user:", didError);
          }
        }

        return {
          ...result,
          username,
          password: hashedCredentialId,
          credentialId: attestationResult.credentialId,
        };
      } else {
        return result;
      }
    } catch (error: any) {
      logError(`Error during WebAuthn registration: ${error}`);
      return {
        success: false,
        error: error.message || "Error during WebAuthn registration",
      };
    }
  }

  // *********************************************************************************************************
  // 🔐 METAMASK AUTHENTICATION
  // *********************************************************************************************************

  /**
   * Login with MetaMask
   * @param address - Ethereum address
   * @returns {Promise<AuthResult>} Authentication result
   * @description Authenticates user using MetaMask wallet credentials after signature verification
   */
  async loginWithMetaMask(address: string): Promise<AuthResult> {
    log("Login with MetaMask");

    try {
      log(`MetaMask login attempt for address: ${address}`);

      if (!address) {
        throw createError(
          ErrorType.VALIDATION,
          "ADDRESS_REQUIRED",
          "Ethereum address required for MetaMask login",
        );
      }

      const metamaskPlugin = this.getPlugin<any>("metamask");
      if (!metamaskPlugin) {
        throw createError(
          ErrorType.PLUGIN,
          "PLUGIN_NOT_AVAILABLE",
          "MetaMask plugin not available",
        );
      }

      if (!metamaskPlugin.isAvailable()) {
        throw createError(
          ErrorType.ENVIRONMENT,
          "METAMASK_UNAVAILABLE",
          "MetaMask is not available in the browser",
        );
      }

      log("Generating credentials for MetaMask login...");
      const credentials = await metamaskPlugin.generateCredentials(address);
      if (
        !credentials?.username ||
        !credentials?.password ||
        !credentials.signature ||
        !credentials.message
      ) {
        throw createError(
          ErrorType.AUTHENTICATION,
          "CREDENTIAL_GENERATION_FAILED",
          "MetaMask credentials not generated correctly or signature missing",
        );
      }

      log(
        `Credentials generated successfully. Username: ${credentials.username}`,
      );

      log("Verifying MetaMask signature...");
      const recoveredAddress = ethers.verifyMessage(
        credentials.message,
        credentials.signature,
      );
      if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
        logError(
          `Signature verification failed. Expected: ${address}, Got: ${recoveredAddress}`,
        );
        throw createError(
          ErrorType.SECURITY,
          "SIGNATURE_VERIFICATION_FAILED",
          "MetaMask signature verification failed. Address mismatch.",
        );
      }
      log("MetaMask signature verified successfully.");

      log("Attempting login or user creation with verified credentials...");
      const result = await this.createUserWithGunDB(
        credentials.username,
        credentials.password,
      );

      if (!result.success || !result.userPub) {
        throw createError(
          ErrorType.AUTHENTICATION,
          "LOGIN_CREATE_FAILED",
          result.error ||
            "Login or user creation failed after signature verification",
        );
      }

      log(`Login/Creation successful: ${result.userPub}`);

      let did: string | null = null;
      try {
        log("Ensuring user has a DID...");
        did = await this.ensureUserHasDID({
          services: [
            {
              type: "EcdsaSecp256k1VerificationKey2019", // Tipo più specifico
              endpoint: `ethereum:${address}`,
            },
          ],
        });
        if (did) {
          log(`DID assigned/verified: ${did}`);
        } else {
          logWarn("Could not ensure DID for user after MetaMask login.");
        }
      } catch (didError) {
        ErrorHandler.handle(
          ErrorType.DID,
          "DID_ENSURE_FAILED",
          "Error ensuring DID for MetaMask user",
          didError,
        );
      }

      this.eventEmitter.emit("auth:login", {
        userPub: result.userPub,
        username: credentials.username,
        method: "metamask",
        did: did || undefined,
      });

      return {
        success: true,
        userPub: result.userPub,
        username: credentials.username,
        password: "********", 
        did: did || undefined,
      };
    } catch (error: any) {
      // Cattura sia errori conformi a ShogunError che generici
      const errorType = error?.type || ErrorType.AUTHENTICATION;
      const errorCode = error?.code || "METAMASK_LOGIN_ERROR";
      const errorMessage =
        error?.message || "Unknown error during MetaMask login";

      const handledError = ErrorHandler.handle(
        errorType,
        errorCode,
        errorMessage,
        error,
      );

      return {
        success: false,
        error: handledError.message, // Ora handledError è ShogunError e ha .message
      };
    }
  }

  /**
   * Register new user with MetaMask
   * @param address - Ethereum address
   * @returns {Promise<AuthResult>} Registration result
   * @description Creates a new user account using MetaMask wallet credentials after signature verification
   */
  async signUpWithMetaMask(address: string): Promise<AuthResult> {
    log("Sign up with MetaMask");

    try {
      log(`MetaMask registration attempt for address: ${address}`);

      if (!address) {
        throw createError(
          ErrorType.VALIDATION,
          "ADDRESS_REQUIRED",
          "Ethereum address required for MetaMask registration",
        );
      }

      const metamaskPlugin = this.getPlugin<any>("metamask");
      if (!metamaskPlugin) {
        throw createError(
          ErrorType.PLUGIN,
          "PLUGIN_NOT_AVAILABLE",
          "MetaMask plugin not available",
        );
      }

      if (!metamaskPlugin.isAvailable()) {
        throw createError(
          ErrorType.ENVIRONMENT,
          "METAMASK_UNAVAILABLE",
          "MetaMask is not available in the browser",
        );
      }

      log("Generating credentials for MetaMask registration...");
      const credentials = await metamaskPlugin.generateCredentials(address);
      if (
        !credentials?.username ||
        !credentials?.password ||
        !credentials.signature ||
        !credentials.message
      ) {
        throw createError(
          ErrorType.AUTHENTICATION,
          "CREDENTIAL_GENERATION_FAILED",
          "MetaMask credentials not generated correctly or signature missing",
        );
      }

      log(
        `Credentials generated successfully. Username: ${credentials.username}`,
      );

      log("Verifying MetaMask signature...");
      const recoveredAddress = ethers.verifyMessage(
        credentials.message,
        credentials.signature,
      );
      if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
        logError(
          `Signature verification failed. Expected: ${address}, Got: ${recoveredAddress}`,
        );
        throw createError(
          ErrorType.SECURITY,
          "SIGNATURE_VERIFICATION_FAILED",
          "MetaMask signature verification failed. Address mismatch.",
        );
      }
      log("MetaMask signature verified successfully.");
      // --- Fine Verifica Firma ---

      log(
        "Attempting user creation (or login if exists) with verified credentials...",
      );
      const result = await this.createUserWithGunDB(
        credentials.username,
        credentials.password,
      );

      if (!result.success || !result.userPub) {
        throw createError(
          ErrorType.AUTHENTICATION,
          "USER_CREATE_LOGIN_FAILED",
          result.error ||
            "User creation or login failed after signature verification",
        );
      }

      log(`User creation/login successful: ${result.userPub}`);

      let did: string | null = null;
      try {
        log("Creating/Ensuring DID with MetaMask verification service...");
        did = await this.ensureUserHasDID({
          services: [
            {
              type: "EcdsaSecp256k1VerificationKey2019", // Tipo più specifico
              endpoint: `ethereum:${address}`,
            },
          ],
        });
        if (did) {
          log(`DID created/verified: ${did}`);
        } else {
          logWarn("Could not ensure DID for user after MetaMask signup.");
        }
      } catch (didError) {
        ErrorHandler.handle(
          ErrorType.DID,
          "DID_ENSURE_FAILED",
          "Error ensuring DID for MetaMask user during signup",
          didError,
        );
      }

      // Emettiamo un evento di registrazione (o login se l'utente esisteva già)
      this.eventEmitter.emit("auth:signup", {
        // Potrebbe essere logico emettere "auth:login" se l'utente esisteva già?
        userPub: result.userPub,
        username: credentials.username,
        method: "metamask",
        did: did || undefined,
      });

      return {
        success: true,
        userPub: result.userPub,
        username: credentials.username,
        password: credentials.password, // Potrebbe non essere sicuro restituirlo
        did: did || undefined,
      };
    } catch (error: any) {
      // Cattura sia errori conformi a ShogunError che generici
      const errorType = error?.type || ErrorType.AUTHENTICATION;
      const errorCode = error?.code || "METAMASK_SIGNUP_ERROR";
      const errorMessage =
        error?.message || "Unknown error during MetaMask registration";

      const handledError = ErrorHandler.handle(
        errorType,
        errorCode,
        errorMessage,
        error,
      );

      return {
        success: false,
        error: handledError.message, // Ora handledError è ShogunError e ha .message
      };
    }
  }

  // *********************************************************************************************************
  // 🤫 PRIVATE HELPER METHODS 🤫
  // *********************************************************************************************************

  /**
   * Ensure the current user has a DID associated, creating one if needed
   * @param {DIDCreateOptions} [options] - Optional configuration for DID creation including:
   *   - network: The network to use (default: 'main')
   *   - controller: The controller of the DID (default: user's public key)
   *   - services: Array of service definitions to add to the DID document
   * @returns {Promise<string|null>} The DID identifier string or null if operation fails
   * @description Checks if the authenticated user already has a DID. If not, creates a new one.
   * If the user already has a DID and options are provided, updates the DID document accordingly.
   * @private
   */
  private async ensureUserHasDID(
    options?: DIDCreateOptions,
  ): Promise<string | null> {
    try {
      const didPlugin = this.getPlugin<DIDPluginInterface>("did");

      if (!didPlugin) {
        log("DID plugin not available, cannot ensure DID");
        return null;
      }

      return await didPlugin.ensureUserHasDID(options);
    } catch (error) {
      logError("Error ensuring user has DID:", error);
      return null;
    }
  }

  /**
   * Create a new user with GunDB
   * @param username - Username
   * @param password - Password
   * @returns {Promise<{success: boolean, userPub?: string, error?: string}>} Promise with success status and user public key
   * @description Creates a new user in GunDB with error handling
   */
  private createUserWithGunDB(
    username: string,
    password: string,
  ): Promise<{ success: boolean; userPub?: string; error?: string }> {
    log(`Ensuring user exists with GunDB: ${username}`);

    return new Promise(async (resolve) => {
      try {
        const authUser = (): Promise<{ err?: string; pub?: string }> => {
          return new Promise((resolveAuth) => {
            try {
              this.gundb.logout();
            } catch (e) {
              /* ignore logout errors */
            }

            this.gundb.gun.user().auth(username, password, (ack: any) => {
              if (ack.err) {
                resolveAuth({ err: ack.err });
              } else {
                const user = this.gundb.gun.user();
                const userPub = user.is?.pub || "";
                if (!user.is || !userPub) {
                  resolveAuth({
                    err: "Authentication failed after apparent success.",
                  });
                } else {
                  resolveAuth({ pub: userPub });
                }
              }
            });
          });
        };

        const createUser = (): Promise<{ err?: string; pub?: string }> => {
          return new Promise((resolveCreate) => {
            try {
              this.gundb.logout();
            } catch (e) {
              /* ignore logout errors */
            }

            this.gundb.gun.user().create(username, password, (ack: any) => {
              resolveCreate({ err: ack.err, pub: ack.pub }); // pub might be present on success
            });
          });
        };

        log(`Attempting login first for ${username}...`);
        let loginResult = await authUser();

        if (loginResult.pub) {
          log(`Login successful for existing user. Pub: ${loginResult.pub}`);
          resolve({
            success: true,
            userPub: loginResult.pub,
          });
          return;
        }

        log(
          `Login failed (${loginResult.err || "unknown reason"}), attempting user creation...`,
        );
        const createResult = await createUser();

        if (createResult.err) {
          log(`User creation error: ${createResult.err}`);
          resolve({
            success: false,
            error: `User creation failed: ${createResult.err}`,
          });
          return;
        }

        log(
          `User created successfully, attempting login again for confirmation...`,
        );
        loginResult = await authUser();

        if (loginResult.pub) {
          log(`Post-creation login successful! User pub: ${loginResult.pub}`);
          resolve({
            success: true,
            userPub: loginResult.pub,
          });
        } else {
          logError(
            `Post-creation login failed unexpectedly: ${loginResult.err}`,
          );
          resolve({
            success: false,
            error: `User created, but subsequent login failed: ${loginResult.err}`,
          });
        }
      } catch (error: any) {
        const errorMsg =
          error.message || "Unknown error during user existence check";
        logError(`Error in createUserWithGunDB: ${errorMsg}`, error);
        resolve({
          success: false,
          error: errorMsg,
        });
      }
    });
  }

  // *********************************************************************************************************
  // 🔫 GuN ACTIONS 🔫
  // *********************************************************************************************************

  /**
   * Retrieves data from a Gun node at the specified path
   * @param path - The path to the Gun node
   * @returns Promise that resolves with the node data or rejects with an error
   */
  get(path: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.gundb.gun.get(path).once((data) => {
        if (data.err) {
          reject(data.err);
        } else {
          resolve(data);
        }
      });
    });
  }

  /**
   * Stores data in Gun at the root level
   * @param data - The data to store
   * @returns Promise that resolves when data is stored or rejects with an error
   */
  put(data: Record<string, any>): Promise<any> {
    return new Promise((resolve, reject) => {
      this.gundb.gun.put(data, (ack: any) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve(ack);
        }
      });
    });
  }

  /**
   * Stores data in the authenticated user's space
   * @param data - The data to store in user space
   * @returns Promise that resolves when data is stored or rejects with an error
   */
  userPut(data: Record<string, any>): Promise<any> {
    return new Promise((resolve, reject) => {
      this.gundb.gun.user().put(data, (ack: any) => {
        if (ack.err) {
          reject(ack.err);
        } else {
          resolve(ack);
        }
      });
    });
  }

  /**
   * Retrieves data from the authenticated user's space at the specified path
   * @param path - The path to the user data
   * @returns Promise that resolves with the user data or rejects with an error
   */
  userGet(path: string): Promise<any> {
    return new Promise((resolve, reject) => {
      this.gundb.gun
        .user()
        .get(path)
        .once((data) => {
          if (data.err) {
            reject(data.err);
          } else {
            resolve(data);
          }
        });
    });
  }

  // *********************************************************************************************************
  // 🔌 PROVIDER 🔌
  // *********************************************************************************************************

  /**
   * Set the RPC URL used for Ethereum network connections
   * @param rpcUrl The RPC provider URL to use
   * @returns True if the URL was successfully set
   */
  setRpcUrl(rpcUrl: string): boolean {
    try {
      if (!rpcUrl) {
        log("Invalid RPC URL provided");
        return false;
      }

      // Update the provider if it's already initialized
      this.provider = new ethers.JsonRpcProvider(rpcUrl);

      log(`RPC URL updated to: ${rpcUrl}`);
      return true;
    } catch (error) {
      logError("Failed to set RPC URL", error);
      return false;
    }
  }

  /**
   * Get the currently configured RPC URL
   * @returns The current provider URL or null if not set
   */
  getRpcUrl(): string | null {
    // Access the provider URL if available
    return this.provider instanceof ethers.JsonRpcProvider
      ? (this.provider as any).connection?.url || null
      : null;
  }

  /**
   * Get the main wallet for the authenticated user
   * @returns The user's main Ethereum wallet or null if not available
   * @deprecated Use getPlugin(CorePlugins.WalletManager).getMainWallet() instead
   */
  getMainWallet(): ethers.Wallet | null {
    const walletPlugin = this.getPlugin<any>(CorePlugins.WalletManager);
    if (walletPlugin && typeof walletPlugin.getMainWallet === "function") {
      return walletPlugin.getMainWallet();
    }
    return null;
  }

  // *********************************************************************************************************
  // 📢 EVENT EMITTER 📢
  // *********************************************************************************************************

  /**
   * Emits an event through the core's event emitter.
   * Plugins should use this method to emit events instead of accessing the private eventEmitter directly.
   * @param eventName The name of the event to emit.
   * @param data The data to pass with the event.
   */
  emit(eventName: string | symbol, ...args: any[]): boolean {
    return this.eventEmitter.emit(eventName, ...args);
  }
}

// Export all types
export * from "./types/shogun";

// Export classes
export { GunDB } from "./gun/gun";
export { MetaMask } from "./plugins/metamask/metamask";
export { Stealth } from "./plugins/stealth/stealth";
export {
  EphemeralKeyPair,
  StealthData,
  StealthAddressResult,
  LogLevel,
  LogMessage,
} from "./types/stealth";
export { Webauthn } from "./plugins/webauthn/webauthn";
export { ShogunStorage } from "./storage/storage";
export { ShogunEventEmitter } from "./events";
