<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Shogun Social</title>

    <!-- Script anti-refresh immediato prima di qualsiasi altro script -->
    <script>
        (function () {
            // Blocca il comportamento submit di tutti i form in modo aggressivo
            document.addEventListener('submit', function (e) {
                console.log('INTERCETTATO SUBMIT DI FORM', e.target);
                e.preventDefault();
                e.stopPropagation();
                return false;
            }, true);  // true = useCapture, intercetta l'evento nella fase di capturing

            // Blocca il comportamento default di Enter su input
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                    if (e.target.classList.contains('comment-input') ||
                        (e.target.type !== 'textarea' && !e.target.classList.contains('enter-allowed'))) {
                        console.log('INTERCETTATO ENTER KEY SU INPUT', e.target);
                        e.preventDefault();
                        e.stopPropagation();

                        // Se è un campo di commento, tenta di inviare il commento
                        if (e.target.classList.contains('comment-input')) {
                            const submitBtn = e.target.closest('.comment-form')?.querySelector('.submit-comment');
                            if (submitBtn) {
                                setTimeout(() => submitBtn.click(), 10);
                            }
                        }
                        return false;
                    }
                }
            }, true);  // true = useCapture, intercetta l'evento nella fase di capturing

            // Blocca anche eventi click che potrebbero causare invio di form
            document.addEventListener('click', function (e) {
                if (e.target.tagName === 'BUTTON' && e.target.type !== 'button') {
                    // Se un pulsante non ha type="button", intercettiamo e preveniamo il comportamento di default
                    console.log('INTERCETTATO CLICK SU BUTTON NON-TYPE-BUTTON', e.target);
                    e.preventDefault();
                    e.stopPropagation();

                    // Forza il tipo del pulsante come "button"
                    e.target.type = 'button';
                    return false;
                }
            }, true);  // true = useCapture, intercetta l'evento nella fase di capturing

            // Quando il DOM è completamente caricato
            window.addEventListener('DOMContentLoaded', function () {
                console.log('DOM caricato, applicazione patch anti-refresh');

                // Imposta type="button" per tutti i pulsanti di submit nei form
                document.querySelectorAll('form button:not([type])').forEach(button => {
                    button.type = 'button';
                    console.log('Forzato type="button" su:', button);
                });

                // Assicura che tutti i form abbiano onsubmit="return false"
                document.querySelectorAll('form:not([onsubmit])').forEach(form => {
                    form.onsubmit = function (e) {
                        e.preventDefault();
                        return false;
                    };
                    console.log('Forzato onsubmit="return false" su:', form);
                });

                // Aggiungi un indicatore quando il refresh è prevenuto
                const indicator = document.createElement('div');
                indicator.id = 'noRefreshIndicator';
                indicator.className = 'no-refresh-indicator';
                indicator.textContent = 'Azione eseguita senza refresh';
                document.body.appendChild(indicator);
            });
        })();
    </script>

    <link rel="stylesheet" href="shogun.css">
</head>

<body>
    <div class="container">
        <div class="app-header">
            <div class="app-title">Shogun Social</div>
            <div id="currentUserInfo" class="current-user" style="display: none;">
                <strong></strong>
            </div>
        </div>

        <div class="app-tabs">
            <button type="button" class="tab-button active" data-tab="timeline">Timeline</button>
            <button type="button" class="tab-button" data-tab="myPosts">Miei Post</button>
            <button type="button" class="tab-button" data-tab="profile">Profilo</button>
        </div>

        <div class="action-group">
            <button id="initBtn" type="button" class="primary-button">Inizializza</button>
            <button id="loginBtn" type="button" disabled class="login-button">Accedi</button>
            <div id="loginForm" style="display:none;">
                <form onsubmit="return false;">
                    <div class="form-group">
                        <label for="username">Username</label>
                        <input type="text" id="username" placeholder="Inserisci username" autocomplete="username">
                    </div>
                    <div class="form-group">
                        <label for="password">Password</label>
                        <input type="password" id="password" placeholder="Inserisci password"
                            autocomplete="current-password">
                    </div>
                    <button type="button" id="performLoginBtn">Accedi</button>
                </form>
            </div>
        </div>

        <!-- Contenuti dei tab -->
        <div id="timeline-tab" class="tab-content active">
            <div class="post-composer" style="display: none;" id="postComposer">
                <div class="composer-header">
                    <span>Nuovo post</span>
                </div>
                <textarea id="postContent" placeholder="A cosa stai pensando?"></textarea>
                <div class="composer-footer">
                    <button type="button" id="createPostBtn" disabled>Pubblica</button>
                </div>
            </div>

            <div class="timeline-actions" style="display: none;" id="timelineActions">
                <button type="button" id="getTimelineBtn">
                    <span class="button-icon">🔄</span>
                    Aggiorna
                </button>
            </div>

            <div id="timelineContainer" class="timeline"></div>
        </div>

        <div id="myPosts-tab" class="tab-content">
            <div class="timeline-section">
                <div class="section-header">I miei post</div>
                <div id="myPostsContainer" class="posts-container"></div>
            </div>
        </div>

        <div id="profile-tab" class="tab-content">
            <div class="action-group" id="profileSection">
                <h2>Profilo</h2>
                <div class="search-profile">
                    <input type="text" id="userPubInput" placeholder="Chiave pubblica utente">
                    <button type="button" id="getProfileBtn" disabled>Visualizza</button>
                </div>
                <div id="profileContainer"></div>
            </div>

            <div class="users-section" id="usersSection" style="display: none;">
                <h2>Utenti sulla rete</h2>
                <button type="button" id="loadUsersBtn">
                    <span class="button-icon">👥</span>
                    Carica utenti
                </button>
                <div class="users-list" id="usersList"></div>
            </div>
        </div>

        <div id="results" style="display: none;">I risultati appariranno qui...</div>
    </div>

    <!-- Aggiungi indicatore no-refresh -->
    <div id="noRefreshIndicator" class="no-refresh-indicator">Azione eseguita senza refresh</div>

    <script src="../../dist/browser/shogun-core.js" defer></script>
    <script>
        // Funzione di utilità per sanitizzare l'HTML
        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Funzione per rendere i pulsanti più minimali
        function shortenButtonLabels() {
            // Abbrevia i testi dei pulsanti
            document.querySelectorAll('.unfollow-user').forEach(btn => {
                btn.textContent = 'Smetti';
            });

            document.querySelectorAll('#btnUnfollow').forEach(btn => {
                btn.textContent = 'Smetti';
            });

            document.querySelectorAll('.view-profile, .view-profile-btn').forEach(btn => {
                btn.textContent = 'Profilo';
            });
        }

        // Prevenzione globale di submit e click problematici
        document.addEventListener('click', function (e) {
            // Prevenire il comportamento di default per tutti i pulsanti che potrebbero causare refresh
            if (e.target.tagName === 'BUTTON' && e.target.type !== 'button') {
                e.preventDefault();
                console.log("Prevented default for button:", e.target);
            }

            // Previeni il comportamento di default per tutti i pulsanti di submit nei form
            if (e.target.tagName === 'BUTTON' && e.target.type === 'submit') {
                e.preventDefault();
                console.log("Prevented form submission via button click");
            }

            // Previeni il comportamento di default per i pulsanti di invio commento
            if (e.target.classList.contains('submit-comment')) {
                e.preventDefault();
                console.log("Prevented default for submit comment button");
            }
        });

        // Prevenire il refresh su invio nei form
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                // Non prevenire Enter in textarea se non è Ctrl+Enter
                if (e.target.tagName === 'TEXTAREA' && !e.ctrlKey) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                console.log("Prevented Enter key submission:", e.target);

                // Controlla se è un campo di commento
                if (e.target.classList.contains('comment-input')) {
                    console.log("Enter in comment field - triggering submit");
                    const submitBtn = e.target.closest('.comment-form').querySelector('.submit-comment');
                    if (submitBtn) {
                        submitBtn.click();
                    }
                }
            }
        });

        // Preveniamo il comportamento di default su tutti i form
        document.addEventListener('submit', function (e) {
            e.preventDefault();
            e.stopPropagation();
            console.log("Prevented form submission:", e.target);
            return false;
        });

        // Controlliamo esplicitamente lo stato del pulsante al caricamento
        window.addEventListener('DOMContentLoaded', function () {
            console.log("DOM completamente caricato, verifica elementi critici:");

            // Verifica i pulsanti critici
            const loginBtnCheck = document.getElementById('loginBtn');
            console.log("loginBtn:", loginBtnCheck ? "trovato" : "NON trovato");

            const performLoginCheck = document.getElementById('performLoginBtn');
            console.log("performLoginBtn:", performLoginCheck ? "trovato" : "NON trovato");

            if (performLoginCheck) {
                console.log("Configurazione listener pulsante login...");

                // Aggiungi debug inline
                performLoginCheck.onclick = function (e) {
                    e.preventDefault(); // Esplicitamente previene il comportamento di default
                    console.log("Click diretto sul pulsante di login rilevato");
                    performLoginHandler();
                };

                // Aggiungi un attributo data per debugging
                performLoginCheck.setAttribute('data-debug', 'listener-attivo');
                performLoginCheck.style.cursor = 'pointer';

                // Test visual feedback
                performLoginCheck.addEventListener('mouseover', function () {
                    this.style.opacity = '0.9';
                });
                performLoginCheck.addEventListener('mouseout', function () {
                    this.style.opacity = '1';
                });
            }

            // Avvia il processo di abbreviazione dei pulsanti
            shortenButtonLabels();

            // Ripeti periodicamente per gestire i pulsanti aggiunti dinamicamente
            setInterval(shortenButtonLabels, 2000);
        });

        // Polyfill (se serve)
        if (!crypto.randomUUID) {
            crypto.randomUUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => ((Math.random() * 16 | 0) & (c == 'x' ? 1 : 3) | 8).toString(16));
        }

        // DOM refs
        const initBtn = document.getElementById('initBtn');
        const loginBtn = document.getElementById('loginBtn');
        const loginForm = document.getElementById('loginForm');
        const performLogin = document.getElementById('performLoginBtn');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');

        const userPubInput = document.getElementById('userPubInput');
        const getProfileBtn = document.getElementById('getProfileBtn');
        const profileDiv = document.getElementById('profileContainer');

        const postComposer = document.getElementById('postComposer');
        const postContent = document.getElementById('postContent');
        const createPostBtn = document.getElementById('createPostBtn');

        const timelineActions = document.getElementById('timelineActions');
        const getTimelineBtn = document.getElementById('getTimelineBtn');
        const timelineDiv = document.getElementById('timelineContainer');

        const resultsDiv = document.getElementById('results');
        const currentUserInfo = document.getElementById('currentUserInfo');

        // Verifica che tutti gli elementi DOM necessari siano stati trovati
        if (!loginForm || !performLogin || !usernameInput || !passwordInput) {
            console.error("Elementi DOM mancanti:", {
                loginForm: !!loginForm,
                performLogin: !!performLogin,
                usernameInput: !!usernameInput,
                passwordInput: !!passwordInput
            });
            setTimeout(() => {
                alert("Errore: Alcuni elementi dell'interfaccia non sono stati trovati. Potrebbe essere necessario ricaricare la pagina.");
            }, 1000);
        } else {
            // Aggiungi event listener per l'evento keydown sui campi di input
            usernameInput.addEventListener('keydown', function (event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    if (passwordInput.value) {
                        performLoginHandler();
                    } else {
                        passwordInput.focus();
                    }
                }
            });

            passwordInput.addEventListener('keydown', function (event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    performLoginHandler();
                }
            });

            // Previeni l'invio del form (che potrebbe ricaricare la pagina)
            loginForm.addEventListener('submit', function (event) {
                event.preventDefault();
                performLoginHandler();
                return false;
            });

            console.log("Event listeners aggiunti ai campi di input");
        }

        let shogun, socialPlugin, currentUserPub;
        let refreshCount = 0, lastRefreshTime = 0, refreshPausedUntil = 0;
        const MAX_REFRESH = 5, WINDOW_MS = 10000;

        // Funzione per sincronizzare lo stato dell'UI con lo stato di autenticazione
        function syncAuthState() {
            try {
                if (socialPlugin && socialPlugin.user && socialPlugin.user.is) {
                    const userPub = socialPlugin.user.is.pub;
                    if (userPub) {
                        console.log("Utente autenticato rilevato:", userPub);
                        currentUserPub = userPub;

                        // Aggiorna la UI
                        loginBtn.disabled = true;
                        loginBtn.textContent = 'Accesso effettuato';
                        getProfileBtn.disabled = false;
                        createPostBtn.disabled = false;

                        // Imposta la chiave pubblica nel campo di input 
                        if (userPubInput) {
                            userPubInput.value = userPub;
                        }

                        // Carica il profilo se necessario
                        if (profileDiv.innerHTML === '') {
                            console.log("Caricamento automatico del profilo dopo auth check");
                            getProfileBtn.click();
                        }
                    }
                }
            } catch (err) {
                console.error("Errore sincronizzazione stato auth:", err);
            }
        }

        function canRefresh() {
            const now = Date.now();
            if (now < refreshPausedUntil) return false;
            if (now - lastRefreshTime > WINDOW_MS) refreshCount = 0;
            refreshCount++; lastRefreshTime = now;
            if (refreshCount > MAX_REFRESH) {
                refreshPausedUntil = now + 30000;
                showError('Attenzione', 'Ciclo di aggiornamenti sospeso 30s');
                return false;
            }
            return true;
        }

        function showResult(title, data) {
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `<strong>${title}</strong>\n\n${typeof data === 'object' ? JSON.stringify(data, null, 2) : data}`;

            // Nascondi il risultato dopo 5 secondi
            setTimeout(() => {
                resultsDiv.style.display = 'none';
            }, 5000);
        }

        function showError(title, msg) {
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = `<strong>${title} - ERRORE</strong>\n\n${msg.message || msg}`;
            console.error(msg);

            // Nascondi l'errore dopo 8 secondi
            setTimeout(() => {
                resultsDiv.style.display = 'none';
            }, 8000);
        }

        function fmt(ts) { return new Date(ts).toLocaleString(); }

        // Display profile
        function displayProfile(p) {
            console.log("Visualizzazione profilo:", p);

            // Verifica che il profilo sia valido
            if (!p || !p.pub) {
                console.error("Tentativo di visualizzare un profilo non valido:", p);
                profileDiv.innerHTML = '<div class="error-message">Profilo non valido o non disponibile</div>';
                return;
            }

            profileDiv.innerHTML = '';
            const me = currentUserPub;
            const isMe = p.pub === me;

            // Aggiungi debug info
            console.log("Profilo:", {
                pub: p.pub,
                isCurrentUser: isMe,
                currentUserPub: me,
                followersCount: p.followers ? p.followers.length : 0,
                followingCount: p.following ? p.following.length : 0
            });

            // Assicurati che followers e following siano array validi
            if (!Array.isArray(p.followers)) p.followers = [];
            if (!Array.isArray(p.following)) p.following = [];

            // Crea intestazione profilo
            const profileHeader = document.createElement('div');
            profileHeader.className = 'profile-header';
            profileHeader.innerHTML = `
                <div class="profile-name">${p.alias || p.pub.slice(0, 8) + '...'}</div>
                <div class="profile-bio">${p.bio || 'Nessuna bio'}</div>
                <div class="profile-pub">Chiave pubblica: ${p.pub}</div>
                ${isMe ? '<div class="profile-status">Questo è il tuo profilo</div>' : ''}
            `;
            profileDiv.appendChild(profileHeader);

            // Se è il proprio profilo, aggiungi il pulsante per modificare la bio
            if (isMe) {
                const editBioBtn = document.createElement('button');
                editBioBtn.textContent = 'Modifica Bio';
                editBioBtn.className = 'edit-bio-btn';

                // Aggiungi il pulsante alla sezione intestazione del profilo
                profileHeader.appendChild(editBioBtn);

                // Aggiungi event listener per il pulsante di modifica
                editBioBtn.addEventListener('click', () => {
                    // Recupera l'elemento della bio
                    const bioElement = profileHeader.querySelector('.profile-bio');
                    const currentBio = p.bio || '';

                    // Crea un form per la modifica
                    const bioForm = document.createElement('div');
                    bioForm.className = 'bio-edit-form';
                    bioForm.innerHTML = `
                        <textarea id="bioInput" maxlength="200" placeholder="Inserisci la tua bio">${currentBio}</textarea>
                        <div class="form-actions">
                            <button id="saveBioBtn">Salva</button>
                            <button id="cancelBioBtn">Annulla</button>
                        </div>
                    `;

                    // Sostituisci temporaneamente l'elemento bio con il form
                    bioElement.style.display = 'none';
                    bioElement.parentNode.insertBefore(bioForm, bioElement.nextSibling);

                    // Focus sul campo di input
                    const bioInput = document.getElementById('bioInput');
                    bioInput.focus();

                    // Event listeners per i pulsanti del form
                    document.getElementById('saveBioBtn').addEventListener('click', async () => {
                        const newBio = bioInput.value.trim();

                        try {
                            // Mostra messaggio di caricamento
                            bioForm.innerHTML = '<div class="loading">Salvataggio in corso...</div>';

                            // Aggiorna la bio utilizzando il metodo dell'API
                            const result = await socialPlugin.updateProfile({ bio: newBio });

                            if (result) {
                                // Aggiorna la UI con la nuova bio
                                bioElement.textContent = newBio || 'Nessuna bio';
                                showResult('Profilo', 'Bio aggiornata con successo');
                            } else {
                                showError('Errore', 'Impossibile aggiornare la bio');
                            }
                        } catch (err) {
                            console.error('Errore aggiornamento bio:', err);
                            showError('Errore', `Impossibile aggiornare la bio: ${err.message || 'errore sconosciuto'}`);
                        } finally {
                            // Rimuovi il form e mostra di nuovo la bio
                            bioForm.remove();
                            bioElement.style.display = 'block';
                        }
                    });

                    document.getElementById('cancelBioBtn').addEventListener('click', () => {
                        // Rimuovi il form e mostra di nuovo la bio
                        bioForm.remove();
                        bioElement.style.display = 'block';
                    });
                });
            }

            // Crea sezione statistiche
            const statsSection = document.createElement('div');
            statsSection.className = 'profile-stats';

            // Crea sezione followers con elenco espandibile
            const followersSection = document.createElement('div');
            followersSection.className = 'profile-stat-section';
            followersSection.innerHTML = `
                <div class="profile-stat">
                    <strong>Followers:</strong> ${p.followers.length}
                    ${p.followers.length > 0 ? '<button class="toggle-list">Mostra</button>' : ''}
                </div>
                <div class="followers-list" style="display:none;">
                    <div class="list-header">
                        <h4>Persone che ti seguono</h4>
                        <button class="refresh-list">🔄</button>
                    </div>
                    <div class="list-content"></div>
                </div>
            `;

            // Se ci sono follower, aggiungi la lista
            if (p.followers.length > 0) {
                const followersList = followersSection.querySelector('.followers-list');
                const followersContent = followersList.querySelector('.list-content');
                const toggleBtn = followersSection.querySelector('.toggle-list');
                const refreshBtn = followersList.querySelector('.refresh-list');

                // Funzione per caricare/ricaricare i follower
                const loadFollowerProfiles = async () => {
                    followersContent.innerHTML = '<div class="loading">Caricamento dei follower...</div>';

                    try {
                        // Array per memorizzare i profili e gli elementi HTML
                        const followerProfiles = [];
                        const followerElements = [];

                        // Per ciascun follower, recuperiamo il profilo
                        for (const followerPub of p.followers) {
                            try {
                                const profile = await socialPlugin.getProfile(followerPub);
                                followerProfiles.push(profile);

                                // Crea l'elemento HTML con il nome utente o l'alias
                                const displayName = profile.alias || followerPub.slice(0, 10) + '...';

                                followerElements.push(`
                                    <div class="follower-item">
                                        <span class="follower-name">${displayName}</span>
                                        <button class="view-profile" data-pub="${followerPub}">Profilo</button>
                                    </div>
                                `);
                            } catch (err) {
                                console.error('Errore recupero profilo follower:', followerPub, err);
                                // Fallback all'ID pubblico in caso di errore
                                followerElements.push(`
                                    <div class="follower-item">
                                        <span class="follower-name">${followerPub.slice(0, 15)}...</span>
                                        <button class="view-profile" data-pub="${followerPub}">Profilo</button>
                                    </div>
                                `);
                            }
                        }

                        // Aggiorna la lista con gli elementi HTML generati
                        followersContent.innerHTML = followerElements.join('') || '<div class="empty-list">Nessun follower</div>';

                        // Aggiungi event listener ai bottoni della vista profilo
                        followersContent.querySelectorAll('.view-profile').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const pub = btn.getAttribute('data-pub');
                                if (pub) {
                                    userPubInput.value = pub;
                                    getProfileBtn.click();
                                }
                            });
                        });
                    } catch (err) {
                        console.error('Errore caricamento profili follower:', err);
                        followersContent.innerHTML = '<div class="error-message">Errore nel caricamento dei follower</div>';
                    }
                };

                // Aggiungi event listener al pulsante di aggiornamento
                refreshBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Evita che l'evento raggiunga il toggle
                    loadFollowerProfiles();
                });

                toggleBtn.addEventListener('click', () => {
                    const isHidden = followersList.style.display === 'none';
                    followersList.style.display = isHidden ? 'block' : 'none';
                    toggleBtn.textContent = isHidden ? 'Nascondi' : 'Mostra';

                    if (isHidden && followersContent.innerHTML === '') {
                        loadFollowerProfiles();
                    }
                });
            }

            statsSection.appendChild(followersSection);

            // Crea sezione following con elenco espandibile
            const followingSection = document.createElement('div');
            followingSection.className = 'profile-stat-section';
            followingSection.innerHTML = `
                <div class="profile-stat">
                    <strong>Following:</strong> ${p.following.length}
                    ${p.following.length > 0 ? '<button class="toggle-list">Mostra</button>' : ''}
                </div>
                <div class="following-list" style="display:none;">
                    <div class="list-header">
                        <h4>Persone che segui</h4>
                        <button class="refresh-list">🔄</button>
                    </div>
                    <div class="list-content"></div>
                </div>
            `;

            // Se ci sono following, aggiungi la lista
            if (p.following.length > 0) {
                const followingList = followingSection.querySelector('.following-list');
                const followingContent = followingList.querySelector('.list-content');
                const toggleBtn = followingSection.querySelector('.toggle-list');
                const refreshBtn = followingList.querySelector('.refresh-list');

                // Funzione per caricare/ricaricare gli utenti seguiti
                const loadFollowingProfiles = async () => {
                    followingContent.innerHTML = '<div class="loading">Caricamento dei profili seguiti...</div>';

                    try {
                        // Array per memorizzare i profili e gli elementi HTML
                        const followingProfiles = [];
                        const followingElements = [];

                        // Per ciascun utente seguito, recuperiamo il profilo
                        for (const followingPub of p.following) {
                            try {
                                const profile = await socialPlugin.getProfile(followingPub);
                                followingProfiles.push(profile);

                                // Crea l'elemento HTML con il nome utente o l'alias
                                const displayName = profile.alias || followingPub.slice(0, 10) + '...';

                                followingElements.push(`
                                    <div class="following-item">
                                        <span class="following-name">${displayName}</span>
                                        <button class="view-profile" data-pub="${followingPub}">Profilo</button>
                                        ${me === p.pub ? `<button class="unfollow-user" data-pub="${followingPub}">Smetti di seguire</button>` : ''}
                                    </div>
                                `);
                            } catch (err) {
                                console.error('Errore recupero profilo:', followingPub, err);
                                // Fallback all'ID pubblico in caso di errore
                                followingElements.push(`
                                    <div class="following-item">
                                        <span class="following-name">${followingPub.slice(0, 15)}...</span>
                                        <button class="view-profile" data-pub="${followingPub}">Profilo</button>
                                        ${me === p.pub ? `<button class="unfollow-user" data-pub="${followingPub}">Smetti di seguire</button>` : ''}
                                    </div>
                                `);
                            }
                        }

                        // Aggiorna la lista con gli elementi HTML generati
                        followingContent.innerHTML = followingElements.join('') || '<div class="empty-list">Non segue nessuno</div>';

                        // Aggiungi event listener ai bottoni
                        followingContent.querySelectorAll('.view-profile').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const pub = btn.getAttribute('data-pub');
                                if (pub) {
                                    userPubInput.value = pub;
                                    getProfileBtn.click();
                                }
                            });
                        });

                        followingContent.querySelectorAll('.unfollow-user').forEach(btn => {
                            btn.addEventListener('click', async () => {
                                const pub = btn.getAttribute('data-pub');
                                if (!pub) return;

                                btn.disabled = true;
                                btn.textContent = 'Rimozione...';

                                try {
                                    // Utilizziamo la nuova funzione performUnfollow
                                    const result = await performUnfollow(pub);
                                    if (!result) {
                                        btn.disabled = false;
                                        btn.textContent = 'Smetti di seguire';
                                    }
                                } catch (err) {
                                    console.error('Errore unfollow:', err);
                                    showError('Unfollow', err.message || 'Errore sconosciuto');
                                    btn.disabled = false;
                                    btn.textContent = 'Smetti di seguire';
                                }
                            });
                        });
                    } catch (err) {
                        console.error('Errore caricamento profili:', err);
                        followingContent.innerHTML = '<div class="error-message">Errore nel caricamento dei profili</div>';
                    }
                };

                // Aggiungi event listener al pulsante di aggiornamento
                refreshBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Evita che l'evento raggiunga il toggle
                    loadFollowingProfiles();
                });

                toggleBtn.addEventListener('click', () => {
                    const isHidden = followingList.style.display === 'none';
                    followingList.style.display = isHidden ? 'block' : 'none';
                    toggleBtn.textContent = isHidden ? 'Nascondi' : 'Mostra';

                    if (isHidden && followingContent.innerHTML === '') {
                        loadFollowingProfiles();
                    }
                });
            }

            statsSection.appendChild(followingSection);
            profileDiv.appendChild(statsSection);

            // Crea sezione azioni
            if (!isMe) {
                const isFollowing = me && p.followers.includes(me);

                const actionsSection = document.createElement('div');
                actionsSection.className = 'profile-actions';

                const followBtn = document.createElement('button');
                followBtn.id = 'btnFollow';
                followBtn.textContent = isFollowing ? 'Già seguito' : 'Segui';
                followBtn.disabled = isFollowing;

                if (isFollowing) {
                    followBtn.style.backgroundColor = '#4caf50';
                }

                followBtn.addEventListener('click', async () => {
                    // Utilizza la nuova funzione performFollow
                    await performFollow(p.pub);
                });

                const unfollowBtn = document.createElement('button');
                unfollowBtn.id = 'btnUnfollow';
                unfollowBtn.textContent = 'Smetti di seguire';
                unfollowBtn.disabled = !isFollowing;

                unfollowBtn.addEventListener('click', async () => {
                    // Utilizza la nuova funzione performUnfollow
                    await performUnfollow(p.pub);
                });

                actionsSection.appendChild(followBtn);
                actionsSection.appendChild(unfollowBtn);
                profileDiv.appendChild(actionsSection);
            } else {
                // Se è il proprio profilo
                const selfInfo = document.createElement('div');
                selfInfo.className = 'self-profile-info';
                selfInfo.innerHTML = '<em>Questo è il tuo profilo</em>';
                profileDiv.appendChild(selfInfo);
            }
        }

        // Funzione per verificare lo stato dei like e aggiornare la UI
        async function checkLikeStatus(postId) {
            if (!currentUserPub) return false;

            try {
                const likes = await socialPlugin.getLikes(postId);
                const hasLiked = likes.includes(currentUserPub);

                // Aggiorna l'aspetto visivo dei pulsanti
                const postEl = document.querySelector(`.post[data-id="${postId}"]`);
                if (postEl) {
                    const likeButton = postEl.querySelector('.like-button');
                    const unlikeButton = postEl.querySelector('.unlike-button');

                    if (likeButton) {
                        if (hasLiked) {
                            likeButton.classList.add('active');
                            likeButton.style.backgroundColor = '#4caf50';
                            // Mostra il pulsante di rimozione
                            if (unlikeButton) {
                                unlikeButton.classList.add('visible');
                            }
                        } else {
                            likeButton.classList.remove('active');
                            likeButton.style.backgroundColor = '';
                            // Nascondi il pulsante di rimozione
                            if (unlikeButton) {
                                unlikeButton.classList.remove('visible');
                            }
                        }
                    }
                }

                return hasLiked;
            } catch (err) {
                console.error(`Errore verifica stato like per ${postId}:`, err);
                return false;
            }
        }

        // Funzione per aggiornare i like
        const updateLikes = async (postId) => {
            try {
                console.log(`Richiesta aggiornamento like per post: ${postId}`);

                // Verifico che l'ID sia valido
                if (!postId || typeof postId !== 'string') {
                    console.error(`ID post non valido:`, postId);
                    return [];
                }

                // Attesa prima di richiedere gli aggiornamenti
                await new Promise(resolve => setTimeout(resolve, 500));

                // Ottieni il conteggio totale dei like dal nuovo metodo
                const likeCount = await socialPlugin.getLikeCount(postId);

                // Ottieni anche gli utenti che hanno messo like (per aggiornare lo stato del pulsante)
                const likes = await socialPlugin.getLikes(postId);

                console.log(`Ricevuti ${likes.length} like per il post ${postId}, conteggio totale: ${likeCount}`);

                // Aggiorna eventuali badge di like nella UI
                const postEl = document.querySelector(`.post[data-id="${postId}"]`);
                if (postEl) {
                    const likeBadge = postEl.querySelector('.like-count');
                    if (likeBadge) {
                        likeBadge.textContent = likeCount > 0 ? likeCount : '';
                    }

                    // Aggiorna lo stato visivo del pulsante like
                    if (currentUserPub) {
                        const hasLiked = likes.includes(currentUserPub);
                        const likeButton = postEl.querySelector('.like-button');
                        const unlikeButton = postEl.querySelector('.unlike-button');

                        if (likeButton) {
                            if (hasLiked) {
                                likeButton.classList.add('active');
                                likeButton.style.backgroundColor = '#4caf50';
                                // Mostra pulsante rimozione
                                if (unlikeButton) {
                                    unlikeButton.classList.add('visible');
                                }
                            } else {
                                likeButton.classList.remove('active');
                                likeButton.style.backgroundColor = '';
                                // Nascondi pulsante rimozione
                                if (unlikeButton) {
                                    unlikeButton.classList.remove('visible');
                                }
                            }
                        }
                    }
                }

                return likes;
            } catch (err) {
                console.error('Errore in updateLikes:', err);
                return [];
            }
        };

        // Aggiungi commento
        async function addComment(postId, content) {
            if (!content.trim()) {
                console.error('Contenuto commento vuoto');
                return null;
            }

            console.log(`Invio commento a post ${postId}: "${content}"`);
            showResult('Operazione', { message: 'Invio commento in corso...' });

            try {
                // Verifica che l'utente sia autenticato
                if (!currentUserPub) {
                    showError('Errore', 'Devi effettuare il login per commentare');
                    return null;
                }

                // Aggiunta del commento con timeout
                const commentPromise = socialPlugin.addComment(postId, content);
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout durante l\'invio del commento')), 10000);
                });

                const comment = await Promise.race([commentPromise, timeoutPromise]);

                if (!comment) {
                    console.error('Errore durante l\'invio del commento: risultato null');
                    showError('Errore', 'Impossibile inviare il commento');
                    return null;
                }

                console.log('Commento inviato con successo:', comment);

                // Verifica che il commento sia stato effettivamente registrato
                // Fai più tentativi per leggere il commento, per assicurarti che sia stato salvato
                let commentFound = false;
                let comments = [];
                let attempts = 0;
                const maxAttempts = 3;

                while (!commentFound && attempts < maxAttempts) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempts)); // aumenta il tempo tra i tentativi

                    // Tenta di recuperare i commenti e verificare se il nostro è presente
                    try {
                        comments = await socialPlugin.getComments(postId);
                        console.log(`Verifica commento tentativo ${attempts}: trovati ${comments.length} commenti`);

                        // Cerca il commento che abbiamo appena aggiunto
                        commentFound = comments.some(c => c.id === comment.id && c.content === content);

                        if (commentFound) {
                            console.log(`Commento ${comment.id} verificato e salvato correttamente`);
                            break;
                        } else {
                            console.warn(`Commento ${comment.id} non trovato al tentativo ${attempts}`);

                            // Tenta di recuperare il commento direttamente
                            gun.get("posts").get(postId).get("comments").get(comment.id).once(function (data) {
                                console.log(`Verifica diretta del commento ${comment.id}:`, data);
                                if (data && data.content === content) {
                                    console.log(`Commento ${comment.id} verificato direttamente da GunDB`);
                                    commentFound = true;
                                }
                            });
                        }
                    } catch (err) {
                        console.error(`Errore durante la verifica del commento (tentativo ${attempts}):`, err);
                    }
                }

                if (!commentFound) {
                    console.warn(`Il commento potrebbe non essere stato salvato correttamente. Riprova.`);

                    // Tenta di riscriverlo una volta in più, direttamente
                    await new Promise((resolve) => {
                        gun.get("posts")
                            .get(postId)
                            .get("comments")
                            .get(comment.id)
                            .put({
                                id: comment.id,
                                postId,
                                author: currentUserPub,
                                content: content.trim(),
                                timestamp: comment.timestamp || Date.now(),
                            }, ack => {
                                console.log("Risultato secondo tentativo di salvataggio commento:", ack);
                                resolve();
                            });
                    });
                }

                // Aggiorna immediatamente la UI con il nuovo commento anche se non troviamo conferma
                // del salvataggio, per dare feedback all'utente
                const commentElement = document.createElement('div');
                commentElement.className = 'comment';
                commentElement.setAttribute('data-comment-id', comment.id);
                commentElement.innerHTML = `
                    <div class="comment-header">
                        <span class="comment-author">Tu</span>
                        <span class="comment-time">${new Date().toLocaleString()}</span>
                    </div>
                    <div class="comment-text">${escapeHtml(content)}</div>
                `;

                const safeId = generateSafeId(postId);
                const commentsList = document.getElementById(`comments-list-${safeId}`);
                if (commentsList) {
                    // Aggiungi il nuovo commento all'inizio (è il più recente)
                    commentsList.insertBefore(commentElement, commentsList.firstChild);
                }

                return comment;
            } catch (err) {
                console.error('Errore addComment:', err);
                showError('Errore', `Errore durante l'invio del commento: ${err.message || 'errore sconosciuto'}`);
                return null;
            }
        }

        // Funzione per generare un ID DOM sicuro
        function generateSafeId(postId) {
            if (!postId) return 'unknown';

            // Se l'ID è molto lungo, usa un hash
            if (postId.length > 40) {
                // Crea un hash semplice basato sull'ID
                let hash = 0;
                for (let i = 0; i < postId.length; i++) {
                    hash = ((hash << 5) - hash) + postId.charCodeAt(i);
                    hash |= 0; // Converti a integer a 32 bit
                }
                return 'post-' + Math.abs(hash).toString(16);
            }

            // Altrimenti, sanifica l'ID rimuovendo caratteri problematici
            return 'post-' + postId.replace(/[^\w-]/g, '_');
        }

        function loadComments(postId) {
            if (!postId) {
                console.error("loadComments: ID del post non valido");
                return;
            }

            console.log(`loadComments: Caricamento commenti per il post ${postId}`);

            // Usa un ID sicuro per il DOM
            const safeId = generateSafeId(postId);
            console.log(`loadComments: Usando ID sicuro: ${safeId}`);

            // Creazione del contenitore per i commenti
            let commentsList = document.getElementById(`comments-list-${safeId}`);
            if (!commentsList) {
                console.error(`loadComments: Contenitore commenti non trovato per il post ${postId}`);
                console.log("Elementi disponibili:", document.querySelectorAll('.comments-container').length);

                // Prova a recuperare il contenitore dei commenti tramite il genitore
                const postElement = document.querySelector(`.post[data-id="${postId}"]`);
                if (postElement) {
                    const commentsContainer = postElement.querySelector('.comments-container');
                    if (commentsContainer) {
                        // Crea dinamicamente il contenitore dei commenti se non esiste
                        commentsList = document.createElement('div');
                        commentsList.id = `comments-list-${safeId}`;
                        commentsList.className = 'comments-list';
                        commentsContainer.appendChild(commentsList);
                        console.log(`loadComments: Creato nuovo contenitore commenti con ID: comments-list-${safeId}`);
                    } else {
                        console.error(`loadComments: Contenitore generico dei commenti non trovato per il post ${postId}`);
                        return;
                    }
                } else {
                    console.error(`loadComments: Elemento post non trovato per l'ID ${postId}`);
                    return;
                }
            }

            // Mostra messaggio di caricamento
            commentsList.innerHTML = '<div class="comment-loading">Caricamento commenti...</div>';

            // Utilizziamo il metodo diretto per recuperare i commenti
            getCommentsDirectly(postId, safeId);
        }

        // Recupera commenti direttamente da Gun (aggiornata per usare safeId)
        function getCommentsDirectly(postId, safeId) {
            // Validazione iniziale
            if (!postId) {
                console.error('getCommentsDirectly: ID post non valido');
                return Promise.reject('ID post non valido');
            }

            // Usa l'ID sicuro fornito o generalo
            const actualSafeId = safeId || generateSafeId(postId);

            const commentsList = document.getElementById(`comments-list-${actualSafeId}`);
            if (!commentsList) {
                console.error(`getCommentsDirectly: Elemento comments-list-${actualSafeId} non trovato`);
                return Promise.reject(`Elemento comments-list-${actualSafeId} non trovato`);
            }

            // Mostra messaggio di caricamento
            commentsList.innerHTML = '<div class="comment-loading">Caricamento commenti...</div>';

            console.log(`getCommentsDirectly: Inizio recupero commenti per il post ${postId}`);

            // Nuova implementazione migliorata:
            // 1. Prima prova con il metodo standard dell'API
            // 2. Poi con accesso diretto a GunDB
            // 3. Infine cerca anche nei nodi alternativi

            // Promessa per il recupero commenti
            return new Promise(async (resolve, reject) => {
                try {
                    // Primo tentativo: usa il metodo ufficiale API
                    console.log(`getCommentsDirectly: Primo tentativo con socialPlugin.getComments`);
                    const comments = await socialPlugin.getComments(postId);
                    console.log(`getCommentsDirectly: Tentativo #1 - Ricevuti ${comments.length} commenti per ${postId}`);

                    if (comments.length > 0) {
                        // Abbiamo trovato commenti, visualizzali
                        displayComments(postId, comments, actualSafeId);
                        resolve(comments);
                        return;
                    }

                    // Se non abbiamo trovato commenti, tenta di accedere direttamente alla struttura GunDB
                    console.log(`getCommentsDirectly: Nessun commento trovato con il metodo API, proviamo accesso diretto a GunDB`);

                    // Secondo tentativo: accesso diretto a GunDB
                    const directAttempt = await new Promise(resolveAttempt => {
                        const commentsFound = [];
                        gun.get("posts").get(postId).get("comments").map().once((data, key) => {
                            if (key !== "_" && data) {
                                console.log(`Trovato commento nel formato posts/${postId}/comments/${key}:`, data);

                                // Controlla se il commento ha già un contenuto
                                const comment = {
                                    id: data.id || key,
                                    author: data.author || "Anonimo",
                                    content: data.content || "",
                                    timestamp: data.timestamp || Date.now(),
                                    postId: postId
                                };

                                commentsFound.push(comment);
                            }
                        });

                        // Attendi un po' per raccogliere dati
                        setTimeout(() => {
                            console.log(`getCommentsDirectly: Tentativo #2 - Ricevuti ${commentsFound.length} commenti direttamente da GunDB`);
                            resolveAttempt(commentsFound);
                        }, 1000);
                    });

                    if (directAttempt.length > 0) {
                        displayComments(postId, directAttempt, actualSafeId);
                        resolve(directAttempt);
                        return;
                    }

                    // Se nessun tentativo ha prodotto risultati
                    console.log(`getCommentsDirectly: Nessun commento trovato per il post ${postId} dopo tutti i tentativi`);
                    commentsList.innerHTML = '<div class="no-comments">Nessun commento per questo post</div>';
                    resolve([]);
                } catch (err) {
                    console.error(`getCommentsDirectly: Errore durante il recupero dei commenti:`, err);
                    commentsList.innerHTML = '<div class="error-message">Errore durante il recupero dei commenti</div>';
                    reject(err);
                }
            });
        }

        // Display timeline
        function displayTimeline(res) {
            timelineDiv.innerHTML = '';

            console.log("displayTimeline - Dati ricevuti:", res);

            if (res.error) {
                timelineDiv.innerHTML = `Errore: ${res.error}`;
                return;
            }

            if (!res.messages || !res.messages.length) {
                timelineDiv.innerHTML = '<p>Nessun post nella timeline. Segui altri utenti per vedere i loro post.</p>';
                return;
            }

            // Controlla se i messaggi hanno la struttura corretta
            res.messages.forEach((msg, idx) => {
                if (!msg.id) {
                    console.warn(`Messaggio #${idx} senza ID:`, msg);
                }

                // Controlla se c'è un contenuto
                const hasContent = msg.content || (msg.payload && msg.payload.content);
                if (!hasContent) {
                    console.warn(`Messaggio #${idx} (${msg.id || 'senza ID'}) senza contenuto:`, msg);
                }
            });

            // Aggiungi bottone di debug
            const debugBtn = document.createElement('button');
            debugBtn.textContent = 'Debug GunDB';
            debugBtn.style.backgroundColor = '#9c27b0';
            debugBtn.addEventListener('click', debugGunDb);
            timelineDiv.appendChild(debugBtn);

            // Aggiungi una intestazione per la timeline
            const header = document.createElement('div');
            header.className = 'timeline-header';
            header.innerHTML = `<h3>I tuoi post e quelli delle persone che segui</h3>`;
            timelineDiv.appendChild(header);

            // Se disponibile, ottieni il profilo per avere la lista dei following
            const currentProfile = { following: [] };
            (async () => {
                if (currentUserPub) {
                    try {
                        const profile = await socialPlugin.getProfile(currentUserPub);
                        Object.assign(currentProfile, profile);
                        console.log(`Utente segue ${profile.following.length} profili`);
                    } catch (err) {
                        console.error('Errore recupero profilo:', err);
                    }
                }
            })();

            // Organizziamo i post in gruppi: propri e degli utenti seguiti
            const myPosts = res.messages.filter(msg => msg.creator === currentUserPub);
            const followingPosts = res.messages.filter(msg => msg.creator !== currentUserPub);

            // Log informativo
            console.log(`Timeline: ${myPosts.length} post propri, ${followingPosts.length} post di utenti seguiti`);

            // Funzione per creare un post con titolo personalizzato
            const createPostWithTitle = (msg, title) => {
                const section = document.createElement('div');
                section.className = 'post-section';
                if (title) {
                    const sectionTitle = document.createElement('div');
                    sectionTitle.className = 'post-section-title';
                    sectionTitle.textContent = title;
                    section.appendChild(sectionTitle);
                }

                // Debug del messaggio
                console.log(`createPostWithTitle - Messaggio completo:`, msg);

                // Estrai contenuto del post da diverse fonti possibili
                let content = '';

                // Controllo diretto su content
                if (msg.content) {
                    content = msg.content;
                    console.log(`createPostWithTitle - Contenuto trovato in msg.content: "${content.substring(0, 30)}${content.length > 30 ? '...' : ''}"`);
                }
                // Controllo nel payload
                else if (msg.payload && typeof msg.payload === 'object') {
                    if (msg.payload.content) {
                        content = msg.payload.content;
                        console.log(`createPostWithTitle - Contenuto trovato in msg.payload.content: "${content.substring(0, 30)}${content.length > 30 ? '...' : ''}"`);
                    }
                }

                // Se ancora vuoto, prova altre proprietà che potrebbero contenere il testo
                if (!content && msg.text) {
                    content = msg.text;
                    console.log(`createPostWithTitle - Contenuto trovato in msg.text: "${content.substring(0, 30)}${content.length > 30 ? '...' : ''}"`);
                }

                // Se il contenuto è vuoto e abbiamo un hash lungo, mostra messaggio appropriato
                if (!content) {
                    content = 'Contenuto non disponibile';
                    console.warn(`Post ${msg.id} senza contenuto visibile (ID: ${msg.id})`);
                }

                const postEl = createPost({
                    id: msg.id,
                    author: msg.creator || msg.author,
                    content: content,
                    timestamp: msg.createdAt || msg.timestamp || Date.now()
                });

                if (postEl) {
                    // Aggiungi classe speciale per i post propri
                    if ((msg.creator === currentUserPub) || (msg.author === currentUserPub)) {
                        postEl.classList.add('own-post');
                    }
                    section.appendChild(postEl);
                }

                return section;
            };

            // Aggiungi tutti i post alla timeline
            res.messages.forEach(msg => {
                try {
                    // Debug dei dati del post
                    console.log("Elaborazione post nella timeline:", {
                        id: msg.id,
                        creator: msg.creator || msg.author,
                        content: msg.content || (msg.payload && msg.payload.content) || "Nessun contenuto",
                        payload: msg.payload,
                        timestamp: msg.createdAt || msg.timestamp
                    });

                    let title = '';
                    const postAuthor = msg.creator || msg.author;

                    if (postAuthor === currentUserPub) {
                        title = 'Il tuo post';
                    } else if (currentProfile.following.includes(postAuthor)) {
                        title = `Post di ${postAuthor.substring(0, 8)}... (segui questo utente)`;
                    } else {
                        title = `Post di ${postAuthor.substring(0, 8)}...`;
                    }

                    const postSection = createPostWithTitle(msg, title);
                    timelineDiv.appendChild(postSection);
                } catch (err) {
                    console.error("Errore nella visualizzazione del post:", err, msg);
                }
            });
        }

        // Handlers for follow/unfollow
        async function follow(pub) {
            const ok = await socialPlugin.follow(pub);
            showResult('Segui', { pub, success: ok });
        }
        async function unfollow(pub) {
            const ok = await socialPlugin.unfollow(pub);
            showResult('Unfollow', { pub, success: ok });
        }

        // Init Shogun
        initBtn.onclick = function (e) {
            e.preventDefault(); // Previene esplicitamente il comportamento di default

            const cfg = {
                gundb: { peers: ['//localhost:8765/gun'], localStorage: false, radisk: false, authToken: 'thisIsTheTokenForReals' },
                walletManager: { enabled: false },  // Disattiva il wallet manager per evitare errori RPC
                social: { enabled: true },
                logging: { enabled: true, level: 'debug', prefix: '[Shogun]' }
            };
            shogun = window.initShogunBrowser(cfg);
            socialPlugin = shogun.getPlugin('social');
            gun = shogun.gun;
            if (socialPlugin) {
                showResult('Inizializzazione completata', 'Il sistema è pronto per l\'uso');
                loginBtn.disabled = false;
                initBtn.disabled = true;
                initBtn.textContent = 'Inizializzato';

                // Controlla se l'utente è già autenticato
                setTimeout(syncAuthState, 500);
            } else {
                showError('Errore', 'Plugin social non trovato');
            }

            return false; // Assicura che non ci sia refresh
        };

        // Login
        loginBtn.onclick = function (e) {
            e.preventDefault(); // Previene esplicitamente il comportamento di default

            console.log("Click sul pulsante Accedi (mostra form)");
            if (loginForm && typeof loginForm !== 'undefined') {
                loginForm.style.display = loginForm.style.display === 'none' ? 'block' : 'none';
                console.log("Cambio visibilità form login:", loginForm.style.display);

                // Focus sul campo username dopo aver mostrato il form
                if (loginForm.style.display === 'block' && usernameInput) {
                    setTimeout(() => usernameInput.focus(), 100);
                }
            } else {
                console.error('Form di login non trovato nel DOM');
                showError('Errore', 'Form di login non disponibile');
            }

            return false; // Assicura che non ci sia refresh
        };

        // Assicuriamoci che il pulsante "Accedi" nel form abbia un event listener diretto
        if (performLogin) {
            console.log("Aggiunta del listener al pulsante di login");
            // Rimuovi eventuali listener esistenti
            performLogin.removeEventListener('click', performLoginHandler);
            // Aggiungi il nuovo listener
            performLogin.addEventListener('click', function (e) {
                e.preventDefault(); // Previene esplicitamente il comportamento di default
                performLoginHandler();
                return false;
            });
        } else {
            console.error("Pulsante performLogin non trovato nel DOM");
        }

        // Funzione separata per gestire il login
        async function performLoginHandler() {
            console.log("performLogin - Inizio procedura");
            const u = usernameInput.value, p = passwordInput.value;
            if (!u || !p) { showError('Login', 'Inserisci credenziali'); return; }

            // Verifica che shogun sia inizializzato
            if (!shogun) {
                showError('Login', 'Shogun non inizializzato. Clicca prima su "Inizializza"');
                return;
            }

            // Disabilita i pulsanti durante il login
            performLogin.disabled = true;
            performLogin.textContent = 'Accesso in corso...';

            try {
                console.log("Tentativo di login con", { username: u, password: "***" });
                const res = await shogun.login(u, p);
                console.log("Risposta login:", res);

                if (res && res.success) {
                    showResult('Accesso effettuato', res);
                    currentUserPub = res.userPub;
                    userPubInput.value = currentUserPub;

                    // Aggiorna UI dopo login
                    getProfileBtn.disabled = false;
                    createPostBtn.disabled = false;
                    loginForm.style.display = 'none';
                    loginBtn.disabled = true;
                    loginBtn.textContent = 'Accesso effettuato';

                    // Mostra il composer dei post e le azioni della timeline
                    postComposer.style.display = 'block';
                    timelineActions.style.display = 'block';

                    // Mostra info utente nell'header
                    currentUserInfo.style.display = 'block';
                    if (currentUserInfo.querySelector('strong')) {
                        currentUserInfo.querySelector('strong').textContent = u;
                    }

                    // Carica subito il profilo dell'utente
                    try {
                        console.log("Caricamento profilo per l'utente autenticato:", currentUserPub);
                        const profile = await socialPlugin.getProfile(currentUserPub);
                        console.log("Profilo utente caricato:", profile);
                        displayProfile(profile);

                        // Imposta la chiave pubblica nel campo di input
                        if (userPubInput) {
                            userPubInput.value = currentUserPub;
                        }
                    } catch (profileErr) {
                        console.error("Errore caricamento profilo dopo login:", profileErr);
                        showError('Caricamento profilo', profileErr.message || 'Errore recupero dati utente');
                    }

                    // Carica anche la timeline
                    setTimeout(loadTimeline, 500);

                    // Sincronizza lo stato dell'autenticazione
                    syncAuthState();

                    // Carica anche i miei post
                    setTimeout(loadMyPosts, 1000);
                } else {
                    showError('Errore di accesso', (res && res.error) ? res.error : 'Credenziali non valide o risposta non valida');
                    performLogin.disabled = false;
                    performLogin.textContent = 'Accedi';
                }
            } catch (error) {
                console.error("Errore completo durante il login:", error);
                showError('Errore di accesso', error.message || 'Errore durante il login');
                performLogin.disabled = false;
                performLogin.textContent = 'Accedi';
            }
        }

        // Manteniamo anche l'onclick per retrocompatibilità
        performLogin.onclick = function (e) {
            e.preventDefault(); // Previene esplicitamente il comportamento di default
            performLoginHandler();
            return false;
        };

        // Profile buttons
        getProfileBtn.onclick = async function (e) {
            e.preventDefault(); // Previene esplicitamente il comportamento di default

            const pub = userPubInput.value.trim();
            if (!pub) {
                showError('Profilo', 'Chiave pubblica utente richiesta');
                return;
            }

            // Mostra un indicatore di caricamento
            profileDiv.innerHTML = '<div class="loading">Caricamento del profilo in corso...</div>';

            try {
                console.log("Richiesta profilo per:", pub);

                // Se siamo autenticati ma non c'è un valore currentUserPub, lo impostiamo
                if (socialPlugin.user && socialPlugin.user.is && socialPlugin.user.is.pub && !currentUserPub) {
                    currentUserPub = socialPlugin.user.is.pub;
                    console.log("Impostato currentUserPub dal plugin:", currentUserPub);
                }

                const p = await socialPlugin.getProfile(pub);
                console.log("Profilo ricevuto:", p);

                if (!p || !p.pub) {
                    throw new Error("Profilo non valido ricevuto dal server");
                }

                showResult('Profilo', p);
                displayProfile(p);
            } catch (err) {
                console.error("Errore recupero profilo:", err);
                profileDiv.innerHTML = `<div class="error-message">Errore caricamento profilo: ${err.message || 'Errore sconosciuto'}</div>`;
                showError('Errore Profilo', err.message || 'Impossibile caricare il profilo');
            }

            return false;
        };

        // Create post
        createPostBtn.onclick = async function (e) {
            e.preventDefault(); // Previene esplicitamente il comportamento di default

            const txt = postContent.value.trim();
            if (!txt) { showError('Post', 'Contenuto vuoto'); return; }

            // Utilizzo il nuovo formato con options
            const options = {
                // Se necessario, aggiungi topic o altri campi qui
            };

            const p = await socialPlugin.post(txt, options);
            showResult('Post creato', p);
            postContent.value = '';
            setTimeout(loadTimeline, 500);
        };

        // Follow/Unfollow handling
        async function performFollow(pub) {
            if (!currentUserPub) {
                alert('Devi effettuare il login per seguire utenti');
                return false;
            }

            if (pub === currentUserPub) {
                showError('Follow', 'Non puoi seguire te stesso');
                return false;
            }

            const followBtn = document.getElementById('btnFollow');
            const unfollowBtn = document.getElementById('btnUnfollow');

            if (followBtn) followBtn.disabled = true;
            if (followBtn) followBtn.textContent = 'Seguendo...';

            try {
                showResult('Operazione', { message: 'Invio richiesta follow...' });
                const result = await socialPlugin.follow(pub);

                if (result) {
                    showResult('Follow', { pub, success: true, message: 'Follow completato con successo' });

                    // Aggiorna lo stato visivo dei pulsanti
                    if (followBtn) {
                        followBtn.textContent = 'Seguito';
                        followBtn.style.backgroundColor = '#4caf50';
                        followBtn.disabled = true;
                    }

                    if (unfollowBtn) {
                        unfollowBtn.disabled = false;
                    }

                    // Aggiorna la timeline e la view del profilo per riflettere le modifiche
                    await loadTimeline();

                    // Ricarica anche il profilo corrente per vedere l'aggiornamento dei contatori
                    const reloadedProfile = await socialPlugin.getProfile(pub);
                    displayProfile(reloadedProfile);

                    return true;
                } else {
                    showError('Follow', 'Operazione fallita - I dati potrebbero non essere persistenti');

                    if (followBtn) {
                        followBtn.disabled = false;
                        followBtn.textContent = 'Segui';
                    }

                    return false;
                }
            } catch (err) {
                console.error('Errore follow:', err);
                showError('Follow', err.message || 'Errore sconosciuto');

                if (followBtn) {
                    followBtn.disabled = false;
                    followBtn.textContent = 'Segui';
                }

                return false;
            }
        }

        async function performUnfollow(pub) {
            if (!currentUserPub) {
                alert('Devi effettuare il login per gestire i tuoi following');
                return false;
            }

            const followBtn = document.getElementById('btnFollow');
            const unfollowBtn = document.getElementById('btnUnfollow');

            if (unfollowBtn) unfollowBtn.disabled = true;
            if (unfollowBtn) unfollowBtn.textContent = 'Rimozione...';

            try {
                showResult('Operazione', { message: 'Invio richiesta unfollow...' });
                const result = await socialPlugin.unfollow(pub);

                if (result) {
                    showResult('Unfollow', { pub, success: true, message: 'Unfollow completato con successo' });

                    // Aggiorna lo stato visivo dei pulsanti
                    if (followBtn) {
                        followBtn.textContent = 'Segui';
                        followBtn.disabled = false;
                        followBtn.style.backgroundColor = '';
                    }

                    if (unfollowBtn) {
                        unfollowBtn.disabled = true;
                    }

                    // Aggiorna la timeline e la view del profilo per riflettere le modifiche
                    await loadTimeline();

                    // Ricarica anche il profilo corrente per vedere l'aggiornamento dei contatori
                    const reloadedProfile = await socialPlugin.getProfile(pub);
                    displayProfile(reloadedProfile);

                    return true;
                } else {
                    showError('Unfollow', 'Operazione fallita - I dati potrebbero non essere persistenti');

                    if (unfollowBtn) {
                        unfollowBtn.disabled = false;
                        unfollowBtn.textContent = 'Smetti di seguire';
                    }

                    return false;
                }
            } catch (err) {
                console.error('Errore unfollow:', err);
                showError('Unfollow', err.message || 'Errore sconosciuto');

                if (unfollowBtn) {
                    unfollowBtn.disabled = false;
                    unfollowBtn.textContent = 'Smetti di seguire';
                }

                return false;
            }
        }

        // Load timeline
        async function loadTimeline() {
            if (!canRefresh()) return;

            getTimelineBtn.disabled = true;
            getTimelineBtn.textContent = 'Caricamento...';
            timelineDiv.innerHTML = '<div class="loading-timeline">Caricamento del feed...</div>';

            try {
                // Aggiungiamo un timeout per evitare attese infinite
                const timelinePromise = socialPlugin.getTimeline();
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout durante il caricamento della timeline')), 15000);
                });

                const res = await Promise.race([timelinePromise, timeoutPromise]);

                if (res.error) {
                    timelineDiv.innerHTML = `<div class="error-message">Errore: ${res.error}</div>`;
                    return;
                }

                if (!res.messages || res.messages.length === 0) {
                    timelineDiv.innerHTML = `
                        <div class="empty-timeline">
                            <p>Non ci sono post da visualizzare.</p>
                            <p>Crea il tuo primo post o segui altri utenti per vedere i loro contenuti.</p>
                        </div>`;
                    return;
                }

                // Pulisci e prepara la timeline
                timelineDiv.innerHTML = '';

                // Ordina i post dal più recente al più vecchio
                const sortedMessages = [...res.messages].sort((a, b) => {
                    const timeA = a.createdAt || a.timestamp || 0;
                    const timeB = b.createdAt || b.timestamp || 0;
                    return timeB - timeA;
                });

                // Aggiungi i post alla timeline
                sortedMessages.forEach(msg => {
                    try {
                        // Converti il messaggio in formato post
                        const postData = {
                            id: msg.id,
                            author: msg.creator || msg.author,
                            content: msg.content || (msg.payload && msg.payload.content) || '',
                            timestamp: msg.createdAt || msg.timestamp || Date.now()
                        };

                        const postEl = createPost(postData);
                        if (postEl) {
                            timelineDiv.appendChild(postEl);
                        }
                    } catch (err) {
                        console.error("Errore nella creazione del post:", err, msg);
                    }
                });

                console.log(`Timeline caricata: ${res.messages.length} post`);

                // Aggiungi chiamata per caricare anche i miei post
                loadMyPosts();
            } catch (e) {
                console.error('Errore durante il caricamento della timeline:', e);
                timelineDiv.innerHTML = '<div class="error-message">Errore durante il caricamento del feed. Riprova più tardi.</div>';
            } finally {
                getTimelineBtn.disabled = false;
                getTimelineBtn.textContent = 'Aggiorna';
            }
        }
        getTimelineBtn.onclick = loadTimeline;

        // Funzione di debug per testare direttamente Gun
        async function debugGunDb() {
            if (!shogun || !shogun.gun) {
                console.error('GunDB non inizializzato');
                return;
            }

            console.log('Test diretto di GunDB');

            // ID message da cercare
            const messageId = prompt('Inserisci ID del messaggio da cercare:');
            if (!messageId) return;

            console.log(`Ricerca messaggio: ${messageId}`);

            // Accesso diretto tramite Gun
            shogun.gun.get('messages').get(messageId).once((data) => {
                console.log('Risultato .once():', data);
                showResult('Gun.once()', data || 'Non trovato');
            });

            shogun.gun.get('messages').get(messageId).on((data) => {
                console.log('Risultato .on():', data);
                showResult('Gun.on()', data || 'Non trovato');
            });
        }

        // Elementi DOM per la sezione utenti
        const usersSection = document.getElementById('usersSection');
        const loadUsersBtn = document.getElementById('loadUsersBtn');
        const usersList = document.getElementById('usersList');

        // ... resta del codice JavaScript esistente ...

        // Funzione per caricare tutti gli utenti
        async function loadAllUsers() {
            if (!socialPlugin) {
                showError('Errore', 'Plugin social non inizializzato');
                return;
            }

            loadUsersBtn.disabled = true;
            loadUsersBtn.textContent = 'Caricamento...';
            usersList.innerHTML = '<div class="loading-users">Caricamento utenti in corso...</div>';

            try {
                const users = await socialPlugin.getAllUsers();
                displayUsersList(users);
            } catch (err) {
                console.error('Errore caricamento utenti:', err);
                usersList.innerHTML = '<div class="loading-users">Errore durante il caricamento degli utenti</div>';
            } finally {
                loadUsersBtn.disabled = false;
                loadUsersBtn.textContent = 'Ricarica utenti';
            }
        }

        // Funzione per visualizzare la lista degli utenti
        function displayUsersList(users) {
            if (!users || users.length === 0) {
                usersList.innerHTML = '<div class="loading-users">Nessun utente trovato</div>';
                return;
            }

            // Ordina gli utenti: prima quelli con alias, poi per ID
            const sortedUsers = [...users].sort((a, b) => {
                if (a.alias && !b.alias) return -1;
                if (!a.alias && b.alias) return 1;
                if (a.alias && b.alias) return a.alias.localeCompare(b.alias);
                return a.pub.localeCompare(b.pub);
            });

            usersList.innerHTML = '';

            sortedUsers.forEach(user => {
                const isCurrentUser = currentUserPub && user.pub === currentUserPub;
                const displayName = user.alias || user.pub.slice(0, 12) + '...';
                const firstLetter = (user.alias || user.pub.slice(0, 1)).toUpperCase();

                const userItem = document.createElement('div');
                userItem.className = 'user-item';

                // Verifica se l'utente è seguito dall'utente corrente
                const isFollowing = currentUserPub && user.followers && user.followers.includes(currentUserPub);

                userItem.innerHTML = `
                    <div class="user-avatar">
                        ${user.profileImage
                        ? `<img src="${user.profileImage}" alt="${displayName}" />`
                        : firstLetter}
                    </div>
                    <div class="user-info">
                        <div class="user-name">${displayName} ${isCurrentUser ? '(Tu)' : ''}</div>
                        <div class="user-id">${user.pub}</div>
                    </div>
                    <div class="user-actions">
                        <button class="view-profile-btn" data-pub="${user.pub}">Profilo</button>
                        ${!isCurrentUser ? `
                            <button class="follow-btn ${isFollowing ? 'active' : ''}" 
                                    data-pub="${user.pub}" 
                                    ${isFollowing ? 'disabled' : ''}>
                                ${isFollowing ? 'Seguito' : 'Segui'}
                            </button>
                        ` : ''}
                    </div>
                `;

                // Eventi dei pulsanti
                const viewProfileBtn = userItem.querySelector('.view-profile-btn');
                viewProfileBtn.addEventListener('click', () => {
                    userPubInput.value = user.pub;
                    getProfileBtn.click();
                });

                const followBtn = userItem.querySelector('.follow-btn');
                if (followBtn) {
                    followBtn.addEventListener('click', async () => {
                        if (!currentUserPub) {
                            showError('Errore', 'Devi accedere per seguire altri utenti');
                            return;
                        }

                        followBtn.disabled = true;
                        followBtn.textContent = 'In corso...';

                        try {
                            const success = await socialPlugin.follow(user.pub);
                            if (success) {
                                followBtn.classList.add('active');
                                followBtn.textContent = 'Seguito';
                                showResult('Seguito', `Ora segui ${displayName}`);
                            } else {
                                followBtn.disabled = false;
                                followBtn.textContent = 'Segui';
                                showError('Errore', 'Impossibile seguire questo utente');
                            }
                        } catch (err) {
                            console.error('Errore follow:', err);
                            followBtn.disabled = false;
                            followBtn.textContent = 'Segui';
                            showError('Errore', 'Impossibile seguire questo utente');
                        }
                    });
                }

                usersList.appendChild(userItem);
            });
        }

        // Collega il pulsante alla funzione di caricamento
        loadUsersBtn.addEventListener('click', loadAllUsers);

        // Aggiorna inizializzazione
        initBtn.onclick = () => {
            const cfg = {
                gundb: { peers: ['//localhost:8765/gun'], localStorage: false, radisk: false, authToken: 'thisIsTheTokenForReals' },
                walletManager: { enabled: false },  // Disattiva il wallet manager per evitare errori RPC
                social: { enabled: true },
                logging: { enabled: true, level: 'debug', prefix: '[Shogun]' }
            };
            shogun = window.initShogunBrowser(cfg);
            socialPlugin = shogun.getPlugin('social');
            gun = shogun.gun;
            if (socialPlugin) {
                showResult('Inizializzazione completata', 'Il sistema è pronto per l\'uso');
                loginBtn.disabled = false;
                initBtn.disabled = true;
                initBtn.textContent = 'Inizializzato';

                // Mostra la sezione utenti subito dopo l'inizializzazione
                usersSection.style.display = 'block';
            } else {
                showError('Errore', 'Plugin social non trovato');
            }
        };

        // Aggiorna login per ricaricare la lista utenti
        performLogin.onclick = async () => {
            // ... codice di login esistente ...

            try {
                const res = await shogun.login(u, p);
                if (res.success) {
                    // ... resto del codice login esistente ...

                    // Carica gli utenti dopo il login
                    loadAllUsers();
                }
                // ... resto del codice ...
            } catch (error) {
                // ... gestione errori ...
            }
        };

        // Aggiornata per supportare safeId
        function displayComments(postId, comments, safeId) {
            console.log(`Visualizzazione di ${comments.length} commenti per il post ${postId}`);

            // Usa l'ID sicuro fornito o generalo
            const actualSafeId = safeId || generateSafeId(postId);

            const commentsList = document.getElementById(`comments-list-${actualSafeId}`);
            if (!commentsList) {
                console.error(`displayComments: Elemento commenti-list-${actualSafeId} non trovato`);
                return;
            }

            // Pulisci il contenitore
            commentsList.innerHTML = '';

            if (comments.length === 0) {
                commentsList.innerHTML = '<div class="no-comments">Nessun commento per questo post</div>';
                return;
            }

            // Ordina i commenti per timestamp (dal più recente al più vecchio)
            const sortedComments = [...comments].sort((a, b) => {
                const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
                const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
                return timeB - timeA;
            });

            // Crea gli elementi dei commenti
            sortedComments.forEach(comment => {
                try {
                    console.log("Elaborazione commento per visualizzazione:", comment);

                    // Gestione caso in cui comment non ha payload
                    if (!comment) {
                        console.error('displayComments: Commento non valido', comment);
                        return;
                    }

                    // Ottieni il payload o creane uno se non esiste
                    const payload = comment.payload || {};

                    // Ottieni il testo del commento in vari modi possibili
                    let text = '';
                    if (payload.text) {
                        text = payload.text;
                    } else if (payload.content) {
                        text = payload.content;
                    } else if (comment.content) {
                        text = comment.content;
                    }

                    // Controllo di sicurezza: se text è undefined, assegna stringa vuota
                    if (text === undefined) {
                        text = '';
                    }

                    // Se non abbiamo testo ma abbiamo un ID, tentiamo un recupero diretto
                    if ((!text || text === '') && comment.id) {
                        // Il commento esiste ma il contenuto potrebbe non essere stato caricato correttamente
                        console.warn(`Commento ${comment.id} senza contenuto visibile, tentativo di recupero diretto`);

                        // Crea un segnaposto temporaneo
                        text = "Recupero contenuto...";

                        // Aggiorna l'ID commento per poterlo riferire dopo
                        const commentId = comment.id;

                        // Tenta di recuperare il contenuto direttamente da GunDB
                        gun.get("posts").get(postId).get("comments").get(commentId).once(function (data) {
                            if (data && data.content) {
                                console.log(`Recuperato contenuto commento ${commentId} direttamente:`, data.content);

                                // Trova l'elemento del commento per aggiornarlo
                                const commentElement = commentsList.querySelector(`[data-comment-id="${commentId}"]`);
                                if (commentElement) {
                                    const textElement = commentElement.querySelector('.comment-text');
                                    if (textElement) {
                                        textElement.textContent = data.content || "Contenuto non disponibile";
                                        console.log(`Aggiornato contenuto commento ${commentId} nella UI`);
                                    }
                                }
                            } else {
                                console.warn(`Contenuto commento ${commentId} non trovato in GunDB`);
                            }
                        });
                    }

                    // Se dopo tutti i tentativi il testo è ancora vuoto, mostra un messaggio
                    if (!text || text === '') {
                        text = 'Contenuto non disponibile';
                    }

                    // Ottieni l'autore del commento in vari modi possibili
                    let author = 'Anonimo';
                    if (payload.author) {
                        author = payload.author;
                    } else if (comment.author) {
                        author = comment.author;
                    } else if (comment.creator) {
                        author = comment.creator;
                    }

                    // Formatta l'autore per una visualizzazione più leggibile
                    if (author !== 'Anonimo') {
                        // Se l'autore è l'utente corrente, mostra "Tu"
                        if (currentUserPub && (author === currentUserPub)) {
                            author = 'Tu';
                        } else {
                            // Altrimenti mostra una versione abbreviata
                            author = author.slice(0, 8) + '...';
                        }
                    }

                    // Ottieni il timestamp del commento
                    const timestamp = comment.timestamp || payload.timestamp || comment.createdAt || new Date().toISOString();
                    const formattedTime = typeof timestamp === 'string' ? timestamp : new Date(timestamp).toLocaleString();

                    // Crea l'elemento del commento
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'comment';

                    // Assegna un data attribute per poterlo riferire più tardi
                    if (comment.id) {
                        commentDiv.setAttribute('data-comment-id', comment.id);
                    }

                    // Costruisci HTML del commento
                    commentDiv.innerHTML = `
                        <div class="comment-header">
                            <span class="comment-author">${escapeHtml(author)}</span>
                            <span class="comment-time">${escapeHtml(formattedTime)}</span>
                        </div>
                        <div class="comment-text">${escapeHtml(text)}</div>
                    `;

                    commentsList.appendChild(commentDiv);
                } catch (err) {
                    console.error('Errore durante la visualizzazione del commento:', err, comment);
                }
            });
        }

        // ... existing code ...
        // Funzione base per creare un post
        function createPost(post) {
            if (!post || !post.id) {
                console.error('Post non valido:', post);
                return null;
            }

            const safeId = generateSafeId(post.id);
            const p = document.createElement('div');
            p.className = 'post';
            p.setAttribute('data-id', post.id);
            p.setAttribute('data-safe-id', safeId);

            // Formatta autore
            let author = 'Sconosciuto';
            if (post.author) {
                author = (currentUserPub && post.author === currentUserPub)
                    ? 'Tu'
                    : post.author.slice(0, 8) + '...';
            }

            // Assicura contenuto valido
            let content = post.content || (post.payload && post.payload.content) || 'Contenuto non disponibile';
            if (!content || content.trim() === '') content = 'Contenuto non disponibile';

            // Timestamp
            const timestamp = new Date(post.timestamp).toLocaleString();

            // Struttura HTML base
            p.innerHTML = `
                <div class="post-header">
                    <span class="post-author">${author}</span>
                    <span class="post-timestamp">${timestamp}</span>
                    ${(currentUserPub && post.author === currentUserPub) ?
                    `<div class="post-delete">
                            <button class="delete-post-button" data-post-id="${post.id}">🗑️</button>
                         </div>` : ''
                }
                </div>
                <div class="post-content">${content}</div>
                <div class="post-actions">
                    <button class="like-button" data-post-id="${post.id}">❤️ <span class="like-count"></span></button>
                    <button class="unlike-button" data-post-id="${post.id}" style="display: none;">💔</button>
                    <button class="comment-button" data-post-id="${post.id}">💬 <span class="comment-count"></span></button>
                </div>
                <div class="comment-section" data-post-id="${post.id}" style="display:none">
                    <div class="comments-container">
                        <div id="comments-list-${safeId}" class="comments-list"></div>
                    </div>
                    <div class="comment-form">
                        <input type="text" class="comment-input" placeholder="Scrivi un commento..." />
                        <button type="button" class="submit-comment" data-post-id="${post.id}">Invia</button>
                    </div>
                </div>
            `;

            // Aggiungi event listeners
            // Like button
            const likeButton = p.querySelector('.like-button');
            const unlikeButton = p.querySelector('.unlike-button');
            if (likeButton && unlikeButton) {
                likeButton.addEventListener('click', async () => {
                    if (!currentUserPub) {
                        showError('Errore', 'Devi effettuare il login per mettere like');
                        return;
                    }
                    likeButton.disabled = true;
                    try {
                        const hasLiked = await checkLikeStatus(post.id);
                        if (!hasLiked) {
                            await socialPlugin.likePost(post.id);
                            likeButton.classList.add('active');
                            unlikeButton.style.display = 'inline-block';
                        }
                        updateLikes(post.id);
                    } catch (err) {
                        console.error('Errore like:', err);
                    } finally {
                        likeButton.disabled = false;
                    }
                });

                unlikeButton.addEventListener('click', async () => {
                    if (!currentUserPub) {
                        showError('Errore', 'Devi effettuare il login per rimuovere il like');
                        return;
                    }
                    unlikeButton.disabled = true;
                    try {
                        await socialPlugin.unlikePost(post.id);
                        likeButton.classList.remove('active');
                        unlikeButton.style.display = 'none';
                        updateLikes(post.id);
                    } catch (err) {
                        console.error('Errore unlike:', err);
                    } finally {
                        unlikeButton.disabled = false;
                    }
                });
            }

            // Comment button
            const commentButton = p.querySelector('.comment-button');
            const commentSection = p.querySelector('.comment-section');
            if (commentButton && commentSection) {
                commentButton.addEventListener('click', () => {
                    commentSection.style.display = commentSection.style.display === 'block' ? 'none' : 'block';
                    if (commentSection.style.display === 'block') {
                        loadComments(post.id);
                    }
                });
            }

            // Delete post button (solo per i post dell'utente corrente)
            const deletePostButton = p.querySelector('.delete-post-button');
            if (deletePostButton) {
                deletePostButton.addEventListener('click', async () => {
                    if (!currentUserPub) {
                        showError('Errore', 'Devi effettuare il login per eliminare il post');
                        return;
                    }

                    if (confirm('Sei sicuro di voler eliminare questo post?')) {
                        deletePostButton.disabled = true;
                        try {
                            const result = await socialPlugin.deletePost(post.id);
                            if (result) {
                                showResult('Operazione', 'Post eliminato con successo');
                                p.remove(); // Rimuove il post dalla UI
                            } else {
                                showError('Errore', 'Impossibile eliminare il post');
                            }
                        } catch (err) {
                            console.error('Errore eliminazione post:', err);
                            showError('Errore', `Impossibile eliminare il post: ${err.message || 'errore sconosciuto'}`);
                        } finally {
                            deletePostButton.disabled = false;
                        }
                    }
                });
            }

            // Submit comment
            const submitComment = p.querySelector('.submit-comment');
            const commentInput = p.querySelector('.comment-input');
            if (submitComment && commentInput) {
                submitComment.addEventListener('mousedown', function (e) {
                    e.preventDefault(); // Previeni il comportamento di default
                    return false;
                });

                submitComment.addEventListener('click', async (e) => {
                    e.preventDefault(); // Previeni il comportamento di default
                    e.stopPropagation(); // Ferma la propagazione dell'evento

                    const content = commentInput.value.trim();
                    if (!content) return;

                    submitComment.disabled = true;
                    submitComment.textContent = 'Invio...';

                    try {
                        const comment = await addComment(post.id, content);
                        if (comment) {
                            commentInput.value = '';
                            // Mostra l'indicatore di nessun refresh
                            const indicator = document.getElementById('noRefreshIndicator');
                            if (indicator) {
                                indicator.classList.add('visible');
                                setTimeout(() => {
                                    indicator.classList.remove('visible');
                                }, 2000);
                            }
                        }
                    } catch (err) {
                        console.error('Errore invio commento:', err);
                    } finally {
                        submitComment.disabled = false;
                        submitComment.textContent = 'Invia';
                    }

                    return false; // Importante per prevenire ulteriori azioni
                });

                // Gestisci anche il tasto Enter nel campo di input
                commentInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Previeni il comportamento di default
                        submitComment.click(); // Simula il click sul pulsante
                        return false;
                    }
                });
            }

            // Inizializza like
            updateLikes(post.id);

            return p;
        }

        // ... existing code ...

        // Funzione per gestire i tab
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.getAttribute('data-tab');

                    // Rimuovi la classe active da tutti i tab
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));

                    // Aggiungi la classe active al tab selezionato
                    button.classList.add('active');
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                });
            });
        }

        // Funzione per caricare i miei post
        async function loadMyPosts() {
            if (!currentUserPub || !socialPlugin) return;

            const myPostsContainer = document.getElementById('myPostsContainer');
            myPostsContainer.innerHTML = '<div class="loading-timeline">Caricamento dei tuoi post...</div>';

            try {
                // Ottieni la timeline e filtra solo i miei post
                const timeline = await socialPlugin.getTimeline();

                if (timeline.error) {
                    myPostsContainer.innerHTML = `<div class="error-message">Errore: ${timeline.error}</div>`;
                    return;
                }

                const myPosts = timeline.messages.filter(msg => msg.creator === currentUserPub || msg.author === currentUserPub);

                if (!myPosts.length) {
                    myPostsContainer.innerHTML = '<div class="empty-timeline">Non hai ancora pubblicato post.</div>';
                    return;
                }

                // Ordina i post dal più recente al più vecchio
                const sortedPosts = [...myPosts].sort((a, b) => {
                    const timeA = a.createdAt || a.timestamp || 0;
                    const timeB = b.createdAt || b.timestamp || 0;
                    return timeB - timeA;
                });

                myPostsContainer.innerHTML = '';

                sortedPosts.forEach(post => {
                    const postData = {
                        id: post.id,
                        author: post.creator || post.author,
                        content: post.content || (post.payload && post.payload.content) || '',
                        timestamp: post.createdAt || post.timestamp || Date.now()
                    };

                    const postEl = createPost(postData);
                    if (postEl) {
                        postEl.classList.add('own-post');
                        myPostsContainer.appendChild(postEl);
                    }
                });
            } catch (err) {
                console.error('Errore caricamento miei post:', err);
                myPostsContainer.innerHTML = '<div class="error-message">Errore nel caricamento dei post.</div>';
            }
        }

        // Inizializza i tab e aggiorna la funzione di login per caricare i miei post
        window.addEventListener('DOMContentLoaded', function () {
            setupTabs();
        });

        // Modifica anche i gestori di eventi per i campi di input generali
        // Aggiungi questi gestori di eventi dopo la definizione delle variabili DOM
        window.addEventListener('DOMContentLoaded', function () {
            // Previeni il submit del form su tutti gli input text e password
            document.addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                    e.preventDefault(); // Previene il refresh della pagina
                }
            });

            // Imposta anche per il campo di input del post
            if (postContent) {
                postContent.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // Previene il refresh della pagina
                        // Non invia il post automaticamente, permette l'uso di Enter per andare a capo
                    }
                });
            }

            // Gestori di eventi già esistenti...
            setupTabs();
            shortenButtonLabels();
        });

        // ... existing code ...

        // Prevenzione più stringente per i refresh su tutti i campi input
        document.addEventListener('DOMContentLoaded', function () {
            // Ottieni riferimento all'indicatore no-refresh
            const noRefreshIndicator = document.getElementById('noRefreshIndicator');

            // Funzione per mostrare l'indicatore temporaneamente
            function showNoRefreshIndicator(message = 'Azione eseguita senza refresh') {
                if (noRefreshIndicator) {
                    noRefreshIndicator.textContent = message;
                    noRefreshIndicator.classList.add('visible');
                    setTimeout(() => {
                        noRefreshIndicator.classList.remove('visible');
                    }, 1500);
                }
            }

            // Previeni il comportamento predefinito su tutti i form
            document.querySelectorAll('form').forEach(form => {
                form.addEventListener('submit', function (e) {
                    e.preventDefault();
                    console.log("Form submission prevented");
                    showNoRefreshIndicator('Form non inviato - Prevenuto refresh pagina');
                    return false;
                });
            });

            // Previeni il comportamento di default su tutti i campi input quando si preme Enter
            document.querySelectorAll('input').forEach(input => {
                // Aggiungi classe typing durante la digitazione
                input.addEventListener('input', function () {
                    this.classList.add('typing');
                });

                // Rimuovi la classe dopo un po'
                input.addEventListener('blur', function () {
                    this.classList.remove('typing');
                });

                // Gestisci il tasto Enter
                input.addEventListener('keydown', function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log("Enter keypress prevented on input field:", input.id || 'unnamed');

                        // Se è un campo di ricerca o un campo di login, esegui l'azione relativa
                        if (input.id === 'userPubInput' && getProfileBtn) {
                            getProfileBtn.click();
                            showNoRefreshIndicator('Ricerca profilo avviata');
                        } else if (input.id === 'username' && passwordInput.value && performLogin) {
                            performLogin.click();
                            showNoRefreshIndicator('Login in corso...');
                        } else if (input.id === 'password' && usernameInput.value && performLogin) {
                            performLogin.click();
                            showNoRefreshIndicator('Login in corso...');
                        } else if (input.classList.contains('comment-input')) {
                            // Trova il pulsante di invio più vicino e fai clic
                            const submitBtn = input.closest('.comment-form').querySelector('.submit-comment');
                            if (submitBtn) {
                                submitBtn.click();
                                showNoRefreshIndicator('Commento inviato');
                            }
                        } else {
                            showNoRefreshIndicator('Invio premuto - Prevenuto refresh pagina');
                        }
                        return false;
                    }
                });
            });

            // Gestisci anche l'area di testo per i post
            if (postContent) {
                postContent.addEventListener('keydown', function (e) {
                    // Consenti l'invio del post con Ctrl+Enter o Shift+Enter
                    if (e.key === 'Enter' && (e.ctrlKey || e.shiftKey) && createPostBtn && !createPostBtn.disabled) {
                        e.preventDefault();
                        createPostBtn.click();
                        showNoRefreshIndicator('Post inviato');
                    }
                });
            }
        });

        // ... existing code ...

        // Aggiungi un listener super-aggressivo per tutti gli eventi di submit
        document.addEventListener('DOMContentLoaded', function () {
            // Super-intercettore di submit a livello di documento
            document.addEventListener('submit', function (e) {
                console.log('INTERCETTATO SUBMIT A LIVELLO DOCUMENTO', e.target);
                // Blocca sempre tutti i submit
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();

                // Mostra feedback all'utente
                const noRefreshIndicator = document.getElementById('noRefreshIndicator');
                if (noRefreshIndicator) {
                    noRefreshIndicator.textContent = 'Submit bloccato - nessun refresh';
                    noRefreshIndicator.classList.add('visible');
                    setTimeout(() => {
                        noRefreshIndicator.classList.remove('visible');
                    }, 1500);
                }

                return false;
            }, true); // Usa capturing per intercettare prima di tutti

            // Blocca tutti gli Enter su input
            document.addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                    console.log('INTERCETTATO ENTER SU INPUT', e.target);
                    // Blocca sempre il comportamento predefinito
                    e.preventDefault();
                    e.stopPropagation();

                    // Se è un campo commento, gestisci manualmente
                    if (e.target.classList.contains('comment-input')) {
                        const form = e.target.closest('.comment-form');
                        if (form) {
                            const submitBtn = form.querySelector('.submit-comment');
                            if (submitBtn) {
                                // Ritarda leggermente per interrompere la catena di eventi
                                setTimeout(() => {
                                    console.log('Trigger manuale click su submit commento');
                                    submitBtn.click();
                                }, 10);
                            }
                        }
                    }

                    return false;
                }
            }, true); // Usa capturing per intercettare prima di tutti

            // Applica a tutti i pulsanti di submit commento esistenti
            document.querySelectorAll('.submit-comment').forEach(button => {
                button.type = 'button'; // Imposta esplicitamente il tipo
            });
        });
    </script>
</body>

</html>